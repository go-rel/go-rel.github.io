{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"adapters/","text":"Adapters \u00b6 Rel uses adapter in order to generate and execute query to a database, below is the list of available adapters currently supported. Adapter Package Godoc MySQL github.com/Fs02/rel/adapter/mysql PostgreSQL github.com/Fs02/rel/adapter/postgres SQLite3 github.com/Fs02/rel/adapter/sqlite3","title":"Adapters"},{"location":"adapters/#adapters","text":"Rel uses adapter in order to generate and execute query to a database, below is the list of available adapters currently supported. Adapter Package Godoc MySQL github.com/Fs02/rel/adapter/mysql PostgreSQL github.com/Fs02/rel/adapter/postgres SQLite3 github.com/Fs02/rel/adapter/sqlite3","title":"Adapters"},{"location":"association/","text":"Association \u00b6 Defining Association \u00b6 Association in REL can be declared by ensuring that each association have an association field, reference id field and foreign id field. Association field is a field with the type of another struct. Reference id is an id field that can be mapped to the foreign id field in another struct. By following that convention, REL currently supports belongs to , has one and has many association. // User schema. type User struct { ID int Name string Age int CreatedAt time . Time UpdatedAt time . Time // has many transactions. // with custom reference and foreign field declaration. // ref: id refers to User.ID field. // fk: buyer_id refers to Transaction.BuyerID Transactions [] Transaction `ref:\"id\" fk:\"buyer_id\"` // has one address. // doesn't contains primary key of other struct. // REL can guess the reference and foreign field if it's not specified. Address Address } // Transaction schema. type Transaction struct { ID int Item string Status string // belongs to user. // contains primary key of other struct. Buyer User `ref:\"buyer_id\" fk:\"id\"` BuyerID int } // Address schema. type Address struct { ID int City string // belongs to user. User * User UserID * int } Preloading Association \u00b6 Preload will load association to structs. To preload association, use Preload . Preload Transaction's Buyer ( belongs to association): Example err := repo . Preload ( ctx , & transaction , \"buyer\" ) Mock user := User { ID : 1 , Name : \"Nabe\" } repo . ExpectPreload ( \"buyer\" ). Result ( user ) Preload User's Address ( has one association): Example err := repo . Preload ( ctx , & user , \"address\" ) Mock address := Address { ID : 1 , City : \"Nazarick\" } repo . ExpectPreload ( \"address\" ). Result ( address ) Preload User's Transactions ( has many association): Example err := repo . Preload ( ctx , & user , \"transactions\" ) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" ). Result ( transactions ) Preload only paid Transactions from users: Example err := repo . Preload ( ctx , & user , \"transactions\" , where . Eq ( \"status\" , \"paid\" )) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" , where . Eq ( \"status\" , \"paid\" )). Result ( transactions ) Preload every Buyer's Address in Transactions (Buyer needs to be preloaded before preloading Buyer's Address): Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Inserting and Updating Association \u00b6 REL will automatically creates or updates association by using Insert or Update method. If ID of association struct is not a zero value, REL will try to update the association, else it'll create a new association. Note REL will try to create a new record for association if Primary Value ( ID ) is a zero value. Example user := User { Name : \"rel\" , Address : Address { City : \"Bandung\" , }, } // Inserts a new record to users and address table. // Result: User{ID: 1, Name: \"rel\", Address: Address{ID: 1, City: \"Bandung\", UserID: 1}} err := repo . Insert ( ctx , & user ) Mock repo . ExpectInsert (). ForType ( \"main.User\" ) REL will try to update a new record for association if ID is a zero value. To update association, it first needs to be preloaded. Example userID := 1 user := User { ID : 1 , Name : \"rel\" , // association is loaded when the primary key (id) is not zero. Address : Address { ID : 1 , UserID : & userID , City : \"Bandung\" , }, } // Update user record with id 1. // Update address record with id 1. err := repo . Update ( ctx , & user ) Mock repo . ExpectUpdate (). ForType ( \"main.User\" ) To selectively update only specific fields or association, use rel.Map . Example mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record if it's loaded else it'll creates a new address. // only set city to bandung. err := repo . Update ( ctx , & user , mutation ) Mock mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record with id 1, only set city to bandung. repo . ExpectUpdate ( mutation ). ForType ( \"main.User\" )","title":"Association"},{"location":"association/#association","text":"","title":"Association"},{"location":"association/#defining-association","text":"Association in REL can be declared by ensuring that each association have an association field, reference id field and foreign id field. Association field is a field with the type of another struct. Reference id is an id field that can be mapped to the foreign id field in another struct. By following that convention, REL currently supports belongs to , has one and has many association. // User schema. type User struct { ID int Name string Age int CreatedAt time . Time UpdatedAt time . Time // has many transactions. // with custom reference and foreign field declaration. // ref: id refers to User.ID field. // fk: buyer_id refers to Transaction.BuyerID Transactions [] Transaction `ref:\"id\" fk:\"buyer_id\"` // has one address. // doesn't contains primary key of other struct. // REL can guess the reference and foreign field if it's not specified. Address Address } // Transaction schema. type Transaction struct { ID int Item string Status string // belongs to user. // contains primary key of other struct. Buyer User `ref:\"buyer_id\" fk:\"id\"` BuyerID int } // Address schema. type Address struct { ID int City string // belongs to user. User * User UserID * int }","title":"Defining Association"},{"location":"association/#preloading-association","text":"Preload will load association to structs. To preload association, use Preload . Preload Transaction's Buyer ( belongs to association): Example err := repo . Preload ( ctx , & transaction , \"buyer\" ) Mock user := User { ID : 1 , Name : \"Nabe\" } repo . ExpectPreload ( \"buyer\" ). Result ( user ) Preload User's Address ( has one association): Example err := repo . Preload ( ctx , & user , \"address\" ) Mock address := Address { ID : 1 , City : \"Nazarick\" } repo . ExpectPreload ( \"address\" ). Result ( address ) Preload User's Transactions ( has many association): Example err := repo . Preload ( ctx , & user , \"transactions\" ) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" ). Result ( transactions ) Preload only paid Transactions from users: Example err := repo . Preload ( ctx , & user , \"transactions\" , where . Eq ( \"status\" , \"paid\" )) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" , where . Eq ( \"status\" , \"paid\" )). Result ( transactions ) Preload every Buyer's Address in Transactions (Buyer needs to be preloaded before preloading Buyer's Address): Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses )","title":"Preloading Association"},{"location":"association/#inserting-and-updating-association","text":"REL will automatically creates or updates association by using Insert or Update method. If ID of association struct is not a zero value, REL will try to update the association, else it'll create a new association. Note REL will try to create a new record for association if Primary Value ( ID ) is a zero value. Example user := User { Name : \"rel\" , Address : Address { City : \"Bandung\" , }, } // Inserts a new record to users and address table. // Result: User{ID: 1, Name: \"rel\", Address: Address{ID: 1, City: \"Bandung\", UserID: 1}} err := repo . Insert ( ctx , & user ) Mock repo . ExpectInsert (). ForType ( \"main.User\" ) REL will try to update a new record for association if ID is a zero value. To update association, it first needs to be preloaded. Example userID := 1 user := User { ID : 1 , Name : \"rel\" , // association is loaded when the primary key (id) is not zero. Address : Address { ID : 1 , UserID : & userID , City : \"Bandung\" , }, } // Update user record with id 1. // Update address record with id 1. err := repo . Update ( ctx , & user ) Mock repo . ExpectUpdate (). ForType ( \"main.User\" ) To selectively update only specific fields or association, use rel.Map . Example mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record if it's loaded else it'll creates a new address. // only set city to bandung. err := repo . Update ( ctx , & user , mutation ) Mock mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record with id 1, only set city to bandung. repo . ExpectUpdate ( mutation ). ForType ( \"main.User\" )","title":"Inserting and Updating Association"},{"location":"basics/","text":"Basics \u00b6 Full Example \u00b6 Below is a very basic example on how to utilize REL using mysql adapter. Testing database query using REL can be done using reltest package. main.go package main import ( \"context\" \"time\" \"github.com/Fs02/rel\" \"github.com/Fs02/rel/adapter/mysql\" \"github.com/Fs02/rel/where\" _ \"github.com/go-sql-driver/mysql\" ) // Author is a model that maps to authors table. type Author struct { ID int Name string } // Book is a model that maps to books table. type Book struct { ID int Title string Category string Price int Discount bool Stock int AuthorID int Author Author CreatedAt time . Time UpdatedAt time . Time } var dsn = \"root@(127.0.0.1:3306)/db?charset=utf8&parseTime=True&loc=Local\" func main () { // initialize mysql adapter. adapter , _ := mysql . Open ( dsn ) defer adapter . Close () // initialize rel's repo. repo := rel . New ( adapter ) // run Example ( context . Background (), repo ) } // Example is an actual service function that run a complex business package. // beware: it's actually doing nonsense here. func Example ( ctx context . Context , repo rel . Repository ) error { var book Book // Quickly find a book with id 1 using short alias. if err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )); err != nil { return err } // Or use chainable query builder. query := rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 ) if err := repo . Find ( ctx , & book , query ); err != nil { return err } // Convenient method to preload Book's Author. if err := repo . Preload ( ctx , & book , \"author\" ); err != nil { return err } // Performs updates inside a transaction. return repo . Transaction ( ctx , func ( ctx context . Context ) error { // basic update using struct. book . Title = \"REL for dummies\" repo . MustUpdate ( ctx , & book ) // update only specific fields. repo . MustUpdate ( ctx , & book , rel . Set ( \"discount\" , false )) // it even supports atomic inc/dec mutation. return repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) }) } main_test.go package main import ( \"context\" \"testing\" \"github.com/Fs02/rel\" \"github.com/Fs02/rel/reltest\" \"github.com/Fs02/rel/where\" \"github.com/stretchr/testify/assert\" ) func TestExample ( t * testing . T ) { // create a mocked repository. var ( repo = reltest . New () book = Book { ID : 1 , Title : \"Go for dummies\" , Category : \"learning\" , AuthorID : 1 , } author = Author { ID : 1 , Name : \"CZ2I28 Delta\" } ) // mock find and return result repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) // mock find and return result using query builder. repo . ExpectFind ( rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 )). Result ( book ) // mock preload and return result repo . ExpectPreload ( \"author\" ). ForType ( \"main.Book\" ). Result ( author ) // mocks transaction repo . ExpectTransaction ( func ( repo * reltest . Repository ) { // mock updates repo . ExpectUpdate (). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"discount\" , false )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) }) // run and asserts assert . Nil ( t , Example ( context . Background (), repo )) repo . AssertExpectations ( t ) } Other Examples \u00b6 go-todo-backend - Todo Backend Conventions \u00b6 Schema Definition \u00b6 REL uses a struct as the schema to infer table name , columns and primary field . // Table name: books type Book struct { ID int // id Title string // title Category string // category CreatedAt time . Time // created_at UpdatedAt time . Time // updated_at } Table Name \u00b6 Table name will be the pluralized struct name in snake case, you may create a Table() string method to override the default table name. // Default table name is `books` type Book struct {} // Override table name to be `ebooks` func ( b Book ) Table () string { return \"ebooks\" } Column Name \u00b6 Column name will be the struct field name in snake case, you may override the column name by using using db tag. type Book struct { ID int // this field will be mapped to `id` column. Title string `db:\"name\"` // this field will be mapped to `name` column. Category string `db:\"-\"` // this field will be skipped } Primary Key \u00b6 REL requires every struct to have at least primary key. by default field named id will be used as primary key. To use other field as primary key, you may define it as primary using db tag. Defining multiple field as primary will forms composite primary key. type Book struct { UUID string `db:\"uuid,primary\"` // or just `db:\",primary\"` } Timestamp \u00b6 REL automatically track created and updated time of each struct if CreatedAt or UpdatedAt field exists.","title":"Basics"},{"location":"basics/#basics","text":"","title":"Basics"},{"location":"basics/#full-example","text":"Below is a very basic example on how to utilize REL using mysql adapter. Testing database query using REL can be done using reltest package. main.go package main import ( \"context\" \"time\" \"github.com/Fs02/rel\" \"github.com/Fs02/rel/adapter/mysql\" \"github.com/Fs02/rel/where\" _ \"github.com/go-sql-driver/mysql\" ) // Author is a model that maps to authors table. type Author struct { ID int Name string } // Book is a model that maps to books table. type Book struct { ID int Title string Category string Price int Discount bool Stock int AuthorID int Author Author CreatedAt time . Time UpdatedAt time . Time } var dsn = \"root@(127.0.0.1:3306)/db?charset=utf8&parseTime=True&loc=Local\" func main () { // initialize mysql adapter. adapter , _ := mysql . Open ( dsn ) defer adapter . Close () // initialize rel's repo. repo := rel . New ( adapter ) // run Example ( context . Background (), repo ) } // Example is an actual service function that run a complex business package. // beware: it's actually doing nonsense here. func Example ( ctx context . Context , repo rel . Repository ) error { var book Book // Quickly find a book with id 1 using short alias. if err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )); err != nil { return err } // Or use chainable query builder. query := rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 ) if err := repo . Find ( ctx , & book , query ); err != nil { return err } // Convenient method to preload Book's Author. if err := repo . Preload ( ctx , & book , \"author\" ); err != nil { return err } // Performs updates inside a transaction. return repo . Transaction ( ctx , func ( ctx context . Context ) error { // basic update using struct. book . Title = \"REL for dummies\" repo . MustUpdate ( ctx , & book ) // update only specific fields. repo . MustUpdate ( ctx , & book , rel . Set ( \"discount\" , false )) // it even supports atomic inc/dec mutation. return repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) }) } main_test.go package main import ( \"context\" \"testing\" \"github.com/Fs02/rel\" \"github.com/Fs02/rel/reltest\" \"github.com/Fs02/rel/where\" \"github.com/stretchr/testify/assert\" ) func TestExample ( t * testing . T ) { // create a mocked repository. var ( repo = reltest . New () book = Book { ID : 1 , Title : \"Go for dummies\" , Category : \"learning\" , AuthorID : 1 , } author = Author { ID : 1 , Name : \"CZ2I28 Delta\" } ) // mock find and return result repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) // mock find and return result using query builder. repo . ExpectFind ( rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 )). Result ( book ) // mock preload and return result repo . ExpectPreload ( \"author\" ). ForType ( \"main.Book\" ). Result ( author ) // mocks transaction repo . ExpectTransaction ( func ( repo * reltest . Repository ) { // mock updates repo . ExpectUpdate (). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"discount\" , false )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) }) // run and asserts assert . Nil ( t , Example ( context . Background (), repo )) repo . AssertExpectations ( t ) }","title":"Full Example"},{"location":"basics/#other-examples","text":"go-todo-backend - Todo Backend","title":"Other Examples"},{"location":"basics/#conventions","text":"","title":"Conventions"},{"location":"basics/#schema-definition","text":"REL uses a struct as the schema to infer table name , columns and primary field . // Table name: books type Book struct { ID int // id Title string // title Category string // category CreatedAt time . Time // created_at UpdatedAt time . Time // updated_at }","title":"Schema Definition"},{"location":"basics/#table-name","text":"Table name will be the pluralized struct name in snake case, you may create a Table() string method to override the default table name. // Default table name is `books` type Book struct {} // Override table name to be `ebooks` func ( b Book ) Table () string { return \"ebooks\" }","title":"Table Name"},{"location":"basics/#column-name","text":"Column name will be the struct field name in snake case, you may override the column name by using using db tag. type Book struct { ID int // this field will be mapped to `id` column. Title string `db:\"name\"` // this field will be mapped to `name` column. Category string `db:\"-\"` // this field will be skipped }","title":"Column Name"},{"location":"basics/#primary-key","text":"REL requires every struct to have at least primary key. by default field named id will be used as primary key. To use other field as primary key, you may define it as primary using db tag. Defining multiple field as primary will forms composite primary key. type Book struct { UUID string `db:\"uuid,primary\"` // or just `db:\",primary\"` }","title":"Primary Key"},{"location":"basics/#timestamp","text":"REL automatically track created and updated time of each struct if CreatedAt or UpdatedAt field exists.","title":"Timestamp"},{"location":"crud/","text":"Reading and Writing Record \u00b6 Create \u00b6 A new record can be inserted to database using a struct, map or set function. To insert a new record using a struct, simply pass the pointer to the instance as the only argment. Insertion using struct will update created_at and updated_at field if any. Note reltest.Repository will automatically sets any primary key value to be 1. Inserting a record: Example book := Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, } // Insert directly using struct. err := repo . Insert ( ctx , & book ) Mock Any repo . ExpectInsert () Mock by Record repo . ExpectInsert (). For ( & Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, }) Mock by Type repo . ExpectInsert (). ForType ( \"main.Book\" ) Mock Error repo . ExpectInsert (). ForType ( \"main.Book\" ). Error ( errors . New ( \"oops\" )) To inserts multiple records at once, use InsertAll : Example books := [] Book { { Title : \"Golang for dummies\" , Category : \"education\" , }, { Title : \"Rel for dummies\" , Category : \"education\" , }, } err := repo . InsertAll ( ctx , & books ) Mock repo . ExpectInsertAll (). ForType ( \"[]main.Book\" ) Read \u00b6 REL provides a powerful API for querying record from database. To query a record, simply use the Find method, it's accept the returned result as the first argument, and the conditions for the rest arguments. Retrieve a book with id 1: Example var book Book err := repo . Find ( ctx , & book , rel . Eq ( \"id\" , 1 )) Mock book := Book { Title : \"Rel for dummies\" , Category : \"education\" , } repo . ExpectFind ( rel . Eq ( \"id\" , 1 )). Result ( book ) Retrieve a book with id 1 using syntactic sugar: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock repo . ExpectFind ( where . Eq ( \"id\" , 1 )). NotFound () Querying multiple records using FindAll method: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } repo . ExpectFindAll ( where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ). Result ( books ) Using chainable query api for a more complex query use case: Example var books [] Book query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) err := repo . FindAll ( ctx , & books , query ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) repo . ExpectFindAll ( query ). Result ( books ) Update \u00b6 Similar to create, updating a record in REL can also be done using struct, map or set function. Updating using struct will also update updated_at field if any. An update using struct will cause all fields and association to be saved to database, regardless of whether it's been updated or not. Use rel.Map , rel.Set or rel.Changeset to update only specific fields. Note When updating belongs to association, it's recommended to not expose reference key ( [other]_id ) for updates directly from user, since there's no way to validate belongs to association using query. Updating a record: Example book . Title = \"REL for dummies\" err := repo . Update ( ctx , & book ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Updating multiple records is possible using UpdateAll : Example err := repo . UpdateAll ( ctx , rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Mock repo . ExpectUpdateAll ( rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Delete \u00b6 To delete a record in rel, simply pass the record to be deleted. Note REL will automatically apply soft-delete if DeletedAt time.Time field exists in a struct. To query soft-deleted records, use rel.Unscoped(true) when querying. Deleting a record: Example err := repo . Delete ( ctx , & book ) Mock repo . ExpectDelete (). For ( & book ) Deleting multiple records: Example err := repo . DeleteAll ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 ))) Mock repo . ExpectDeleteAll ( rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 )))","title":"Reading and Writing Record"},{"location":"crud/#reading-and-writing-record","text":"","title":"Reading and Writing Record"},{"location":"crud/#create","text":"A new record can be inserted to database using a struct, map or set function. To insert a new record using a struct, simply pass the pointer to the instance as the only argment. Insertion using struct will update created_at and updated_at field if any. Note reltest.Repository will automatically sets any primary key value to be 1. Inserting a record: Example book := Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, } // Insert directly using struct. err := repo . Insert ( ctx , & book ) Mock Any repo . ExpectInsert () Mock by Record repo . ExpectInsert (). For ( & Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, }) Mock by Type repo . ExpectInsert (). ForType ( \"main.Book\" ) Mock Error repo . ExpectInsert (). ForType ( \"main.Book\" ). Error ( errors . New ( \"oops\" )) To inserts multiple records at once, use InsertAll : Example books := [] Book { { Title : \"Golang for dummies\" , Category : \"education\" , }, { Title : \"Rel for dummies\" , Category : \"education\" , }, } err := repo . InsertAll ( ctx , & books ) Mock repo . ExpectInsertAll (). ForType ( \"[]main.Book\" )","title":"Create"},{"location":"crud/#read","text":"REL provides a powerful API for querying record from database. To query a record, simply use the Find method, it's accept the returned result as the first argument, and the conditions for the rest arguments. Retrieve a book with id 1: Example var book Book err := repo . Find ( ctx , & book , rel . Eq ( \"id\" , 1 )) Mock book := Book { Title : \"Rel for dummies\" , Category : \"education\" , } repo . ExpectFind ( rel . Eq ( \"id\" , 1 )). Result ( book ) Retrieve a book with id 1 using syntactic sugar: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock repo . ExpectFind ( where . Eq ( \"id\" , 1 )). NotFound () Querying multiple records using FindAll method: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } repo . ExpectFindAll ( where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ). Result ( books ) Using chainable query api for a more complex query use case: Example var books [] Book query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) err := repo . FindAll ( ctx , & books , query ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) repo . ExpectFindAll ( query ). Result ( books )","title":"Read"},{"location":"crud/#update","text":"Similar to create, updating a record in REL can also be done using struct, map or set function. Updating using struct will also update updated_at field if any. An update using struct will cause all fields and association to be saved to database, regardless of whether it's been updated or not. Use rel.Map , rel.Set or rel.Changeset to update only specific fields. Note When updating belongs to association, it's recommended to not expose reference key ( [other]_id ) for updates directly from user, since there's no way to validate belongs to association using query. Updating a record: Example book . Title = \"REL for dummies\" err := repo . Update ( ctx , & book ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Updating multiple records is possible using UpdateAll : Example err := repo . UpdateAll ( ctx , rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Mock repo . ExpectUpdateAll ( rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true ))","title":"Update"},{"location":"crud/#delete","text":"To delete a record in rel, simply pass the record to be deleted. Note REL will automatically apply soft-delete if DeletedAt time.Time field exists in a struct. To query soft-deleted records, use rel.Unscoped(true) when querying. Deleting a record: Example err := repo . Delete ( ctx , & book ) Mock repo . ExpectDelete (). For ( & book ) Deleting multiple records: Example err := repo . DeleteAll ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 ))) Mock repo . ExpectDeleteAll ( rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 )))","title":"Delete"},{"location":"instrumentation/","text":"Instrumentation \u00b6 REL provides hooks that can be used to log or instrument your queries. repo . Instrumentation ( func ( ctx context . Context , op string , message string ) func ( err error ) { t := time . Now () return func ( err error ) { duration := time . Since ( t ) log . Print ( \"[duration: \" , duration , \" op: \" , op , \"] \" , message , \" - \" , err ) } }) This is the list for available operations: rel-aggregate rel-count rel-find rel-find-all rel-find-and-count-all rel-scan-one rel-scan-all rel-scan-multi rel-insert rel-insert-all rel-update rel-delete rel-delete-all rel-preload rel-transaction adapter-aggregate adapter-query adapter-exec adapter-begin adapter-commit adapter-rollback","title":"Instrumentation"},{"location":"instrumentation/#instrumentation","text":"REL provides hooks that can be used to log or instrument your queries. repo . Instrumentation ( func ( ctx context . Context , op string , message string ) func ( err error ) { t := time . Now () return func ( err error ) { duration := time . Since ( t ) log . Print ( \"[duration: \" , duration , \" op: \" , op , \"] \" , message , \" - \" , err ) } }) This is the list for available operations: rel-aggregate rel-count rel-find rel-find-all rel-find-and-count-all rel-scan-one rel-scan-all rel-scan-multi rel-insert rel-insert-all rel-update rel-delete rel-delete-all rel-preload rel-transaction adapter-aggregate adapter-query adapter-exec adapter-begin adapter-commit adapter-rollback","title":"Instrumentation"},{"location":"introduction/","text":"Introduction \u00b6 REL is golang orm-ish database layer for layered architecture. It's testable and comes with it's own test library. REL also features extendable query builder that allows you to write query using builder or plain sql. Features \u00b6 Testable repository with builtin reltest package. Elegant, yet extendable query builder with mix of syntactic sugar. Supports Eager loading. Supports nested transactions. Composite Primary Key. Multi adapter. Soft Deletion. Pagination. Schema Migration. Install \u00b6 go get github.com/Fs02/rel Why rel \u00b6 Most (if not all) orm for golang is written as a chainable API, meaning all of the query need to be called before performing actual action as a chain of method invocations. example: db . Where ( \"id = ?\" , 1 ). First ( & user ) Chainable api is very hard to be unit tested without writing a wrapper. One way to make it testable is to make an interface that also acts as a wrapper, which is usually ends up as its own repository package resides somewhere in your project: // mockable interface. type UserRepository interface { Find ( user * User , id int ) error } // actual implementation type userRepository struct { db * DB } func ( ur userRepository ) Find ( user * User , id int ) error { return db . Where ( \"id = ?\" , 1 ). First ( & user ) } Compared to other orm, REL api is built with testability in mind. REL uses interface to define contract of every database query or execution, all while making a chainable query possible. The ultimate goal of REL is to be your database package without the needs of making your own wrapper.","title":"Introduction"},{"location":"introduction/#introduction","text":"REL is golang orm-ish database layer for layered architecture. It's testable and comes with it's own test library. REL also features extendable query builder that allows you to write query using builder or plain sql.","title":"Introduction"},{"location":"introduction/#features","text":"Testable repository with builtin reltest package. Elegant, yet extendable query builder with mix of syntactic sugar. Supports Eager loading. Supports nested transactions. Composite Primary Key. Multi adapter. Soft Deletion. Pagination. Schema Migration.","title":"Features"},{"location":"introduction/#install","text":"go get github.com/Fs02/rel","title":"Install"},{"location":"introduction/#why-rel","text":"Most (if not all) orm for golang is written as a chainable API, meaning all of the query need to be called before performing actual action as a chain of method invocations. example: db . Where ( \"id = ?\" , 1 ). First ( & user ) Chainable api is very hard to be unit tested without writing a wrapper. One way to make it testable is to make an interface that also acts as a wrapper, which is usually ends up as its own repository package resides somewhere in your project: // mockable interface. type UserRepository interface { Find ( user * User , id int ) error } // actual implementation type userRepository struct { db * DB } func ( ur userRepository ) Find ( user * User , id int ) error { return db . Where ( \"id = ?\" , 1 ). First ( & user ) } Compared to other orm, REL api is built with testability in mind. REL uses interface to define contract of every database query or execution, all while making a chainable query possible. The ultimate goal of REL is to be your database package without the needs of making your own wrapper.","title":"Why rel"},{"location":"mutations/","text":"Mutations \u00b6 Basic Mutator \u00b6 REL uses mutator to define inserts and updates operation. Using basic mutator won't update created_at and updated_at fields. Mutator Description Dec(field string) Decrement a field value by 1 DecBy(field string, n int) Decrement a field value by n Inc(field string) Increase a field value by 1 IncBy(field string, n int) Increase a field value by n Set(field string, value interface{}) Set a value to a field SetFragment(raw string, args ...interface{}) Set a value of a field using SQL fragment Set title and category values: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ). For ( & book ) Decrement stock: Example err := repo . Update ( ctx , & book , rel . DecBy ( \"stock\" , 2 )) Mock repo . ExpectUpdate ( rel . DecBy ( \"stock\" , 2 )). For ( & book ) Update title using SQL fragment: Example err := repo . Update ( ctx , & book , rel . SetFragment ( \"title=?\" , \"REL for dummies\" )) Mock repo . ExpectUpdate ( rel . SetFragment ( \"title=?\" , \"REL for dummies\" )). For ( & book ) Structset \u00b6 Structset is a mutator that generates list of Set mutators based on a struct value. Using Structset will result in replacing the intire record in the database using provided struct, It'll always clear a has many association and re-insert it on updates if it's loaded. Changeset can be used to avoid clearing has many association on updates. Note Structset is the default mutator used when none is provided explicitly. Inserting a struct using structset mutator: Example structset := rel . NewStructset ( & book , false ) err := repo . Insert ( ctx , & book , structset ) Mock repo . ExpectInsert (). For ( & book ) Changeset \u00b6 Changeset allows you to track and update only updated values and asssociation to database. This is very efficient when dealing with a complex struct that contains a lot of fields and associations. Update only price and discount field using changeset: Example changeset := rel . NewChangeset ( & book ) book . Price = 10 if changeset . FieldChanged ( \"price\" ) { book . Discount = false } err := repo . Update ( ctx , & book , changeset ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Map \u00b6 Map allows to define group of Set mutator, this is intended to be use internally and not to be exposed directly to user. Mutation defined in the map will be applied to the struct passed as the first argument. Insert/Update using map wont update created_at or updated_at field. Insert books and its author using Map : Example data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } // Insert using map. err := repo . Insert ( ctx , & book , data ) Mock data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } repo . ExpectInsert ( data ). ForType ( \"main.Book\" ) Reloading Updated Struct \u00b6 By default, only Inc , IncBy , Dec , DecBy and SetFragment will reload struct from database, Reload mutator can be used to manually trigger reload after inserts/update operations. Update title and force reload: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ). For ( & book ) Cascade Operations \u00b6 REL supports insert/update/delete record and it's associations. Disable cascade insert (default enabled): Example err := repo . Insert ( ctx , & book , rel . Cascade ( false )) Mock repo . ExpectInsert ( rel . Cascade ( false )). For ( & book ) Enable cascade delete (default disabled): Example err := repo . Delete ( ctx , & book , rel . Cascade ( true )) Mock repo . ExpectDelete ( rel . Cascade ( true )). For ( & book )","title":"Mutations"},{"location":"mutations/#mutations","text":"","title":"Mutations"},{"location":"mutations/#basic-mutator","text":"REL uses mutator to define inserts and updates operation. Using basic mutator won't update created_at and updated_at fields. Mutator Description Dec(field string) Decrement a field value by 1 DecBy(field string, n int) Decrement a field value by n Inc(field string) Increase a field value by 1 IncBy(field string, n int) Increase a field value by n Set(field string, value interface{}) Set a value to a field SetFragment(raw string, args ...interface{}) Set a value of a field using SQL fragment Set title and category values: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ). For ( & book ) Decrement stock: Example err := repo . Update ( ctx , & book , rel . DecBy ( \"stock\" , 2 )) Mock repo . ExpectUpdate ( rel . DecBy ( \"stock\" , 2 )). For ( & book ) Update title using SQL fragment: Example err := repo . Update ( ctx , & book , rel . SetFragment ( \"title=?\" , \"REL for dummies\" )) Mock repo . ExpectUpdate ( rel . SetFragment ( \"title=?\" , \"REL for dummies\" )). For ( & book )","title":"Basic Mutator"},{"location":"mutations/#structset","text":"Structset is a mutator that generates list of Set mutators based on a struct value. Using Structset will result in replacing the intire record in the database using provided struct, It'll always clear a has many association and re-insert it on updates if it's loaded. Changeset can be used to avoid clearing has many association on updates. Note Structset is the default mutator used when none is provided explicitly. Inserting a struct using structset mutator: Example structset := rel . NewStructset ( & book , false ) err := repo . Insert ( ctx , & book , structset ) Mock repo . ExpectInsert (). For ( & book )","title":"Structset"},{"location":"mutations/#changeset","text":"Changeset allows you to track and update only updated values and asssociation to database. This is very efficient when dealing with a complex struct that contains a lot of fields and associations. Update only price and discount field using changeset: Example changeset := rel . NewChangeset ( & book ) book . Price = 10 if changeset . FieldChanged ( \"price\" ) { book . Discount = false } err := repo . Update ( ctx , & book , changeset ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" )","title":"Changeset"},{"location":"mutations/#map","text":"Map allows to define group of Set mutator, this is intended to be use internally and not to be exposed directly to user. Mutation defined in the map will be applied to the struct passed as the first argument. Insert/Update using map wont update created_at or updated_at field. Insert books and its author using Map : Example data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } // Insert using map. err := repo . Insert ( ctx , & book , data ) Mock data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } repo . ExpectInsert ( data ). ForType ( \"main.Book\" )","title":"Map"},{"location":"mutations/#reloading-updated-struct","text":"By default, only Inc , IncBy , Dec , DecBy and SetFragment will reload struct from database, Reload mutator can be used to manually trigger reload after inserts/update operations. Update title and force reload: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ). For ( & book )","title":"Reloading Updated Struct"},{"location":"mutations/#cascade-operations","text":"REL supports insert/update/delete record and it's associations. Disable cascade insert (default enabled): Example err := repo . Insert ( ctx , & book , rel . Cascade ( false )) Mock repo . ExpectInsert ( rel . Cascade ( false )). For ( & book ) Enable cascade delete (default disabled): Example err := repo . Delete ( ctx , & book , rel . Cascade ( true )) Mock repo . ExpectDelete ( rel . Cascade ( true )). For ( & book )","title":"Cascade Operations"},{"location":"queries/","text":"Queries \u00b6 Retrieving Data \u00b6 REL provides two basic finders method, Find for retrieving single record, and FindAll for retrieving multiple record. Note Find only accepts struct as the first argument, and always return the first result from the query. FindAll only accepts slice as the first argument, and always return all result from the query. Retrieve a book where id=1: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock book := Book { ID : 1 , Title : \"REL for dummies\" } repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) Retrieve all books: Example var books [] Book err := repo . FindAll ( ctx , & books ) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll (). Result ( books ) Conditions \u00b6 To retrieve filtered recods from database, you can use filter api to specify condition . For example, to filter all books that available, you can use rel.Eq in the query builder. Retrieve all available books using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true )). Result ( books ) Alias can be used to boost readability when dealing with short query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true )). Result ( books ) Use fragment to specify custom SQL query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Fragment ( \"available=?\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Fragment ( \"available=?\" , true )). Result ( books ) You can use rel.And or rel.Or to specify more conditions. Retrieve all available books where price is at least 100 or in discount using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using chained filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using alias ( github.com/Fs02/rel/where ): Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Sorting \u00b6 To retrieve records from database in a specific order, you can use the sort api. Sort books ascending by updated_at field: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . NewSortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . NewSortAsc ( \"updated_at\" )). Result ( books ) Using alias if you need more syntactic sugar: Example var books [] Book err := repo . FindAll ( ctx , & books , sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( sort . Asc ( \"updated_at\" )). Result ( books ) Combining with other query is fairly easy. Chain where and sort using query builder: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )). Result ( books ) It's also possible to use variadic arguments to combine multiple queries: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )). Result ( books ) Selecting Specific Fields \u00b6 To select specific fields, you can use Select method, this way only specificied field will be mapped to books. Note Specifying select without argument ( rel.Select() ) will automatically load all fields. This is helpful when used as query builder entry point (compared to using rel.From ), because you can let REL to infer the table name. Load only id and title: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" )). Result ( books ) Using Specific Table \u00b6 By default, REL will use pluralized-snakecase struct name as the table name. To select from specific table, you can use From method. Load from ebooks table: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . From ( \"ebooks\" )). Result ( books ) Chain the query with select: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )). Result ( books ) Limit and Offset \u00b6 To set the limit and offset of query, use Limit and Offset api. Offset will be ignored if Limit is not specified. Specify limit and offset: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Limit ( 10 ), rel . Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Limit ( 10 ), rel . Offset ( 20 )). Result ( books ) As a chainable api: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select (). Limit ( 10 ). Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select (). Limit ( 10 ). Offset ( 20 )). Result ( books ) Group \u00b6 To use group by query, you can use Group method. Retrieve count of books for every category: Example // custom struct to store the result. var results [] struct { Category string Total int } // we need to explicitly specify table name since we are using an anonymous struct. err := repo . FindAll ( ctx , & results , rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )) Mock results := [] struct { Category string Total int }{ { Category : \"education\" , Total : 100 }, } repo . ExpectFindAll ( rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )). Result ( results ) Joining Tables \u00b6 To join tables, you can use join api. Note Joining table won't load the association to struct. If you want to load association on a struct, use preload instead. Join transaction and book table, then filter only transaction that have specified book name. This methods assumes belongs to relation, which means it'll try to join using transactions.book_id=books.id : Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))). Result ( transactions ) Specifying which column to join using JoinOn: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Syntactic sugar also available for join: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Joining table with custom join mode: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Use fragment for more complex join query: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )). Result ( transactions ) Pessimistic Locking \u00b6 REL supports pessimistic locking by using mechanism provided by the underlying database. Lock can be only used only inside transaction. Retrieve and lock a row for update: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )). Result ( book ) Retrieve and lock a row using predefined lock alias: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . ForUpdate ()) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . ForUpdate ()). Result ( book ) Retrieve and lock a row using chained query: Example var book Book err := repo . Find ( ctx , & book , rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )). Result ( book ) Aggregation \u00b6 REL provides a very basic Aggregate method which can be used to count, sum, max etc. Count all available books using aggregate: Example count , err := repo . Aggregate ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ) Mock repo . ExpectAggregate ( rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ). Result ( 5 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" ) Mock repo . ExpectCount ( \"books\" ). Result ( 7 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" , where . Eq ( \"available\" , true )) Mock repo . ExpectCount ( \"books\" , where . Eq ( \"available\" , true )). Result ( 5 ) Pagination \u00b6 REL provides a convenient FindAndCountAll methods that is useful for pagination, It's a combination of FindAll and Count method. FindAndCountAll returns count of records (ignoring limit and offset query) and an error. Retrieve all books within limit and offset and also count of all books: Example var books [] Book count , err := repo . FindAndCountAll ( ctx , & books , rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAndCountAll ( rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )). Result ( books , 12 ) Batch Iteration \u00b6 REL provides records iterator that can be use for perform batch processing of large amounts of records. Options: BatchSize - The size of batches (default 1000). Start - The primary value (ID) to start from (inclusive). Finish - The primary value (ID) to finish at (inclusive). Example var ( user User iter = repo . Iterate ( ctx , rel . From ( \"users\" ), rel . BatchSize ( 500 )) ) // make sure iterator is closed after process is finish. defer iter . Close () for { // retrieve next user. if err := iter . Next ( & user ); err != nil { if err == io . EOF { break } // handle error return err } // process user SendPromotionEmail ( & user ) } Mock users := make ([] User , 5 ) repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). Result ( users ) Mock Error repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). ConnectionClosed () Native SQL Query \u00b6 REL allows querying using native SQL query, this is especially useful when using complex query that cannot be covered with the query builder. Retrieve a book using native sql query: Example var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) err := repo . Find ( ctx , & book , sql ) Mock var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) repo . ExpectFind ( sql ). Result ( book )","title":"Queries"},{"location":"queries/#queries","text":"","title":"Queries"},{"location":"queries/#retrieving-data","text":"REL provides two basic finders method, Find for retrieving single record, and FindAll for retrieving multiple record. Note Find only accepts struct as the first argument, and always return the first result from the query. FindAll only accepts slice as the first argument, and always return all result from the query. Retrieve a book where id=1: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock book := Book { ID : 1 , Title : \"REL for dummies\" } repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) Retrieve all books: Example var books [] Book err := repo . FindAll ( ctx , & books ) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll (). Result ( books )","title":"Retrieving Data"},{"location":"queries/#conditions","text":"To retrieve filtered recods from database, you can use filter api to specify condition . For example, to filter all books that available, you can use rel.Eq in the query builder. Retrieve all available books using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true )). Result ( books ) Alias can be used to boost readability when dealing with short query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true )). Result ( books ) Use fragment to specify custom SQL query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Fragment ( \"available=?\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Fragment ( \"available=?\" , true )). Result ( books ) You can use rel.And or rel.Or to specify more conditions. Retrieve all available books where price is at least 100 or in discount using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using chained filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using alias ( github.com/Fs02/rel/where ): Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books )","title":"Conditions"},{"location":"queries/#sorting","text":"To retrieve records from database in a specific order, you can use the sort api. Sort books ascending by updated_at field: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . NewSortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . NewSortAsc ( \"updated_at\" )). Result ( books ) Using alias if you need more syntactic sugar: Example var books [] Book err := repo . FindAll ( ctx , & books , sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( sort . Asc ( \"updated_at\" )). Result ( books ) Combining with other query is fairly easy. Chain where and sort using query builder: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )). Result ( books ) It's also possible to use variadic arguments to combine multiple queries: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )). Result ( books )","title":"Sorting"},{"location":"queries/#selecting-specific-fields","text":"To select specific fields, you can use Select method, this way only specificied field will be mapped to books. Note Specifying select without argument ( rel.Select() ) will automatically load all fields. This is helpful when used as query builder entry point (compared to using rel.From ), because you can let REL to infer the table name. Load only id and title: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" )). Result ( books )","title":"Selecting Specific Fields"},{"location":"queries/#using-specific-table","text":"By default, REL will use pluralized-snakecase struct name as the table name. To select from specific table, you can use From method. Load from ebooks table: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . From ( \"ebooks\" )). Result ( books ) Chain the query with select: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )). Result ( books )","title":"Using Specific Table"},{"location":"queries/#limit-and-offset","text":"To set the limit and offset of query, use Limit and Offset api. Offset will be ignored if Limit is not specified. Specify limit and offset: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Limit ( 10 ), rel . Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Limit ( 10 ), rel . Offset ( 20 )). Result ( books ) As a chainable api: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select (). Limit ( 10 ). Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select (). Limit ( 10 ). Offset ( 20 )). Result ( books )","title":"Limit and Offset"},{"location":"queries/#group","text":"To use group by query, you can use Group method. Retrieve count of books for every category: Example // custom struct to store the result. var results [] struct { Category string Total int } // we need to explicitly specify table name since we are using an anonymous struct. err := repo . FindAll ( ctx , & results , rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )) Mock results := [] struct { Category string Total int }{ { Category : \"education\" , Total : 100 }, } repo . ExpectFindAll ( rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )). Result ( results )","title":"Group"},{"location":"queries/#joining-tables","text":"To join tables, you can use join api. Note Joining table won't load the association to struct. If you want to load association on a struct, use preload instead. Join transaction and book table, then filter only transaction that have specified book name. This methods assumes belongs to relation, which means it'll try to join using transactions.book_id=books.id : Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))). Result ( transactions ) Specifying which column to join using JoinOn: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Syntactic sugar also available for join: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Joining table with custom join mode: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Use fragment for more complex join query: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )). Result ( transactions )","title":"Joining Tables"},{"location":"queries/#pessimistic-locking","text":"REL supports pessimistic locking by using mechanism provided by the underlying database. Lock can be only used only inside transaction. Retrieve and lock a row for update: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )). Result ( book ) Retrieve and lock a row using predefined lock alias: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . ForUpdate ()) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . ForUpdate ()). Result ( book ) Retrieve and lock a row using chained query: Example var book Book err := repo . Find ( ctx , & book , rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )). Result ( book )","title":"Pessimistic Locking"},{"location":"queries/#aggregation","text":"REL provides a very basic Aggregate method which can be used to count, sum, max etc. Count all available books using aggregate: Example count , err := repo . Aggregate ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ) Mock repo . ExpectAggregate ( rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ). Result ( 5 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" ) Mock repo . ExpectCount ( \"books\" ). Result ( 7 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" , where . Eq ( \"available\" , true )) Mock repo . ExpectCount ( \"books\" , where . Eq ( \"available\" , true )). Result ( 5 )","title":"Aggregation"},{"location":"queries/#pagination","text":"REL provides a convenient FindAndCountAll methods that is useful for pagination, It's a combination of FindAll and Count method. FindAndCountAll returns count of records (ignoring limit and offset query) and an error. Retrieve all books within limit and offset and also count of all books: Example var books [] Book count , err := repo . FindAndCountAll ( ctx , & books , rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAndCountAll ( rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )). Result ( books , 12 )","title":"Pagination"},{"location":"queries/#batch-iteration","text":"REL provides records iterator that can be use for perform batch processing of large amounts of records. Options: BatchSize - The size of batches (default 1000). Start - The primary value (ID) to start from (inclusive). Finish - The primary value (ID) to finish at (inclusive). Example var ( user User iter = repo . Iterate ( ctx , rel . From ( \"users\" ), rel . BatchSize ( 500 )) ) // make sure iterator is closed after process is finish. defer iter . Close () for { // retrieve next user. if err := iter . Next ( & user ); err != nil { if err == io . EOF { break } // handle error return err } // process user SendPromotionEmail ( & user ) } Mock users := make ([] User , 5 ) repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). Result ( users ) Mock Error repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). ConnectionClosed ()","title":"Batch Iteration"},{"location":"queries/#native-sql-query","text":"REL allows querying using native SQL query, this is especially useful when using complex query that cannot be covered with the query builder. Retrieve a book using native sql query: Example var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) err := repo . Find ( ctx , & book , sql ) Mock var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) repo . ExpectFind ( sql ). Result ( book )","title":"Native SQL Query"},{"location":"transactions/","text":"Transactions \u00b6 To declare a transaction, use the Transaction method which can be called recursively to define nested transactions. Rel accepts a function with context.Context argument that is used to determine the transaction scope. Context makes it easier to call any function that involves db operation inside a transaction, because the scope of transaction is automatically passed by context. If any error occured within transaction, the transaction will be rolled back, and returns the error. If the error is a runtime error or panic with string argument, it'll panic after rollback. Example err := repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) // Any database calls inside other function will be using the same transaction as long as it share the same context. Process ( ctx , transaction ) return repo . Update ( ctx , & transaction , rel . Set ( \"status\" , \"paid\" )) }) Mock repo . ExpectTransaction ( func ( repo * reltest . Repository ) { repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"status\" , \"paid\" )). ForType ( \"main.Transaction\" ) })","title":"Transactions"},{"location":"transactions/#transactions","text":"To declare a transaction, use the Transaction method which can be called recursively to define nested transactions. Rel accepts a function with context.Context argument that is used to determine the transaction scope. Context makes it easier to call any function that involves db operation inside a transaction, because the scope of transaction is automatically passed by context. If any error occured within transaction, the transaction will be rolled back, and returns the error. If the error is a runtime error or panic with string argument, it'll panic after rollback. Example err := repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) // Any database calls inside other function will be using the same transaction as long as it share the same context. Process ( ctx , transaction ) return repo . Update ( ctx , & transaction , rel . Set ( \"status\" , \"paid\" )) }) Mock repo . ExpectTransaction ( func ( repo * reltest . Repository ) { repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"status\" , \"paid\" )). ForType ( \"main.Transaction\" ) })","title":"Transactions"},{"location":"changelog/release-notes/","text":"Release Notes \u00b6 v0.7.0 - September 19, 2020 \u00b6 Drop go1.10 and go1.11 ( #95 ) Homebrew tap and linux installer ( #106 ) Migration CLI ( #94 ) Publish prebuilt binary on release ( #105 ) Replace snakecase with snaker ( #96 ) [POC] Schema migration API ( #79 ) fix iid typo ( #90 ) fix: handle unexported struct field ( #91 ) fix: homebrew tap token ( #107 ) remove brews ( #108 ) v0.6.0 - August 12, 2020 \u00b6 \ud83d\udca5 Composite primary key ( #86 ) \ud83d\udca5 Allow explicitly set value for primary key when inserting records ( #82 ) Support partially specified custom primary key on bulk insert ( #89 ) Allow no-op preload if association is already loaded ( #84 ) [fix] Replace has many for non-autogenerated ids ( #87 ) [fix] Postgres returning primary key ( #88 ) [fix] Go 1.12 build pipeline ( #83 ) [doc] add todo app example ( #77 ) [doc] Create CONTRIBUTING.md ( #80 ) v0.5.0 - June 19, 2020 \u00b6 Use context to manage transaction ( #76 ) Improve test coverage and edge cases bug fix ( #75 ) Update all ( #74 ) Added availability create adapters with already opened db ( #69 ) ErrorFunc mutators ( #71 ) fix soft delete all ( #73 ) [doc] improve mobile readability and fix scrolling ( #72 ) [doc] fix link ( #68 ) v0.4.0 - May 24, 2020 \u00b6 Raw SQL Query Builder ( #58 ) Changeset Modifier ( #59 ) Refactor modification to mutation ( #60 ) Support Generating Diff for Associations on Changeset.Changes() ( #62 ) Passing mutator options should not require explicit mutator ( #63 ) Option to disable cascade update ( #64 ) Cascade delete ( #65 ) [fix] default to mock anything if mutators is nil ( #66 ) [doc] Test transaction example ( #55 ) [doc] Test Query Example ( #54 ) [doc] fix the document mistake ( #56 ) [doc] Test CRUD Example ( #57 ) [doc] Test Association Example ( #61 ) [doc] Mutations ( #67 ) v0.3.0 - April 13, 2020 \u00b6 Instrumentation ( #40 ) Iterator ( #46 ) FindAndCountAll method useful pagination ( #41 ) more consistent expect insert/update api signature ( #44 ) Supports error handling using errors.Is ( #50 ) delete all only accepts query chain ( #53 ) make default logger less verbose ( #45 ) Update travis ci ( #51 ) [doc] add instrumentations and minor improvement ( #52 ) v0.2.0 - February 28, 2020 \u00b6 Optimistic DB Insert and Update ( #33 ) Soft delete ( #35 ) Introduce context in API ( #34 ) implement ping ( #36 ) Save zero value when creating and updating with struct ( #31 ) [fix] reset collection ( #37 ) [fix] unscoped query builder ( #38 ) [fix] update not found when updating unchanged record ( #39 ) v0.1.1 - January 4, 2020 \u00b6 [reltest][doc] fix docs example and add missing reltest.New method ( #27 ) [reltest] emulate inc dec ( #26 ) [doc] fix assoc guide and add social footer ( #25 ) [doc] fix paginations ( #24 ) v0.1.0 - January 2, 2020 \u00b6 Initial release","title":"Release Notes"},{"location":"changelog/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"changelog/release-notes/#v070---september-19-2020","text":"Drop go1.10 and go1.11 ( #95 ) Homebrew tap and linux installer ( #106 ) Migration CLI ( #94 ) Publish prebuilt binary on release ( #105 ) Replace snakecase with snaker ( #96 ) [POC] Schema migration API ( #79 ) fix iid typo ( #90 ) fix: handle unexported struct field ( #91 ) fix: homebrew tap token ( #107 ) remove brews ( #108 )","title":"v0.7.0 - September 19, 2020"},{"location":"changelog/release-notes/#v060---august-12-2020","text":"\ud83d\udca5 Composite primary key ( #86 ) \ud83d\udca5 Allow explicitly set value for primary key when inserting records ( #82 ) Support partially specified custom primary key on bulk insert ( #89 ) Allow no-op preload if association is already loaded ( #84 ) [fix] Replace has many for non-autogenerated ids ( #87 ) [fix] Postgres returning primary key ( #88 ) [fix] Go 1.12 build pipeline ( #83 ) [doc] add todo app example ( #77 ) [doc] Create CONTRIBUTING.md ( #80 )","title":"v0.6.0 - August 12, 2020"},{"location":"changelog/release-notes/#v050---june-19-2020","text":"Use context to manage transaction ( #76 ) Improve test coverage and edge cases bug fix ( #75 ) Update all ( #74 ) Added availability create adapters with already opened db ( #69 ) ErrorFunc mutators ( #71 ) fix soft delete all ( #73 ) [doc] improve mobile readability and fix scrolling ( #72 ) [doc] fix link ( #68 )","title":"v0.5.0 - June 19, 2020"},{"location":"changelog/release-notes/#v040---may-24-2020","text":"Raw SQL Query Builder ( #58 ) Changeset Modifier ( #59 ) Refactor modification to mutation ( #60 ) Support Generating Diff for Associations on Changeset.Changes() ( #62 ) Passing mutator options should not require explicit mutator ( #63 ) Option to disable cascade update ( #64 ) Cascade delete ( #65 ) [fix] default to mock anything if mutators is nil ( #66 ) [doc] Test transaction example ( #55 ) [doc] Test Query Example ( #54 ) [doc] fix the document mistake ( #56 ) [doc] Test CRUD Example ( #57 ) [doc] Test Association Example ( #61 ) [doc] Mutations ( #67 )","title":"v0.4.0 - May 24, 2020"},{"location":"changelog/release-notes/#v030---april-13-2020","text":"Instrumentation ( #40 ) Iterator ( #46 ) FindAndCountAll method useful pagination ( #41 ) more consistent expect insert/update api signature ( #44 ) Supports error handling using errors.Is ( #50 ) delete all only accepts query chain ( #53 ) make default logger less verbose ( #45 ) Update travis ci ( #51 ) [doc] add instrumentations and minor improvement ( #52 )","title":"v0.3.0 - April 13, 2020"},{"location":"changelog/release-notes/#v020---february-28-2020","text":"Optimistic DB Insert and Update ( #33 ) Soft delete ( #35 ) Introduce context in API ( #34 ) implement ping ( #36 ) Save zero value when creating and updating with struct ( #31 ) [fix] reset collection ( #37 ) [fix] unscoped query builder ( #38 ) [fix] update not found when updating unchanged record ( #39 )","title":"v0.2.0 - February 28, 2020"},{"location":"changelog/release-notes/#v011---january-4-2020","text":"[reltest][doc] fix docs example and add missing reltest.New method ( #27 ) [reltest] emulate inc dec ( #26 ) [doc] fix assoc guide and add social footer ( #25 ) [doc] fix paginations ( #24 )","title":"v0.1.1 - January 4, 2020"},{"location":"changelog/release-notes/#v010---january-2-2020","text":"Initial release","title":"v0.1.0 - January 2, 2020"},{"location":"reference/adapter-mysql/","text":"mysql \u00b6 import \"github.com/Fs02/rel/adapter/mysql\" Overview \u00b6 Package mysql wraps mysql driver as an adapter for REL. Usage: // open mysql connection. adapter, err := mysql.Open(\"root@(127.0.0.1:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter) Variables \u00b6 var ( // Config for mysql adapter. Config = sql . Config { DropIndexOnTable : true , Placeholder : \"?\" , EscapeChar : \"`\" , IncrementFunc : incrementFunc , ErrorFunc : errorFunc , MapColumnFunc : sql . MapColumn , } ) type Adapter \u00b6 type Adapter struct { * sql . Adapter } Adapter definition for mysql database. func New \u00b6 func New ( database * db . DB ) * Adapter New mysql adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( * Adapter , error ) Open mysql connection using dsn.","title":"github.com/Fs02/rel/adapter/mysql"},{"location":"reference/adapter-mysql/#mysql","text":"import \"github.com/Fs02/rel/adapter/mysql\"","title":"mysql"},{"location":"reference/adapter-mysql/#overview","text":"Package mysql wraps mysql driver as an adapter for REL. Usage: // open mysql connection. adapter, err := mysql.Open(\"root@(127.0.0.1:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-mysql/#variables","text":"var ( // Config for mysql adapter. Config = sql . Config { DropIndexOnTable : true , Placeholder : \"?\" , EscapeChar : \"`\" , IncrementFunc : incrementFunc , ErrorFunc : errorFunc , MapColumnFunc : sql . MapColumn , } )","title":"Variables"},{"location":"reference/adapter-mysql/#type-adapter","text":"type Adapter struct { * sql . Adapter } Adapter definition for mysql database.","title":"type Adapter"},{"location":"reference/adapter-mysql/#func-new","text":"func New ( database * db . DB ) * Adapter New mysql adapter using existing connection.","title":"func New"},{"location":"reference/adapter-mysql/#func-open","text":"func Open ( dsn string ) ( * Adapter , error ) Open mysql connection using dsn.","title":"func Open"},{"location":"reference/adapter-postgres/","text":"postgres \u00b6 import \"github.com/Fs02/rel/adapter/postgres\" Overview \u00b6 Package postgres wraps postgres (pq) driver as an adapter for REL. Usage: // open postgres connection. adapter, err := postgres.Open(\"postgres://postgres@localhost/rel_test?sslmode=disable\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter) Variables \u00b6 var ( // Config for postgres adapter. Config = sql . Config { Placeholder : \"$\" , EscapeChar : \"\\\"\" , Ordinal : true , InsertDefaultValues : true , ErrorFunc : errorFunc , MapColumnFunc : mapColumnFunc , } ) type Adapter \u00b6 type Adapter struct { * sql . Adapter } Adapter definition for postgres database. func New \u00b6 func New ( database * db . DB ) * Adapter New postgres adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( * Adapter , error ) Open postgres connection using dsn. func (*Adapter) Begin \u00b6 func ( adapter * Adapter ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (*Adapter) Insert \u00b6 func ( adapter * Adapter ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (*Adapter) InsertAll \u00b6 func ( adapter * Adapter ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"github.com/Fs02/rel/adapter/postgres"},{"location":"reference/adapter-postgres/#postgres","text":"import \"github.com/Fs02/rel/adapter/postgres\"","title":"postgres"},{"location":"reference/adapter-postgres/#overview","text":"Package postgres wraps postgres (pq) driver as an adapter for REL. Usage: // open postgres connection. adapter, err := postgres.Open(\"postgres://postgres@localhost/rel_test?sslmode=disable\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-postgres/#variables","text":"var ( // Config for postgres adapter. Config = sql . Config { Placeholder : \"$\" , EscapeChar : \"\\\"\" , Ordinal : true , InsertDefaultValues : true , ErrorFunc : errorFunc , MapColumnFunc : mapColumnFunc , } )","title":"Variables"},{"location":"reference/adapter-postgres/#type-adapter","text":"type Adapter struct { * sql . Adapter } Adapter definition for postgres database.","title":"type Adapter"},{"location":"reference/adapter-postgres/#func-new","text":"func New ( database * db . DB ) * Adapter New postgres adapter using existing connection.","title":"func New"},{"location":"reference/adapter-postgres/#func-open","text":"func Open ( dsn string ) ( * Adapter , error ) Open postgres connection using dsn.","title":"func Open"},{"location":"reference/adapter-postgres/#func-adapter-begin","text":"func ( adapter * Adapter ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (*Adapter) Begin"},{"location":"reference/adapter-postgres/#func-adapter-insert","text":"func ( adapter * Adapter ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (*Adapter) Insert"},{"location":"reference/adapter-postgres/#func-adapter-insertall","text":"func ( adapter * Adapter ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (*Adapter) InsertAll"},{"location":"reference/adapter-sql/","text":"sql \u00b6 import \"github.com/Fs02/rel/adapter/sql\" Overview \u00b6 Package sql is general sql adapter that wraps database/sql. Variables \u00b6 var UnescapeCharacter byte = '^' UnescapeCharacter disable field escaping when it starts with this character. func Escape \u00b6 func Escape ( config Config , field string ) string Escape field or table name. func ExtractString \u00b6 func ExtractString ( s , left , right string ) string ExtractString between two string. func MapColumn \u00b6 func MapColumn ( column * rel . Column ) ( string , int , int ) MapColumn func. type Adapter \u00b6 type Adapter struct { Instrumenter rel . Instrumenter Config Config DB * sql . DB Tx * sql . Tx // contains filtered or unexported fields } Adapter definition for database database. func New \u00b6 func New ( config Config ) * Adapter New initialize adapter without db. func (*Adapter) Aggregate \u00b6 func ( a * Adapter ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) Aggregate record using given query. func (*Adapter) Apply \u00b6 func ( a * Adapter ) Apply ( ctx context . Context , migration rel . Migration ) error Apply table. func (*Adapter) Begin \u00b6 func ( a * Adapter ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (*Adapter) Close \u00b6 func ( a * Adapter ) Close () error Close database connection. func (*Adapter) Commit \u00b6 func ( a * Adapter ) Commit ( ctx context . Context ) error Commit commits current transaction. func (*Adapter) Delete \u00b6 func ( a * Adapter ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) Delete deletes all results that match the query. func (*Adapter) Exec \u00b6 func ( a * Adapter ) Exec ( ctx context . Context , statement string , args [] interface {}) ( int64 , int64 , error ) Exec performs exec operation. func (*Adapter) Insert \u00b6 func ( a * Adapter ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (*Adapter) InsertAll \u00b6 func ( a * Adapter ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate ) ([] interface {}, error ) InsertAll inserts all record to database and returns its ids. func (*Adapter) Instrument \u00b6 func ( a * Adapter ) Instrument ( ctx context . Context , op string , message string ) func ( err error ) Instrument call instrumenter, if no instrumenter is set, this will be a no op. func (*Adapter) Instrumentation \u00b6 func ( a * Adapter ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation set instrumenter for this adapter. func (*Adapter) Ping \u00b6 func ( a * Adapter ) Ping ( ctx context . Context ) error Ping database. func (*Adapter) Query \u00b6 func ( a * Adapter ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) Query performs query operation. func (*Adapter) Rollback \u00b6 func ( a * Adapter ) Rollback ( ctx context . Context ) error Rollback revert current transaction. func (*Adapter) Update \u00b6 func ( a * Adapter ) Update ( ctx context . Context , query rel . Query , mutates map [ string ] rel . Mutate ) ( int , error ) Update updates a record in database. type Buffer \u00b6 type Buffer struct { strings . Builder Arguments [] interface {} } Buffer used to strings buffer and argument of the query. func (*Buffer) Append \u00b6 func ( b * Buffer ) Append ( args ... interface {}) Append argumetns. func (*Buffer) Reset \u00b6 func ( b * Buffer ) Reset () Reset buffer. type Builder \u00b6 type Builder struct { // contains filtered or unexported fields } Builder defines information of query b. func NewBuilder \u00b6 func NewBuilder ( config Config ) * Builder NewBuilder create new SQL builder. func (*Builder) Aggregate \u00b6 func ( b * Builder ) Aggregate ( query rel . Query , mode string , field string ) ( string , [] interface {}) Aggregate generates query for aggregation. func (*Builder) Delete \u00b6 func ( b * Builder ) Delete ( table string , filter rel . FilterQuery ) ( string , [] interface {}) Delete generates query for delete. func (*Builder) Find \u00b6 func ( b * Builder ) Find ( query rel . Query ) ( string , [] interface {}) Find generates query for select. func (*Builder) Index \u00b6 func ( b * Builder ) Index ( index rel . Index ) string Index generates query for index. func (*Builder) Insert \u00b6 func ( b * Builder ) Insert ( table string , mutates map [ string ] rel . Mutate ) ( string , [] interface {}) Insert generates query for insert. func (*Builder) InsertAll \u00b6 func ( b * Builder ) InsertAll ( table string , fields [] string , bulkMutates [] map [ string ] rel . Mutate ) ( string , [] interface {}) InsertAll generates query for multiple insert. func (*Builder) Returning \u00b6 func ( b * Builder ) Returning ( field string ) * Builder Returning append returning to insert rel. func (*Builder) Table \u00b6 func ( b * Builder ) Table ( table rel . Table ) string Table generates query for table creation and modification. func (*Builder) Update \u00b6 func ( b * Builder ) Update ( table string , mutates map [ string ] rel . Mutate , filter rel . FilterQuery ) ( string , [] interface {}) Update generates query for update. type Config \u00b6 type Config struct { Placeholder string Ordinal bool InsertDefaultValues bool DropIndexOnTable bool EscapeChar string ErrorFunc func ( error ) error IncrementFunc func ( Adapter ) int IndexToSQL func ( config Config , buffer * Buffer , index rel . Index ) bool MapColumnFunc func ( column * rel . Column ) ( string , int , int ) } Config holds configuration for adapter. type Cursor \u00b6 type Cursor struct { * sql . Rows } Cursor used for retrieving result. func (*Cursor) Fields \u00b6 func ( c * Cursor ) Fields () ([] string , error ) Fields returned in the result. func (*Cursor) NopScanner \u00b6 func ( c * Cursor ) NopScanner () interface {} NopScanner for this adapter.","title":"github.com/Fs02/rel/adapter/sql"},{"location":"reference/adapter-sql/#sql","text":"import \"github.com/Fs02/rel/adapter/sql\"","title":"sql"},{"location":"reference/adapter-sql/#overview","text":"Package sql is general sql adapter that wraps database/sql.","title":"Overview"},{"location":"reference/adapter-sql/#variables","text":"var UnescapeCharacter byte = '^' UnescapeCharacter disable field escaping when it starts with this character.","title":"Variables"},{"location":"reference/adapter-sql/#func-escape","text":"func Escape ( config Config , field string ) string Escape field or table name.","title":"func Escape"},{"location":"reference/adapter-sql/#func-extractstring","text":"func ExtractString ( s , left , right string ) string ExtractString between two string.","title":"func ExtractString"},{"location":"reference/adapter-sql/#func-mapcolumn","text":"func MapColumn ( column * rel . Column ) ( string , int , int ) MapColumn func.","title":"func MapColumn"},{"location":"reference/adapter-sql/#type-adapter","text":"type Adapter struct { Instrumenter rel . Instrumenter Config Config DB * sql . DB Tx * sql . Tx // contains filtered or unexported fields } Adapter definition for database database.","title":"type Adapter"},{"location":"reference/adapter-sql/#func-new","text":"func New ( config Config ) * Adapter New initialize adapter without db.","title":"func New"},{"location":"reference/adapter-sql/#func-adapter-aggregate","text":"func ( a * Adapter ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) Aggregate record using given query.","title":"func (*Adapter) Aggregate"},{"location":"reference/adapter-sql/#func-adapter-apply","text":"func ( a * Adapter ) Apply ( ctx context . Context , migration rel . Migration ) error Apply table.","title":"func (*Adapter) Apply"},{"location":"reference/adapter-sql/#func-adapter-begin","text":"func ( a * Adapter ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (*Adapter) Begin"},{"location":"reference/adapter-sql/#func-adapter-close","text":"func ( a * Adapter ) Close () error Close database connection.","title":"func (*Adapter) Close"},{"location":"reference/adapter-sql/#func-adapter-commit","text":"func ( a * Adapter ) Commit ( ctx context . Context ) error Commit commits current transaction.","title":"func (*Adapter) Commit"},{"location":"reference/adapter-sql/#func-adapter-delete","text":"func ( a * Adapter ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) Delete deletes all results that match the query.","title":"func (*Adapter) Delete"},{"location":"reference/adapter-sql/#func-adapter-exec","text":"func ( a * Adapter ) Exec ( ctx context . Context , statement string , args [] interface {}) ( int64 , int64 , error ) Exec performs exec operation.","title":"func (*Adapter) Exec"},{"location":"reference/adapter-sql/#func-adapter-insert","text":"func ( a * Adapter ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (*Adapter) Insert"},{"location":"reference/adapter-sql/#func-adapter-insertall","text":"func ( a * Adapter ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate ) ([] interface {}, error ) InsertAll inserts all record to database and returns its ids.","title":"func (*Adapter) InsertAll"},{"location":"reference/adapter-sql/#func-adapter-instrument","text":"func ( a * Adapter ) Instrument ( ctx context . Context , op string , message string ) func ( err error ) Instrument call instrumenter, if no instrumenter is set, this will be a no op.","title":"func (*Adapter) Instrument"},{"location":"reference/adapter-sql/#func-adapter-instrumentation","text":"func ( a * Adapter ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation set instrumenter for this adapter.","title":"func (*Adapter) Instrumentation"},{"location":"reference/adapter-sql/#func-adapter-ping","text":"func ( a * Adapter ) Ping ( ctx context . Context ) error Ping database.","title":"func (*Adapter) Ping"},{"location":"reference/adapter-sql/#func-adapter-query","text":"func ( a * Adapter ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) Query performs query operation.","title":"func (*Adapter) Query"},{"location":"reference/adapter-sql/#func-adapter-rollback","text":"func ( a * Adapter ) Rollback ( ctx context . Context ) error Rollback revert current transaction.","title":"func (*Adapter) Rollback"},{"location":"reference/adapter-sql/#func-adapter-update","text":"func ( a * Adapter ) Update ( ctx context . Context , query rel . Query , mutates map [ string ] rel . Mutate ) ( int , error ) Update updates a record in database.","title":"func (*Adapter) Update"},{"location":"reference/adapter-sql/#type-buffer","text":"type Buffer struct { strings . Builder Arguments [] interface {} } Buffer used to strings buffer and argument of the query.","title":"type Buffer"},{"location":"reference/adapter-sql/#func-buffer-append","text":"func ( b * Buffer ) Append ( args ... interface {}) Append argumetns.","title":"func (*Buffer) Append"},{"location":"reference/adapter-sql/#func-buffer-reset","text":"func ( b * Buffer ) Reset () Reset buffer.","title":"func (*Buffer) Reset"},{"location":"reference/adapter-sql/#type-builder","text":"type Builder struct { // contains filtered or unexported fields } Builder defines information of query b.","title":"type Builder"},{"location":"reference/adapter-sql/#func-newbuilder","text":"func NewBuilder ( config Config ) * Builder NewBuilder create new SQL builder.","title":"func NewBuilder"},{"location":"reference/adapter-sql/#func-builder-aggregate","text":"func ( b * Builder ) Aggregate ( query rel . Query , mode string , field string ) ( string , [] interface {}) Aggregate generates query for aggregation.","title":"func (*Builder) Aggregate"},{"location":"reference/adapter-sql/#func-builder-delete","text":"func ( b * Builder ) Delete ( table string , filter rel . FilterQuery ) ( string , [] interface {}) Delete generates query for delete.","title":"func (*Builder) Delete"},{"location":"reference/adapter-sql/#func-builder-find","text":"func ( b * Builder ) Find ( query rel . Query ) ( string , [] interface {}) Find generates query for select.","title":"func (*Builder) Find"},{"location":"reference/adapter-sql/#func-builder-index","text":"func ( b * Builder ) Index ( index rel . Index ) string Index generates query for index.","title":"func (*Builder) Index"},{"location":"reference/adapter-sql/#func-builder-insert","text":"func ( b * Builder ) Insert ( table string , mutates map [ string ] rel . Mutate ) ( string , [] interface {}) Insert generates query for insert.","title":"func (*Builder) Insert"},{"location":"reference/adapter-sql/#func-builder-insertall","text":"func ( b * Builder ) InsertAll ( table string , fields [] string , bulkMutates [] map [ string ] rel . Mutate ) ( string , [] interface {}) InsertAll generates query for multiple insert.","title":"func (*Builder) InsertAll"},{"location":"reference/adapter-sql/#func-builder-returning","text":"func ( b * Builder ) Returning ( field string ) * Builder Returning append returning to insert rel.","title":"func (*Builder) Returning"},{"location":"reference/adapter-sql/#func-builder-table","text":"func ( b * Builder ) Table ( table rel . Table ) string Table generates query for table creation and modification.","title":"func (*Builder) Table"},{"location":"reference/adapter-sql/#func-builder-update","text":"func ( b * Builder ) Update ( table string , mutates map [ string ] rel . Mutate , filter rel . FilterQuery ) ( string , [] interface {}) Update generates query for update.","title":"func (*Builder) Update"},{"location":"reference/adapter-sql/#type-config","text":"type Config struct { Placeholder string Ordinal bool InsertDefaultValues bool DropIndexOnTable bool EscapeChar string ErrorFunc func ( error ) error IncrementFunc func ( Adapter ) int IndexToSQL func ( config Config , buffer * Buffer , index rel . Index ) bool MapColumnFunc func ( column * rel . Column ) ( string , int , int ) } Config holds configuration for adapter.","title":"type Config"},{"location":"reference/adapter-sql/#type-cursor","text":"type Cursor struct { * sql . Rows } Cursor used for retrieving result.","title":"type Cursor"},{"location":"reference/adapter-sql/#func-cursor-fields","text":"func ( c * Cursor ) Fields () ([] string , error ) Fields returned in the result.","title":"func (*Cursor) Fields"},{"location":"reference/adapter-sql/#func-cursor-nopscanner","text":"func ( c * Cursor ) NopScanner () interface {} NopScanner for this adapter.","title":"func (*Cursor) NopScanner"},{"location":"reference/adapter-sqlite3/","text":"sqlite3 \u00b6 import \"github.com/Fs02/rel/adapter/sqlite3\" Overview \u00b6 Package sqlite3 wraps go-sqlite3 driver as an adapter for rel. Usage: // open sqlite3 connection. adapter, err := sqlite3.Open(\"dev.db\") if err != nil { panic(err) } defer adapter.Close() // initialize rel's repo. repo := rel.New(adapter) Variables \u00b6 var ( // Config for mysql adapter. Config = sql . Config { Placeholder : \"?\" , EscapeChar : \"`\" , InsertDefaultValues : true , IncrementFunc : incrementFunc , ErrorFunc : errorFunc , MapColumnFunc : mapColumnFunc , } ) type Adapter \u00b6 type Adapter struct { * sql . Adapter } Adapter definition for mysql database. func New \u00b6 func New ( database * db . DB ) * Adapter New sqlite adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( * Adapter , error ) Open sqlite connection using dsn.","title":"github.com/Fs02/rel/adapter/sqlite3"},{"location":"reference/adapter-sqlite3/#sqlite3","text":"import \"github.com/Fs02/rel/adapter/sqlite3\"","title":"sqlite3"},{"location":"reference/adapter-sqlite3/#overview","text":"Package sqlite3 wraps go-sqlite3 driver as an adapter for rel. Usage: // open sqlite3 connection. adapter, err := sqlite3.Open(\"dev.db\") if err != nil { panic(err) } defer adapter.Close() // initialize rel's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-sqlite3/#variables","text":"var ( // Config for mysql adapter. Config = sql . Config { Placeholder : \"?\" , EscapeChar : \"`\" , InsertDefaultValues : true , IncrementFunc : incrementFunc , ErrorFunc : errorFunc , MapColumnFunc : mapColumnFunc , } )","title":"Variables"},{"location":"reference/adapter-sqlite3/#type-adapter","text":"type Adapter struct { * sql . Adapter } Adapter definition for mysql database.","title":"type Adapter"},{"location":"reference/adapter-sqlite3/#func-new","text":"func New ( database * db . DB ) * Adapter New sqlite adapter using existing connection.","title":"func New"},{"location":"reference/adapter-sqlite3/#func-open","text":"func Open ( dsn string ) ( * Adapter , error ) Open sqlite connection using dsn.","title":"func Open"},{"location":"reference/group/","text":"group \u00b6 import \"github.com/Fs02/rel/group\" Overview \u00b6 Package group is syntatic sugar for building group query. Variables \u00b6 var ( // By is alias for rel.NewGroup By = rel . NewGroup // Fields is alias for rel.NewGroup Fields = rel . NewGroup )","title":"github.com/Fs02/rel/group"},{"location":"reference/group/#group","text":"import \"github.com/Fs02/rel/group\"","title":"group"},{"location":"reference/group/#overview","text":"Package group is syntatic sugar for building group query.","title":"Overview"},{"location":"reference/group/#variables","text":"var ( // By is alias for rel.NewGroup By = rel . NewGroup // Fields is alias for rel.NewGroup Fields = rel . NewGroup )","title":"Variables"},{"location":"reference/join/","text":"join \u00b6 import \"github.com/Fs02/rel/join\" Overview \u00b6 Package join is syntatic sugar for building join query. Variables \u00b6 var ( // Join is alias for rel.NewJoin Join = rel . NewJoin // On is alias for rel.NewJoinOn On = rel . NewJoinOn // Inner is alias for rel.NewInnerJoin Inner = rel . NewInnerJoin // InnerOn is alias for rel.NewInnerJoinOn InnerOn = rel . NewInnerJoinOn // Left is alias for rel.NewLeftJoin Left = rel . NewLeftJoin // LeftOn is alias for rel.NewLeftJoinOn LeftOn = rel . NewLeftJoinOn // Right is alias for rel.NewRightJoin Right = rel . NewRightJoin // RightOn is alias for rel.NewRightJoinOn RightOn = rel . NewRightJoinOn // Full is alias for rel.NewFullJoin Full = rel . NewFullJoin // FullOn is alias for rel.NewFullJoinOn FullOn = rel . NewFullJoinOn )","title":"github.com/Fs02/rel/join"},{"location":"reference/join/#join","text":"import \"github.com/Fs02/rel/join\"","title":"join"},{"location":"reference/join/#overview","text":"Package join is syntatic sugar for building join query.","title":"Overview"},{"location":"reference/join/#variables","text":"var ( // Join is alias for rel.NewJoin Join = rel . NewJoin // On is alias for rel.NewJoinOn On = rel . NewJoinOn // Inner is alias for rel.NewInnerJoin Inner = rel . NewInnerJoin // InnerOn is alias for rel.NewInnerJoinOn InnerOn = rel . NewInnerJoinOn // Left is alias for rel.NewLeftJoin Left = rel . NewLeftJoin // LeftOn is alias for rel.NewLeftJoinOn LeftOn = rel . NewLeftJoinOn // Right is alias for rel.NewRightJoin Right = rel . NewRightJoin // RightOn is alias for rel.NewRightJoinOn RightOn = rel . NewRightJoinOn // Full is alias for rel.NewFullJoin Full = rel . NewFullJoin // FullOn is alias for rel.NewFullJoinOn FullOn = rel . NewFullJoinOn )","title":"Variables"},{"location":"reference/migrator/","text":"migrator \u00b6 import \"github.com/Fs02/rel/migrator\" Overview \u00b6 type Migrator \u00b6 type Migrator struct { // contains filtered or unexported fields } Migrator is a migration manager that handles migration logic. func New \u00b6 func New ( repo rel . Repository ) Migrator New migrationr. func (*Migrator) Migrate \u00b6 func ( m * Migrator ) Migrate ( ctx context . Context ) Migrate to the latest schema version. func (*Migrator) Register \u00b6 func ( m * Migrator ) Register ( v int , up func ( schema * rel . Schema ), down func ( schema * rel . Schema )) Register a migration. func (*Migrator) Rollback \u00b6 func ( m * Migrator ) Rollback ( ctx context . Context ) Rollback migration 1 step.","title":"github.com/Fs02/rel/migrator"},{"location":"reference/migrator/#migrator","text":"import \"github.com/Fs02/rel/migrator\"","title":"migrator"},{"location":"reference/migrator/#overview","text":"","title":"Overview"},{"location":"reference/migrator/#type-migrator","text":"type Migrator struct { // contains filtered or unexported fields } Migrator is a migration manager that handles migration logic.","title":"type Migrator"},{"location":"reference/migrator/#func-new","text":"func New ( repo rel . Repository ) Migrator New migrationr.","title":"func New"},{"location":"reference/migrator/#func-migrator-migrate","text":"func ( m * Migrator ) Migrate ( ctx context . Context ) Migrate to the latest schema version.","title":"func (*Migrator) Migrate"},{"location":"reference/migrator/#func-migrator-register","text":"func ( m * Migrator ) Register ( v int , up func ( schema * rel . Schema ), down func ( schema * rel . Schema )) Register a migration.","title":"func (*Migrator) Register"},{"location":"reference/migrator/#func-migrator-rollback","text":"func ( m * Migrator ) Rollback ( ctx context . Context ) Rollback migration 1 step.","title":"func (*Migrator) Rollback"},{"location":"reference/rel/","text":"rel \u00b6 import \"github.com/Fs02/rel\" Overview \u00b6 Package rel is a Database Layer for SQL Database. Constants \u00b6 const ( // BelongsTo association. BelongsTo = iota // HasOne association. HasOne // HasMany association. HasMany ) Variables \u00b6 var ( // ErrNotFound returned when records not found. ErrNotFound = NotFoundError {} // ErrCheckConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrCheckConstraint). ErrCheckConstraint = ConstraintError { Type : CheckConstraint } // ErrNotNullConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrNotNullConstraint). ErrNotNullConstraint = ConstraintError { Type : NotNullConstraint } // ErrUniqueConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrUniqueConstraint). ErrUniqueConstraint = ConstraintError { Type : UniqueConstraint } // ErrPrimaryKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrPrimaryKeyConstraint). ErrPrimaryKeyConstraint = ConstraintError { Type : PrimaryKeyConstraint } // ErrForeignKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrForeignKeyConstraint). ErrForeignKeyConstraint = ConstraintError { Type : ForeignKeyConstraint } ) var Setf = SetFragment Setf is an alias for SetFragment func DefaultLogger \u00b6 func DefaultLogger ( ctx context . Context , op string , message string ) func ( err error ) DefaultLogger instrumentation to log queries and rel operation. func Nullable \u00b6 func Nullable ( dest interface {}) interface {} Nullable wrap value as a nullable sql.Scanner. If value returned from database is nil, nullable scanner will set dest to zero value. type Adapter \u00b6 type Adapter interface { Instrumentation ( instrumenter Instrumenter ) Ping ( ctx context . Context ) error Aggregate ( ctx context . Context , query Query , mode string , field string ) ( int , error ) Query ( ctx context . Context , query Query ) ( Cursor , error ) Insert ( ctx context . Context , query Query , primaryField string , mutates map [ string ] Mutate ) ( interface {}, error ) InsertAll ( ctx context . Context , query Query , primaryField string , fields [] string , bulkMutates [] map [ string ] Mutate ) ([] interface {}, error ) Update ( ctx context . Context , query Query , mutates map [ string ] Mutate ) ( int , error ) Delete ( ctx context . Context , query Query ) ( int , error ) Begin ( ctx context . Context ) ( Adapter , error ) Commit ( ctx context . Context ) error Rollback ( ctx context . Context ) error Apply ( ctx context . Context , migration Migration ) error } Adapter interface type AlterTable \u00b6 type AlterTable struct { Table } AlterTable Migrator. func (*AlterTable) DropColumn \u00b6 func ( at * AlterTable ) DropColumn ( name string , options ... ColumnOption ) DropColumn from this table. func (*AlterTable) RenameColumn \u00b6 func ( at * AlterTable ) RenameColumn ( name string , newName string , options ... ColumnOption ) RenameColumn to a new name. type AssocMutation \u00b6 type AssocMutation struct { Mutations [] Mutation DeletedIDs [] interface {} // This is array of single id, and doesn't support composite primary key. } AssocMutation represents mutation for association. type Association \u00b6 type Association struct { // contains filtered or unexported fields } Association provides abstraction to work with association of document or collection. func (Association) Collection \u00b6 func ( a Association ) Collection () ( * Collection , bool ) Collection returns association target as collection. If association is zero, second return value will be false. func (Association) Document \u00b6 func ( a Association ) Document () ( * Document , bool ) Document returns association target as document. If association is zero, second return value will be false. func (Association) ForeignField \u00b6 func ( a Association ) ForeignField () string ForeignField of the association. func (Association) ForeignValue \u00b6 func ( a Association ) ForeignValue () interface {} ForeignValue of the association. It'll panic if association type is has many. func (Association) IsZero \u00b6 func ( a Association ) IsZero () bool IsZero returns true if association is not loaded. func (Association) ReferenceField \u00b6 func ( a Association ) ReferenceField () string ReferenceField of the association. func (Association) ReferenceValue \u00b6 func ( a Association ) ReferenceValue () interface {} ReferenceValue of the association. func (Association) Type \u00b6 func ( a Association ) Type () AssociationType Type of association. type AssociationType \u00b6 type AssociationType uint8 AssociationType defines the type of association in database. type Cascade \u00b6 type Cascade bool Cascade enable or disable updating associations. Default to true. func (Cascade) Apply \u00b6 func ( c Cascade ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. type ChangeOp \u00b6 type ChangeOp int ChangeOp represents type of mutate operation. const ( // ChangeInvalidOp operation. ChangeInvalidOp ChangeOp = iota // ChangeSetOp operation. ChangeSetOp // ChangeIncOp operation. ChangeIncOp // ChangeFragmentOp operation. ChangeFragmentOp ) type Changeset \u00b6 type Changeset struct { // contains filtered or unexported fields } Changeset mutator for structs. This allows REL to efficiently to perform update operation only on updated fields and association. The catch is, enabling changeset will duplicates the original struct values which consumes more memory. func NewChangeset \u00b6 func NewChangeset ( record interface {}) Changeset NewChangeset returns new changeset mutator for given record. func (Changeset) Apply \u00b6 func ( c Changeset ) Apply ( doc * Document , mut * Mutation ) Apply mutation. func (Changeset) Changes \u00b6 func ( c Changeset ) Changes () map [ string ] interface {} Changes returns map of changes. func (Changeset) FieldChanged \u00b6 func ( c Changeset ) FieldChanged ( field string ) bool FieldChanged returns true if field exists and it's already chagned. returns false otherwise. type Collection \u00b6 type Collection struct { // contains filtered or unexported fields } Collection provides an abstraction over reflect to easily works with slice for database purpose. func NewCollection \u00b6 func NewCollection ( records interface {}, readonly ... bool ) * Collection NewCollection used to create abstraction to work with slice. COllection can be created using interface or reflect.Value. func (Collection) Add \u00b6 func ( c Collection ) Add () * Document Add new document into collection. func (Collection) Get \u00b6 func ( c Collection ) Get ( index int ) * Document Get an element from the underlying slice as a document. func (Collection) Len \u00b6 func ( c Collection ) Len () int Len of the underlying slice. func (Collection) PrimaryField \u00b6 func ( c Collection ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key. func (Collection) PrimaryFields \u00b6 func ( c Collection ) PrimaryFields () [] string PrimaryFields column name of this collection. func (Collection) PrimaryValue \u00b6 func ( c Collection ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key. func (Collection) PrimaryValues \u00b6 func ( c Collection ) PrimaryValues () [] interface {} PrimaryValues of collection. Returned value will be interface of slice interface. func (Collection) ReflectValue \u00b6 func ( c Collection ) ReflectValue () reflect . Value ReflectValue of referenced document. func (Collection) Reset \u00b6 func ( c Collection ) Reset () Reset underlying slice to be zero length. func (Collection) Slice \u00b6 func ( c Collection ) Slice ( i , j int ) * Collection Slice returns a new collection that is a slice of the original collection.s func (Collection) Swap \u00b6 func ( c Collection ) Swap ( i , j int ) Swap element in the collection. func (*Collection) Table \u00b6 func ( c * Collection ) Table () string Table returns name of the table. func (Collection) Truncate \u00b6 func ( c Collection ) Truncate ( i , j int ) Truncate collection. type Column \u00b6 type Column struct { Op SchemaOp Name string Type ColumnType Rename string Unique bool Required bool Unsigned bool Limit int Precision int Scale int Default interface {} Options string } Column definition. type ColumnOption \u00b6 type ColumnOption interface { // contains filtered or unexported methods } ColumnOption interface. Available options are: Nil, Unsigned, Limit, Precision, Scale, Default, Comment, Options. func Default \u00b6 func Default ( def interface {}) ColumnOption Default allows to set a default value on the column.). type ColumnType \u00b6 type ColumnType string ColumnType definition. const ( // ID ColumnType. ID ColumnType = \"ID\" // Bool ColumnType. Bool ColumnType = \"BOOL\" // Int ColumnType. Int ColumnType = \"INT\" // BigInt ColumnType. BigInt ColumnType = \"BIGINT\" // Float ColumnType. Float ColumnType = \"FLOAT\" // Decimal ColumnType. Decimal ColumnType = \"DECIMAL\" // String ColumnType. String ColumnType = \"STRING\" // Text ColumnType. Text ColumnType = \"TEXT\" // Date ColumnType. Date ColumnType = \"DATE\" // DateTime ColumnType. DateTime ColumnType = \"DATETIME\" // Time ColumnType. Time ColumnType = \"TIME\" // Timestamp ColumnType. Timestamp ColumnType = \"TIMESTAMP\" ) type ConstraintError \u00b6 type ConstraintError struct { Key string Type ConstraintType Err error } ConstraintError returned whenever constraint error encountered. func (ConstraintError) Error \u00b6 func ( ce ConstraintError ) Error () string Error message. func (ConstraintError) Is \u00b6 func ( ce ConstraintError ) Is ( target error ) bool Is returns true when target error have the same type and key if defined. func (ConstraintError) Unwrap \u00b6 func ( ce ConstraintError ) Unwrap () error Unwrap internal error returned by database driver. type ConstraintType \u00b6 type ConstraintType int8 ConstraintType defines the type of constraint error. const ( // CheckConstraint error type. CheckConstraint ConstraintType = iota // NotNullConstraint error type.1 NotNullConstraint // UniqueConstraint error type.1 UniqueConstraint // PrimaryKeyConstraint error type.1 PrimaryKeyConstraint // ForeignKeyConstraint error type.1 ForeignKeyConstraint ) func (ConstraintType) String \u00b6 func ( ct ConstraintType ) String () string String representation of the constraint type. type Cursor \u00b6 type Cursor interface { Close () error Fields () ([] string , error ) Next () bool Scan ( ... interface {}) error NopScanner () interface {} // TODO: conflict with manual scanners interface } Cursor is interface to work with database result (used by adapter). type Do \u00b6 type Do func ( Repository ) error Do used internally for schema migration. type Document \u00b6 type Document struct { // contains filtered or unexported fields } Document provides an abstraction over reflect to easily works with struct for database purpose. func NewDocument \u00b6 func NewDocument ( record interface {}, readonly ... bool ) * Document NewDocument used to create abstraction to work with struct. Document can be created using interface or reflect.Value. func (*Document) Add \u00b6 func ( d * Document ) Add () * Document Add returns this document, this is a noop for compatibility with collection. func (Document) Association \u00b6 func ( d Document ) Association ( name string ) Association Association of this document with given name. func (Document) BelongsTo \u00b6 func ( d Document ) BelongsTo () [] string BelongsTo fields of this document. func (Document) Fields \u00b6 func ( d Document ) Fields () [] string Fields returns list of fields available on this document. func (Document) Flag \u00b6 func ( d Document ) Flag ( flag DocumentFlag ) bool Flag returns true if struct contains specified flag. func (*Document) Get \u00b6 func ( d * Document ) Get ( index int ) * Document Get always returns this document, this is a noop for compatibility with collection. func (Document) HasMany \u00b6 func ( d Document ) HasMany () [] string HasMany fields of this document. func (Document) HasOne \u00b6 func ( d Document ) HasOne () [] string HasOne fields of this document. func (Document) Index \u00b6 func ( d Document ) Index () map [ string ] int Index returns map of column name and it's struct index. func (*Document) Len \u00b6 func ( d * Document ) Len () int Len always returns 1 for document, this is a noop for compatibility with collection. func (Document) Persisted \u00b6 func ( d Document ) Persisted () bool Persisted returns true if document primary key is not zero. func (Document) PrimaryField \u00b6 func ( d Document ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key. func (Document) PrimaryFields \u00b6 func ( d Document ) PrimaryFields () [] string PrimaryFields column name of this document. func (Document) PrimaryValue \u00b6 func ( d Document ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key. func (Document) PrimaryValues \u00b6 func ( d Document ) PrimaryValues () [] interface {} PrimaryValues of this document. func (Document) ReflectValue \u00b6 func ( d Document ) ReflectValue () reflect . Value ReflectValue of referenced document. func (Document) Reset \u00b6 func ( d Document ) Reset () Reset this document, this is a noop for compatibility with collection. func (Document) Scanners \u00b6 func ( d Document ) Scanners ( fields [] string ) [] interface {} Scanners returns slice of sql.Scanner for given fields. func (Document) SetValue \u00b6 func ( d Document ) SetValue ( field string , value interface {}) bool SetValue of the field, it returns false if field does not exist, or it's not assignable. func (Document) Table \u00b6 func ( d Document ) Table () string Table returns name of the table. func (Document) Type \u00b6 func ( d Document ) Type ( field string ) ( reflect . Type , bool ) Type returns reflect.Type of given field. if field does not exist, second returns value will be false. func (Document) Value \u00b6 func ( d Document ) Value ( field string ) ( interface {}, bool ) Value returns value of given field. if field does not exist, second returns value will be false. type DocumentFlag \u00b6 type DocumentFlag int8 DocumentFlag stores information about document as a flag. const ( // Invalid flag. Invalid DocumentFlag = 1 << iota // HasCreatedAt flag. HasCreatedAt // HasUpdatedAt flag. HasUpdatedAt // HasDeletedAt flag. HasDeletedAt ) func (DocumentFlag) Is \u00b6 func ( df DocumentFlag ) Is ( flag DocumentFlag ) bool Is returns true if it's defined. type ErrorFunc \u00b6 type ErrorFunc func ( error ) error ErrorFunc allows conversion REL's error to Application custom errors. func (ErrorFunc) Apply \u00b6 func ( ef ErrorFunc ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. type FilterOp \u00b6 type FilterOp int FilterOp defines enumeration of all supported filter types. const ( // FilterAndOp is filter type for and operator. FilterAndOp FilterOp = iota // FilterOrOp is filter type for or operator. FilterOrOp // FilterNotOp is filter type for not operator. FilterNotOp // FilterEqOp is filter type for equal comparison. FilterEqOp // FilterNeOp is filter type for not equal comparison. FilterNeOp // FilterLtOp is filter type for less than comparison. FilterLtOp // FilterLteOp is filter type for less than or equal comparison. FilterLteOp // FilterGtOp is filter type for greater than comparison. FilterGtOp // FilterGteOp is filter type for greter than or equal comparison. FilterGteOp // FilterNilOp is filter type for nil check. FilterNilOp // FilterNotNilOp is filter type for not nil check. FilterNotNilOp // FilterInOp is filter type for inclusion comparison. FilterInOp // FilterNinOp is filter type for not inclusion comparison. FilterNinOp // FilterLikeOp is filter type for like comparison. FilterLikeOp // FilterNotLikeOp is filter type for not like comparison. FilterNotLikeOp // FilterFragmentOp is filter type for custom filter. FilterFragmentOp ) type FilterQuery \u00b6 type FilterQuery struct { Type FilterOp Field string Value interface {} Inner [] FilterQuery } FilterQuery defines details of a coundition type. func And \u00b6 func And ( inner ... FilterQuery ) FilterQuery And compares other filters using and. func Eq \u00b6 func Eq ( field string , value interface {}) FilterQuery Eq expression field equal to value. func FilterFragment \u00b6 func FilterFragment ( expr string , values ... interface {}) FilterQuery FilterFragment add custom filter. func Gt \u00b6 func Gt ( field string , value interface {}) FilterQuery Gt compares that left value is greater than to right value. func Gte \u00b6 func Gte ( field string , value interface {}) FilterQuery Gte compares that left value is greater than or equal to right value. func In \u00b6 func In ( field string , values ... interface {}) FilterQuery In check whethers value of the field is included in values. func InInt \u00b6 func InInt ( field string , values [] int ) FilterQuery InInt check whethers integer values of the field is included. func InString \u00b6 func InString ( field string , values [] string ) FilterQuery InString check whethers string values of the field is included. func InUint \u00b6 func InUint ( field string , values [] uint ) FilterQuery InUint check whethers unsigned integer values of the field is included. func Like \u00b6 func Like ( field string , pattern string ) FilterQuery Like compares value of field to match string pattern. func Lt \u00b6 func Lt ( field string , value interface {}) FilterQuery Lt compares that left value is less than to right value. func Lte \u00b6 func Lte ( field string , value interface {}) FilterQuery Lte compares that left value is less than or equal to right value. func Ne \u00b6 func Ne ( field string , value interface {}) FilterQuery Ne compares that left value is not equal to right value. func Nil \u00b6 func Nil ( field string ) FilterQuery Nil check whether field is nil. func Nin \u00b6 func Nin ( field string , values ... interface {}) FilterQuery Nin check whethers value of the field is not included in values. func NinInt \u00b6 func NinInt ( field string , values [] int ) FilterQuery NinInt check whethers integer values of the is not included. func NinString \u00b6 func NinString ( field string , values [] string ) FilterQuery NinString check whethers string values of the is not included. func NinUint \u00b6 func NinUint ( field string , values [] uint ) FilterQuery NinUint check whethers unsigned integer values of the is not included. func Not \u00b6 func Not ( inner ... FilterQuery ) FilterQuery Not wraps filters using not. It'll negate the filter type if possible. func NotLike \u00b6 func NotLike ( field string , pattern string ) FilterQuery NotLike compares value of field to not match string pattern. func NotNil \u00b6 func NotNil ( field string ) FilterQuery NotNil check whether field is not nil. func Or \u00b6 func Or ( inner ... FilterQuery ) FilterQuery Or compares other filters using and. func (FilterQuery) And \u00b6 func ( fq FilterQuery ) And ( filters ... FilterQuery ) FilterQuery And wraps filters using and. func (FilterQuery) AndEq \u00b6 func ( fq FilterQuery ) AndEq ( field string , value interface {}) FilterQuery AndEq append equal expression using and. func (FilterQuery) AndFragment \u00b6 func ( fq FilterQuery ) AndFragment ( expr string , values ... interface {}) FilterQuery AndFragment append fragment using and. func (FilterQuery) AndGt \u00b6 func ( fq FilterQuery ) AndGt ( field string , value interface {}) FilterQuery AndGt append greater than expression using and. func (FilterQuery) AndGte \u00b6 func ( fq FilterQuery ) AndGte ( field string , value interface {}) FilterQuery AndGte append greater than or equal expression using and. func (FilterQuery) AndIn \u00b6 func ( fq FilterQuery ) AndIn ( field string , values ... interface {}) FilterQuery AndIn append is in expression using and. func (FilterQuery) AndLike \u00b6 func ( fq FilterQuery ) AndLike ( field string , pattern string ) FilterQuery AndLike append like expression using and. func (FilterQuery) AndLt \u00b6 func ( fq FilterQuery ) AndLt ( field string , value interface {}) FilterQuery AndLt append lesser than expression using and. func (FilterQuery) AndLte \u00b6 func ( fq FilterQuery ) AndLte ( field string , value interface {}) FilterQuery AndLte append lesser than or equal expression using and. func (FilterQuery) AndNe \u00b6 func ( fq FilterQuery ) AndNe ( field string , value interface {}) FilterQuery AndNe append not equal expression using and. func (FilterQuery) AndNil \u00b6 func ( fq FilterQuery ) AndNil ( field string ) FilterQuery AndNil append is nil expression using and. func (FilterQuery) AndNin \u00b6 func ( fq FilterQuery ) AndNin ( field string , values ... interface {}) FilterQuery AndNin append is not in expression using and. func (FilterQuery) AndNotLike \u00b6 func ( fq FilterQuery ) AndNotLike ( field string , pattern string ) FilterQuery AndNotLike append not like expression using and. func (FilterQuery) AndNotNil \u00b6 func ( fq FilterQuery ) AndNotNil ( field string ) FilterQuery AndNotNil append is not nil expression using and. func (FilterQuery) Build \u00b6 func ( fq FilterQuery ) Build ( query * Query ) Build Filter query. func (FilterQuery) None \u00b6 func ( fq FilterQuery ) None () bool None returns true if no filter is specified. func (FilterQuery) Or \u00b6 func ( fq FilterQuery ) Or ( filter ... FilterQuery ) FilterQuery Or wraps filters using or. func (FilterQuery) OrEq \u00b6 func ( fq FilterQuery ) OrEq ( field string , value interface {}) FilterQuery OrEq append equal expression using or. func (FilterQuery) OrFragment \u00b6 func ( fq FilterQuery ) OrFragment ( expr string , values ... interface {}) FilterQuery OrFragment append fragment using or. func (FilterQuery) OrGt \u00b6 func ( fq FilterQuery ) OrGt ( field string , value interface {}) FilterQuery OrGt append greater than expression using or. func (FilterQuery) OrGte \u00b6 func ( fq FilterQuery ) OrGte ( field string , value interface {}) FilterQuery OrGte append greater than or equal expression using or. func (FilterQuery) OrIn \u00b6 func ( fq FilterQuery ) OrIn ( field string , values ... interface {}) FilterQuery OrIn append is in expression using or. func (FilterQuery) OrLike \u00b6 func ( fq FilterQuery ) OrLike ( field string , pattern string ) FilterQuery OrLike append like expression using or. func (FilterQuery) OrLt \u00b6 func ( fq FilterQuery ) OrLt ( field string , value interface {}) FilterQuery OrLt append lesser than expression using or. func (FilterQuery) OrLte \u00b6 func ( fq FilterQuery ) OrLte ( field string , value interface {}) FilterQuery OrLte append lesser than or equal expression using or. func (FilterQuery) OrNe \u00b6 func ( fq FilterQuery ) OrNe ( field string , value interface {}) FilterQuery OrNe append not equal expression using or. func (FilterQuery) OrNil \u00b6 func ( fq FilterQuery ) OrNil ( field string ) FilterQuery OrNil append is nil expression using or. func (FilterQuery) OrNin \u00b6 func ( fq FilterQuery ) OrNin ( field string , values ... interface {}) FilterQuery OrNin append is not in expression using or. func (FilterQuery) OrNotLike \u00b6 func ( fq FilterQuery ) OrNotLike ( field string , pattern string ) FilterQuery OrNotLike append not like expression using or. func (FilterQuery) OrNotNil \u00b6 func ( fq FilterQuery ) OrNotNil ( field string ) FilterQuery OrNotNil append is not nil expression using or. type ForeignKeyReference \u00b6 type ForeignKeyReference struct { Table string Columns [] string OnDelete string OnUpdate string } ForeignKeyReference definition. type GroupQuery \u00b6 type GroupQuery struct { Fields [] string Filter FilterQuery } GroupQuery defines group clause of the query. func NewGroup \u00b6 func NewGroup ( fields ... string ) GroupQuery NewGroup query. func (GroupQuery) Build \u00b6 func ( gq GroupQuery ) Build ( query * Query ) Build query. func (GroupQuery) Having \u00b6 func ( gq GroupQuery ) Having ( filters ... FilterQuery ) GroupQuery Having appends filter for group query with and operand. func (GroupQuery) OrHaving \u00b6 func ( gq GroupQuery ) OrHaving ( filters ... FilterQuery ) GroupQuery OrHaving appends filter for group query with or operand. func (GroupQuery) OrWhere \u00b6 func ( gq GroupQuery ) OrWhere ( filters ... FilterQuery ) GroupQuery OrWhere is alias for OrHaving. func (GroupQuery) Where \u00b6 func ( gq GroupQuery ) Where ( filters ... FilterQuery ) GroupQuery Where is alias for having. type Index \u00b6 type Index struct { Op SchemaOp Table string Name string Unique bool Columns [] string Optional bool Options string } Index definition. type IndexOption \u00b6 type IndexOption interface { // contains filtered or unexported methods } IndexOption interface. Available options are: Comment, Options. type Instrumenter \u00b6 type Instrumenter func ( ctx context . Context , op string , message string ) func ( err error ) Instrumenter defines function type that can be used for instrumetation. This function should return a function with no argument as a callback for finished execution. type Iterator \u00b6 type Iterator interface { io . Closer Next ( record interface {}) error } Iterator alllows iterating through all record in database in batch. type IteratorOption \u00b6 type IteratorOption interface { // contains filtered or unexported methods } IteratorOption is used to configure iteration behaviour, such as batch size, start id and finish id. func BatchSize \u00b6 func BatchSize ( size int ) IteratorOption BatchSize specifies the size of iterator batch. Defaults to 1000. func Finish \u00b6 func Finish ( id ... interface {}) IteratorOption Finish specfies the primary value to finish at (inclusive). func Start \u00b6 func Start ( id ... interface {}) IteratorOption Start specfies the primary value to start from (inclusive). type JoinQuery \u00b6 type JoinQuery struct { Mode string Table string From string To string Arguments [] interface {} } JoinQuery defines join clause in query. func NewFullJoin \u00b6 func NewFullJoin ( table string ) JoinQuery NewFullJoin with given table. func NewFullJoinOn \u00b6 func NewFullJoinOn ( table string , from string , to string ) JoinQuery NewFullJoinOn table with given field. func NewInnerJoin \u00b6 func NewInnerJoin ( table string ) JoinQuery NewInnerJoin with given table. func NewInnerJoinOn \u00b6 func NewInnerJoinOn ( table string , from string , to string ) JoinQuery NewInnerJoinOn table with given field. func NewJoin \u00b6 func NewJoin ( table string ) JoinQuery NewJoin with given table. func NewJoinFragment \u00b6 func NewJoinFragment ( expr string , args ... interface {}) JoinQuery NewJoinFragment defines a join clause using raw query. func NewJoinOn \u00b6 func NewJoinOn ( table string , from string , to string ) JoinQuery NewJoinOn table with given field. func NewJoinWith \u00b6 func NewJoinWith ( mode string , table string , from string , to string ) JoinQuery NewJoinWith query with custom join mode, table and field. func NewLeftJoin \u00b6 func NewLeftJoin ( table string ) JoinQuery NewLeftJoin with given table. func NewLeftJoinOn \u00b6 func NewLeftJoinOn ( table string , from string , to string ) JoinQuery NewLeftJoinOn table with given field. func NewRightJoin \u00b6 func NewRightJoin ( table string ) JoinQuery NewRightJoin with given table. func NewRightJoinOn \u00b6 func NewRightJoinOn ( table string , from string , to string ) JoinQuery NewRightJoinOn table with given field. func (JoinQuery) Build \u00b6 func ( jq JoinQuery ) Build ( query * Query ) Build query. type Key \u00b6 type Key struct { Op SchemaOp Name string Type KeyType Columns [] string Rename string Reference ForeignKeyReference Options string } Key definition. type KeyOption \u00b6 type KeyOption interface { // contains filtered or unexported methods } KeyOption interface. Available options are: Comment, Options. type KeyType \u00b6 type KeyType string KeyType definition. const ( // PrimaryKey KeyType. PrimaryKey KeyType = \"PRIMARY KEY\" // ForeignKey KeyType. ForeignKey KeyType = \"FOREIGN KEY\" // UniqueKey KeyType. UniqueKey = \"UNIQUE\" ) type Limit \u00b6 type Limit int Limit options. When passed as query, it limits returned result from database. When passed as column option, it sets the maximum size of the string/text/binary/integer columns. func (Limit) Build \u00b6 func ( l Limit ) Build ( query * Query ) Build query. type Lock \u00b6 type Lock string Lock query. This query will be ignored if used outside of transaction. func ForUpdate \u00b6 func ForUpdate () Lock ForUpdate lock query. func (Lock) Build \u00b6 func ( l Lock ) Build ( query * Query ) Build query. type Map \u00b6 type Map map [ string ] interface {} Map can be used as mutation for repository insert or update operation. This allows inserting or updating only on specified field. Insert/Update of has one or belongs to can be done using other Map as a value. Insert/Update of has many can be done using slice of Map as a value. Map is intended to be used internally within application, and not to be exposed directly as an APIs. func (Map) Apply \u00b6 func ( m Map ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. type Migration \u00b6 type Migration interface { // contains filtered or unexported methods } Migration definition. type Mutate \u00b6 type Mutate struct { Type ChangeOp Field string Value interface {} } Mutate stores mutation instruction. func Dec \u00b6 func Dec ( field string ) Mutate Dec create a mutate using deccrement operation. func DecBy \u00b6 func DecBy ( field string , n int ) Mutate DecBy create a mutate using decrement operation with custom decrement value. func Inc \u00b6 func Inc ( field string ) Mutate Inc create a mutate using increment operation. func IncBy \u00b6 func IncBy ( field string , n int ) Mutate IncBy create a mutate using increment operation with custom increment value. func Set \u00b6 func Set ( field string , value interface {}) Mutate Set create a mutate using set operation. func SetFragment \u00b6 func SetFragment ( raw string , args ... interface {}) Mutate SetFragment create a mutate operation using randoc fragment operation. Only available for Update. func (Mutate) Apply \u00b6 func ( m Mutate ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. type Mutation \u00b6 type Mutation struct { Mutates map [ string ] Mutate Assoc map [ string ] AssocMutation Unscoped Unscoped Reload Reload Cascade Cascade ErrorFunc ErrorFunc } Mutation represents value to be inserted or updated to database. It's not safe to be used multiple time. some operation my alter mutation data. func Apply \u00b6 func Apply ( doc * Document , mutators ... Mutator ) Mutation Apply using given mutators. func (*Mutation) Add \u00b6 func ( m * Mutation ) Add ( mut Mutate ) Add a mutate. func (*Mutation) IsAssocEmpty \u00b6 func ( m * Mutation ) IsAssocEmpty () bool IsAssocEmpty returns true if no assoc's mutation is defined. func (*Mutation) IsEmpty \u00b6 func ( m * Mutation ) IsEmpty () bool IsEmpty returns true if no mutates operation and assoc's mutation is defined. func (*Mutation) IsMutatesEmpty \u00b6 func ( m * Mutation ) IsMutatesEmpty () bool IsMutatesEmpty returns true if no mutates operation is defined. func (*Mutation) SetAssoc \u00b6 func ( m * Mutation ) SetAssoc ( field string , muts ... Mutation ) SetAssoc mutation. func (*Mutation) SetDeletedIDs \u00b6 func ( m * Mutation ) SetDeletedIDs ( field string , ids [] interface {}) SetDeletedIDs mutation. nil slice will clear association. type Mutator \u00b6 type Mutator interface { Apply ( doc * Document , mutation * Mutation ) } Mutator is interface for a record mutator. type Name \u00b6 type Name string Name option for defining custom index name. type NotFoundError \u00b6 type NotFoundError struct {} NotFoundError returned whenever Find returns no result. func (NotFoundError) Error \u00b6 func ( nfe NotFoundError ) Error () string Error message. type Offset \u00b6 type Offset int Offset Query. func (Offset) Build \u00b6 func ( o Offset ) Build ( query * Query ) Build query. type OnDelete \u00b6 type OnDelete string OnDelete option for foreign key. type OnUpdate \u00b6 type OnUpdate string OnUpdate option for foreign key. type Optional \u00b6 type Optional bool Optional option. when used with create table, will create table only if it's not exists. when used with drop table, will drop table only if it's exists. type Options \u00b6 type Options string Options options for table, column and index. type Precision \u00b6 type Precision int Precision defines the precision for the decimal fields, representing the total number of digits in the number. type Querier \u00b6 type Querier interface { Build ( * Query ) } Querier interface defines contract to be used for query builder. type Query \u00b6 type Query struct { Table string SelectQuery SelectQuery JoinQuery [] JoinQuery WhereQuery FilterQuery GroupQuery GroupQuery SortQuery [] SortQuery OffsetQuery Offset LimitQuery Limit LockQuery Lock UnscopedQuery Unscoped ReloadQuery Reload SQLQuery SQLQuery // contains filtered or unexported fields } Query defines information about query generated by query builder. func Build \u00b6 func Build ( table string , queriers ... Querier ) Query Build for given table using given queriers. func From \u00b6 func From ( table string ) Query From create a query with chainable syntax, using from as the starting point. func Join \u00b6 func Join ( table string ) Query Join create a query with chainable syntax, using join as the starting point. func JoinOn \u00b6 func JoinOn ( table string , from string , to string ) Query JoinOn create a query with chainable syntax, using join as the starting point. func JoinWith \u00b6 func JoinWith ( mode string , table string , from string , to string ) Query JoinWith create a query with chainable syntax, using join as the starting point. func Joinf \u00b6 func Joinf ( expr string , args ... interface {}) Query Joinf create a query with chainable syntax, using join as the starting point. func Select \u00b6 func Select ( fields ... string ) Query Select query create a query with chainable syntax, using select as the starting point. func Where \u00b6 func Where ( filters ... FilterQuery ) Query Where create a query with chainable syntax, using where as the starting point. func (Query) Build \u00b6 func ( q Query ) Build ( query * Query ) Build query. func (Query) Distinct \u00b6 func ( q Query ) Distinct () Query Distinct sets select query to be distinct. func (Query) From \u00b6 func ( q Query ) From ( table string ) Query From set the table to be used for query. func (Query) Group \u00b6 func ( q Query ) Group ( fields ... string ) Query Group query. func (Query) Having \u00b6 func ( q Query ) Having ( filters ... FilterQuery ) Query Having query. func (Query) Havingf \u00b6 func ( q Query ) Havingf ( expr string , args ... interface {}) Query Havingf create having query using a raw query. func (Query) Join \u00b6 func ( q Query ) Join ( table string ) Query Join current table with other table. func (Query) JoinOn \u00b6 func ( q Query ) JoinOn ( table string , from string , to string ) Query JoinOn current table with other table. func (Query) JoinWith \u00b6 func ( q Query ) JoinWith ( mode string , table string , from string , to string ) Query JoinWith current table with other table with custom join mode. func (Query) Joinf \u00b6 func ( q Query ) Joinf ( expr string , args ... interface {}) Query Joinf create join query using a raw query. func (Query) Limit \u00b6 func ( q Query ) Limit ( limit int ) Query Limit result returned by database. func (Query) Lock \u00b6 func ( q Query ) Lock ( lock string ) Query Lock query expression. func (Query) Offset \u00b6 func ( q Query ) Offset ( offset int ) Query Offset the result returned by database. func (Query) OrHaving \u00b6 func ( q Query ) OrHaving ( filters ... FilterQuery ) Query OrHaving query. func (Query) OrHavingf \u00b6 func ( q Query ) OrHavingf ( expr string , args ... interface {}) Query OrHavingf create having query using a raw query. func (Query) OrWhere \u00b6 func ( q Query ) OrWhere ( filters ... FilterQuery ) Query OrWhere query. func (Query) OrWheref \u00b6 func ( q Query ) OrWheref ( expr string , args ... interface {}) Query OrWheref create where query using a raw query. func (Query) Reload \u00b6 func ( q Query ) Reload () Query Reload force reloading association on preload. func (Query) Select \u00b6 func ( q Query ) Select ( fields ... string ) Query Select filter fields to be selected from database. func (Query) Sort \u00b6 func ( q Query ) Sort ( fields ... string ) Query Sort query. func (Query) SortAsc \u00b6 func ( q Query ) SortAsc ( fields ... string ) Query SortAsc query. func (Query) SortDesc \u00b6 func ( q Query ) SortDesc ( fields ... string ) Query SortDesc query. func (Query) Unscoped \u00b6 func ( q Query ) Unscoped () Query Unscoped allows soft-delete to be ignored. func (Query) Where \u00b6 func ( q Query ) Where ( filters ... FilterQuery ) Query Where query. func (Query) Wheref \u00b6 func ( q Query ) Wheref ( expr string , args ... interface {}) Query Wheref create where query using a raw query. type Raw \u00b6 type Raw string Raw string type Reload \u00b6 type Reload bool Reload force reload after insert/update. Default to false. func (Reload) Apply \u00b6 func ( r Reload ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Reload) Build \u00b6 func ( r Reload ) Build ( query * Query ) Build query. type Repository \u00b6 type Repository interface { Adapter ( ctx context . Context ) Adapter Instrumentation ( instrumenter Instrumenter ) Ping ( ctx context . Context ) error Iterate ( ctx context . Context , query Query , option ... IteratorOption ) Iterator Aggregate ( ctx context . Context , query Query , aggregate string , field string ) ( int , error ) MustAggregate ( ctx context . Context , query Query , aggregate string , field string ) int Count ( ctx context . Context , collection string , queriers ... Querier ) ( int , error ) MustCount ( ctx context . Context , collection string , queriers ... Querier ) int Find ( ctx context . Context , record interface {}, queriers ... Querier ) error MustFind ( ctx context . Context , record interface {}, queriers ... Querier ) FindAll ( ctx context . Context , records interface {}, queriers ... Querier ) error MustFindAll ( ctx context . Context , records interface {}, queriers ... Querier ) FindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) ( int , error ) MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) int Insert ( ctx context . Context , record interface {}, mutators ... Mutator ) error MustInsert ( ctx context . Context , record interface {}, mutators ... Mutator ) InsertAll ( ctx context . Context , records interface {}) error MustInsertAll ( ctx context . Context , records interface {}) Update ( ctx context . Context , record interface {}, mutators ... Mutator ) error MustUpdate ( ctx context . Context , record interface {}, mutators ... Mutator ) UpdateAll ( ctx context . Context , query Query , mutates ... Mutate ) error MustUpdateAll ( ctx context . Context , query Query , mutates ... Mutate ) Delete ( ctx context . Context , record interface {}, options ... Cascade ) error MustDelete ( ctx context . Context , record interface {}, options ... Cascade ) DeleteAll ( ctx context . Context , query Query ) error MustDeleteAll ( ctx context . Context , query Query ) Preload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) error MustPreload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error } Repository defines sets of available database operations. func New \u00b6 func New ( adapter Adapter ) Repository New create new repo using adapter. type Required \u00b6 type Required bool Required disallows nil values in the column. type SQLQuery \u00b6 type SQLQuery struct { Statement string Values [] interface {} } SQLQuery allows querying using native query supported by database. func SQL \u00b6 func SQL ( statement string , values ... interface {}) SQLQuery SQL Query. func (SQLQuery) Build \u00b6 func ( sq SQLQuery ) Build ( query * Query ) Build Raw Query. type Scale \u00b6 type Scale int Scale Defines the scale for the decimal fields, representing the number of digits after the decimal point. type Schema \u00b6 type Schema struct { Migrations [] Migration } Schema builder. func (*Schema) AddColumn \u00b6 func ( s * Schema ) AddColumn ( table string , name string , typ ColumnType , options ... ColumnOption ) AddColumn with name and type. func (*Schema) AlterTable \u00b6 func ( s * Schema ) AlterTable ( name string , fn func ( t * AlterTable ), options ... TableOption ) AlterTable with name and its definition. func (*Schema) CreateIndex \u00b6 func ( s * Schema ) CreateIndex ( table string , name string , column [] string , options ... IndexOption ) CreateIndex for columns on a table. func (*Schema) CreateTable \u00b6 func ( s * Schema ) CreateTable ( name string , fn func ( t * Table ), options ... TableOption ) CreateTable with name and its definition. func (*Schema) CreateTableIfNotExists \u00b6 func ( s * Schema ) CreateTableIfNotExists ( name string , fn func ( t * Table ), options ... TableOption ) CreateTableIfNotExists with name and its definition. func (*Schema) CreateUniqueIndex \u00b6 func ( s * Schema ) CreateUniqueIndex ( table string , name string , column [] string , options ... IndexOption ) CreateUniqueIndex for columns on a table. func (*Schema) Do \u00b6 func ( s * Schema ) Do ( fn Do ) Do migration using golang codes. func (*Schema) DropColumn \u00b6 func ( s * Schema ) DropColumn ( table string , name string , options ... ColumnOption ) DropColumn by name. func (*Schema) DropIndex \u00b6 func ( s * Schema ) DropIndex ( table string , name string , options ... IndexOption ) DropIndex by name. func (*Schema) DropTable \u00b6 func ( s * Schema ) DropTable ( name string , options ... TableOption ) DropTable by name. func (*Schema) DropTableIfExists \u00b6 func ( s * Schema ) DropTableIfExists ( name string , options ... TableOption ) DropTableIfExists by name. func (*Schema) Exec \u00b6 func ( s * Schema ) Exec ( raw Raw ) Exec queries. func (*Schema) RenameColumn \u00b6 func ( s * Schema ) RenameColumn ( table string , name string , newName string , options ... ColumnOption ) RenameColumn by name. func (*Schema) RenameTable \u00b6 func ( s * Schema ) RenameTable ( name string , newName string , options ... TableOption ) RenameTable by name. type SchemaOp \u00b6 type SchemaOp uint8 SchemaOp type. const ( // SchemaCreate operation. SchemaCreate SchemaOp = iota // SchemaAlter operation. SchemaAlter // SchemaRename operation. SchemaRename // SchemaDrop operation. SchemaDrop ) type SelectQuery \u00b6 type SelectQuery struct { OnlyDistinct bool Fields [] string } SelectQuery defines select clause of the query. func NewSelect \u00b6 func NewSelect ( fields ... string ) SelectQuery NewSelect query. func (SelectQuery) Distinct \u00b6 func ( sq SelectQuery ) Distinct () SelectQuery Distinct select query. type SortQuery \u00b6 type SortQuery struct { Field string Sort int } SortQuery defines sort information of query. func NewSortAsc \u00b6 func NewSortAsc ( field string ) SortQuery NewSortAsc sorts field with ascending sort. func NewSortDesc \u00b6 func NewSortDesc ( field string ) SortQuery NewSortDesc sorts field with descending sort. func (SortQuery) Asc \u00b6 func ( sq SortQuery ) Asc () bool Asc returns true if sort is ascending. func (SortQuery) Build \u00b6 func ( sq SortQuery ) Build ( query * Query ) Build sort query. func (SortQuery) Desc \u00b6 func ( sq SortQuery ) Desc () bool Desc returns true if s is descending. type Structset \u00b6 type Structset struct { // contains filtered or unexported fields } Structset can be used as mutation for repository insert or update operation. This will save every field in struct and it's association as long as it's loaded. This is the default mutator used by repository. func NewStructset \u00b6 func NewStructset ( record interface {}, skipZero bool ) Structset NewStructset from a struct. func (Structset) Apply \u00b6 func ( s Structset ) Apply ( doc * Document , mut * Mutation ) Apply mutation. type Table \u00b6 type Table struct { Op SchemaOp Name string Rename string Definitions [] TableDefinition Optional bool Options string } Table definition. func (*Table) BigInt \u00b6 func ( t * Table ) BigInt ( name string , options ... ColumnOption ) BigInt defines a column with name and BigInt type. func (*Table) Bool \u00b6 func ( t * Table ) Bool ( name string , options ... ColumnOption ) Bool defines a column with name and Bool type. func (*Table) Column \u00b6 func ( t * Table ) Column ( name string , typ ColumnType , options ... ColumnOption ) Column defines a column with name and type. func (*Table) Date \u00b6 func ( t * Table ) Date ( name string , options ... ColumnOption ) Date defines a column with name and Date type. func (*Table) DateTime \u00b6 func ( t * Table ) DateTime ( name string , options ... ColumnOption ) DateTime defines a column with name and DateTime type. func (*Table) Decimal \u00b6 func ( t * Table ) Decimal ( name string , options ... ColumnOption ) Decimal defines a column with name and Decimal type. func (*Table) Float \u00b6 func ( t * Table ) Float ( name string , options ... ColumnOption ) Float defines a column with name and Float type. func (*Table) ForeignKey \u00b6 func ( t * Table ) ForeignKey ( column string , refTable string , refColumn string , options ... KeyOption ) ForeignKey defines foreign key index. func (*Table) Fragment \u00b6 func ( t * Table ) Fragment ( fragment string ) Fragment defines anything using sql fragment. func (*Table) ID \u00b6 func ( t * Table ) ID ( name string , options ... ColumnOption ) ID defines a column with name and ID type. the resulting database type will depends on database. func (*Table) Int \u00b6 func ( t * Table ) Int ( name string , options ... ColumnOption ) Int defines a column with name and Int type. func (*Table) PrimaryKey \u00b6 func ( t * Table ) PrimaryKey ( column string , options ... KeyOption ) PrimaryKey defines a primary key for table. func (*Table) PrimaryKeys \u00b6 func ( t * Table ) PrimaryKeys ( columns [] string , options ... KeyOption ) PrimaryKeys defines composite primary keys for table. func (*Table) String \u00b6 func ( t * Table ) String ( name string , options ... ColumnOption ) String defines a column with name and String type. func (*Table) Text \u00b6 func ( t * Table ) Text ( name string , options ... ColumnOption ) Text defines a column with name and Text type. func (*Table) Time \u00b6 func ( t * Table ) Time ( name string , options ... ColumnOption ) Time defines a column with name and Time type. func (*Table) Timestamp \u00b6 func ( t * Table ) Timestamp ( name string , options ... ColumnOption ) Timestamp defines a column with name and Timestamp type. func (*Table) Unique \u00b6 func ( t * Table ) Unique ( columns [] string , options ... KeyOption ) Unique defines an unique key for columns. type TableDefinition \u00b6 type TableDefinition interface { // contains filtered or unexported methods } TableDefinition interface. type TableOption \u00b6 type TableOption interface { // contains filtered or unexported methods } TableOption interface. Available options are: Comment, Options. type Unique \u00b6 type Unique bool Unique set column as unique. type Unscoped \u00b6 type Unscoped bool Unscoped query. func (Unscoped) Apply \u00b6 func ( u Unscoped ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Unscoped) Build \u00b6 func ( u Unscoped ) Build ( query * Query ) Build query. type Unsigned \u00b6 type Unsigned bool Unsigned sets integer column to be unsigned.","title":"github.com/Fs02/rel"},{"location":"reference/rel/#rel","text":"import \"github.com/Fs02/rel\"","title":"rel"},{"location":"reference/rel/#overview","text":"Package rel is a Database Layer for SQL Database.","title":"Overview"},{"location":"reference/rel/#constants","text":"const ( // BelongsTo association. BelongsTo = iota // HasOne association. HasOne // HasMany association. HasMany )","title":"Constants"},{"location":"reference/rel/#variables","text":"var ( // ErrNotFound returned when records not found. ErrNotFound = NotFoundError {} // ErrCheckConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrCheckConstraint). ErrCheckConstraint = ConstraintError { Type : CheckConstraint } // ErrNotNullConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrNotNullConstraint). ErrNotNullConstraint = ConstraintError { Type : NotNullConstraint } // ErrUniqueConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrUniqueConstraint). ErrUniqueConstraint = ConstraintError { Type : UniqueConstraint } // ErrPrimaryKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrPrimaryKeyConstraint). ErrPrimaryKeyConstraint = ConstraintError { Type : PrimaryKeyConstraint } // ErrForeignKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrForeignKeyConstraint). ErrForeignKeyConstraint = ConstraintError { Type : ForeignKeyConstraint } ) var Setf = SetFragment Setf is an alias for SetFragment","title":"Variables"},{"location":"reference/rel/#func-defaultlogger","text":"func DefaultLogger ( ctx context . Context , op string , message string ) func ( err error ) DefaultLogger instrumentation to log queries and rel operation.","title":"func DefaultLogger"},{"location":"reference/rel/#func-nullable","text":"func Nullable ( dest interface {}) interface {} Nullable wrap value as a nullable sql.Scanner. If value returned from database is nil, nullable scanner will set dest to zero value.","title":"func Nullable"},{"location":"reference/rel/#type-adapter","text":"type Adapter interface { Instrumentation ( instrumenter Instrumenter ) Ping ( ctx context . Context ) error Aggregate ( ctx context . Context , query Query , mode string , field string ) ( int , error ) Query ( ctx context . Context , query Query ) ( Cursor , error ) Insert ( ctx context . Context , query Query , primaryField string , mutates map [ string ] Mutate ) ( interface {}, error ) InsertAll ( ctx context . Context , query Query , primaryField string , fields [] string , bulkMutates [] map [ string ] Mutate ) ([] interface {}, error ) Update ( ctx context . Context , query Query , mutates map [ string ] Mutate ) ( int , error ) Delete ( ctx context . Context , query Query ) ( int , error ) Begin ( ctx context . Context ) ( Adapter , error ) Commit ( ctx context . Context ) error Rollback ( ctx context . Context ) error Apply ( ctx context . Context , migration Migration ) error } Adapter interface","title":"type Adapter"},{"location":"reference/rel/#type-altertable","text":"type AlterTable struct { Table } AlterTable Migrator.","title":"type AlterTable"},{"location":"reference/rel/#func-altertable-dropcolumn","text":"func ( at * AlterTable ) DropColumn ( name string , options ... ColumnOption ) DropColumn from this table.","title":"func (*AlterTable) DropColumn"},{"location":"reference/rel/#func-altertable-renamecolumn","text":"func ( at * AlterTable ) RenameColumn ( name string , newName string , options ... ColumnOption ) RenameColumn to a new name.","title":"func (*AlterTable) RenameColumn"},{"location":"reference/rel/#type-assocmutation","text":"type AssocMutation struct { Mutations [] Mutation DeletedIDs [] interface {} // This is array of single id, and doesn't support composite primary key. } AssocMutation represents mutation for association.","title":"type AssocMutation"},{"location":"reference/rel/#type-association","text":"type Association struct { // contains filtered or unexported fields } Association provides abstraction to work with association of document or collection.","title":"type Association"},{"location":"reference/rel/#func-association-collection","text":"func ( a Association ) Collection () ( * Collection , bool ) Collection returns association target as collection. If association is zero, second return value will be false.","title":"func (Association) Collection"},{"location":"reference/rel/#func-association-document","text":"func ( a Association ) Document () ( * Document , bool ) Document returns association target as document. If association is zero, second return value will be false.","title":"func (Association) Document"},{"location":"reference/rel/#func-association-foreignfield","text":"func ( a Association ) ForeignField () string ForeignField of the association.","title":"func (Association) ForeignField"},{"location":"reference/rel/#func-association-foreignvalue","text":"func ( a Association ) ForeignValue () interface {} ForeignValue of the association. It'll panic if association type is has many.","title":"func (Association) ForeignValue"},{"location":"reference/rel/#func-association-iszero","text":"func ( a Association ) IsZero () bool IsZero returns true if association is not loaded.","title":"func (Association) IsZero"},{"location":"reference/rel/#func-association-referencefield","text":"func ( a Association ) ReferenceField () string ReferenceField of the association.","title":"func (Association) ReferenceField"},{"location":"reference/rel/#func-association-referencevalue","text":"func ( a Association ) ReferenceValue () interface {} ReferenceValue of the association.","title":"func (Association) ReferenceValue"},{"location":"reference/rel/#func-association-type","text":"func ( a Association ) Type () AssociationType Type of association.","title":"func (Association) Type"},{"location":"reference/rel/#type-associationtype","text":"type AssociationType uint8 AssociationType defines the type of association in database.","title":"type AssociationType"},{"location":"reference/rel/#type-cascade","text":"type Cascade bool Cascade enable or disable updating associations. Default to true.","title":"type Cascade"},{"location":"reference/rel/#func-cascade-apply","text":"func ( c Cascade ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Cascade) Apply"},{"location":"reference/rel/#type-changeop","text":"type ChangeOp int ChangeOp represents type of mutate operation. const ( // ChangeInvalidOp operation. ChangeInvalidOp ChangeOp = iota // ChangeSetOp operation. ChangeSetOp // ChangeIncOp operation. ChangeIncOp // ChangeFragmentOp operation. ChangeFragmentOp )","title":"type ChangeOp"},{"location":"reference/rel/#type-changeset","text":"type Changeset struct { // contains filtered or unexported fields } Changeset mutator for structs. This allows REL to efficiently to perform update operation only on updated fields and association. The catch is, enabling changeset will duplicates the original struct values which consumes more memory.","title":"type Changeset"},{"location":"reference/rel/#func-newchangeset","text":"func NewChangeset ( record interface {}) Changeset NewChangeset returns new changeset mutator for given record.","title":"func NewChangeset"},{"location":"reference/rel/#func-changeset-apply","text":"func ( c Changeset ) Apply ( doc * Document , mut * Mutation ) Apply mutation.","title":"func (Changeset) Apply"},{"location":"reference/rel/#func-changeset-changes","text":"func ( c Changeset ) Changes () map [ string ] interface {} Changes returns map of changes.","title":"func (Changeset) Changes"},{"location":"reference/rel/#func-changeset-fieldchanged","text":"func ( c Changeset ) FieldChanged ( field string ) bool FieldChanged returns true if field exists and it's already chagned. returns false otherwise.","title":"func (Changeset) FieldChanged"},{"location":"reference/rel/#type-collection","text":"type Collection struct { // contains filtered or unexported fields } Collection provides an abstraction over reflect to easily works with slice for database purpose.","title":"type Collection"},{"location":"reference/rel/#func-newcollection","text":"func NewCollection ( records interface {}, readonly ... bool ) * Collection NewCollection used to create abstraction to work with slice. COllection can be created using interface or reflect.Value.","title":"func NewCollection"},{"location":"reference/rel/#func-collection-add","text":"func ( c Collection ) Add () * Document Add new document into collection.","title":"func (Collection) Add"},{"location":"reference/rel/#func-collection-get","text":"func ( c Collection ) Get ( index int ) * Document Get an element from the underlying slice as a document.","title":"func (Collection) Get"},{"location":"reference/rel/#func-collection-len","text":"func ( c Collection ) Len () int Len of the underlying slice.","title":"func (Collection) Len"},{"location":"reference/rel/#func-collection-primaryfield","text":"func ( c Collection ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key.","title":"func (Collection) PrimaryField"},{"location":"reference/rel/#func-collection-primaryfields","text":"func ( c Collection ) PrimaryFields () [] string PrimaryFields column name of this collection.","title":"func (Collection) PrimaryFields"},{"location":"reference/rel/#func-collection-primaryvalue","text":"func ( c Collection ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key.","title":"func (Collection) PrimaryValue"},{"location":"reference/rel/#func-collection-primaryvalues","text":"func ( c Collection ) PrimaryValues () [] interface {} PrimaryValues of collection. Returned value will be interface of slice interface.","title":"func (Collection) PrimaryValues"},{"location":"reference/rel/#func-collection-reflectvalue","text":"func ( c Collection ) ReflectValue () reflect . Value ReflectValue of referenced document.","title":"func (Collection) ReflectValue"},{"location":"reference/rel/#func-collection-reset","text":"func ( c Collection ) Reset () Reset underlying slice to be zero length.","title":"func (Collection) Reset"},{"location":"reference/rel/#func-collection-slice","text":"func ( c Collection ) Slice ( i , j int ) * Collection Slice returns a new collection that is a slice of the original collection.s","title":"func (Collection) Slice"},{"location":"reference/rel/#func-collection-swap","text":"func ( c Collection ) Swap ( i , j int ) Swap element in the collection.","title":"func (Collection) Swap"},{"location":"reference/rel/#func-collection-table","text":"func ( c * Collection ) Table () string Table returns name of the table.","title":"func (*Collection) Table"},{"location":"reference/rel/#func-collection-truncate","text":"func ( c Collection ) Truncate ( i , j int ) Truncate collection.","title":"func (Collection) Truncate"},{"location":"reference/rel/#type-column","text":"type Column struct { Op SchemaOp Name string Type ColumnType Rename string Unique bool Required bool Unsigned bool Limit int Precision int Scale int Default interface {} Options string } Column definition.","title":"type Column"},{"location":"reference/rel/#type-columnoption","text":"type ColumnOption interface { // contains filtered or unexported methods } ColumnOption interface. Available options are: Nil, Unsigned, Limit, Precision, Scale, Default, Comment, Options.","title":"type ColumnOption"},{"location":"reference/rel/#func-default","text":"func Default ( def interface {}) ColumnOption Default allows to set a default value on the column.).","title":"func Default"},{"location":"reference/rel/#type-columntype","text":"type ColumnType string ColumnType definition. const ( // ID ColumnType. ID ColumnType = \"ID\" // Bool ColumnType. Bool ColumnType = \"BOOL\" // Int ColumnType. Int ColumnType = \"INT\" // BigInt ColumnType. BigInt ColumnType = \"BIGINT\" // Float ColumnType. Float ColumnType = \"FLOAT\" // Decimal ColumnType. Decimal ColumnType = \"DECIMAL\" // String ColumnType. String ColumnType = \"STRING\" // Text ColumnType. Text ColumnType = \"TEXT\" // Date ColumnType. Date ColumnType = \"DATE\" // DateTime ColumnType. DateTime ColumnType = \"DATETIME\" // Time ColumnType. Time ColumnType = \"TIME\" // Timestamp ColumnType. Timestamp ColumnType = \"TIMESTAMP\" )","title":"type ColumnType"},{"location":"reference/rel/#type-constrainterror","text":"type ConstraintError struct { Key string Type ConstraintType Err error } ConstraintError returned whenever constraint error encountered.","title":"type ConstraintError"},{"location":"reference/rel/#func-constrainterror-error","text":"func ( ce ConstraintError ) Error () string Error message.","title":"func (ConstraintError) Error"},{"location":"reference/rel/#func-constrainterror-is","text":"func ( ce ConstraintError ) Is ( target error ) bool Is returns true when target error have the same type and key if defined.","title":"func (ConstraintError) Is"},{"location":"reference/rel/#func-constrainterror-unwrap","text":"func ( ce ConstraintError ) Unwrap () error Unwrap internal error returned by database driver.","title":"func (ConstraintError) Unwrap"},{"location":"reference/rel/#type-constrainttype","text":"type ConstraintType int8 ConstraintType defines the type of constraint error. const ( // CheckConstraint error type. CheckConstraint ConstraintType = iota // NotNullConstraint error type.1 NotNullConstraint // UniqueConstraint error type.1 UniqueConstraint // PrimaryKeyConstraint error type.1 PrimaryKeyConstraint // ForeignKeyConstraint error type.1 ForeignKeyConstraint )","title":"type ConstraintType"},{"location":"reference/rel/#func-constrainttype-string","text":"func ( ct ConstraintType ) String () string String representation of the constraint type.","title":"func (ConstraintType) String"},{"location":"reference/rel/#type-cursor","text":"type Cursor interface { Close () error Fields () ([] string , error ) Next () bool Scan ( ... interface {}) error NopScanner () interface {} // TODO: conflict with manual scanners interface } Cursor is interface to work with database result (used by adapter).","title":"type Cursor"},{"location":"reference/rel/#type-do","text":"type Do func ( Repository ) error Do used internally for schema migration.","title":"type Do"},{"location":"reference/rel/#type-document","text":"type Document struct { // contains filtered or unexported fields } Document provides an abstraction over reflect to easily works with struct for database purpose.","title":"type Document"},{"location":"reference/rel/#func-newdocument","text":"func NewDocument ( record interface {}, readonly ... bool ) * Document NewDocument used to create abstraction to work with struct. Document can be created using interface or reflect.Value.","title":"func NewDocument"},{"location":"reference/rel/#func-document-add","text":"func ( d * Document ) Add () * Document Add returns this document, this is a noop for compatibility with collection.","title":"func (*Document) Add"},{"location":"reference/rel/#func-document-association","text":"func ( d Document ) Association ( name string ) Association Association of this document with given name.","title":"func (Document) Association"},{"location":"reference/rel/#func-document-belongsto","text":"func ( d Document ) BelongsTo () [] string BelongsTo fields of this document.","title":"func (Document) BelongsTo"},{"location":"reference/rel/#func-document-fields","text":"func ( d Document ) Fields () [] string Fields returns list of fields available on this document.","title":"func (Document) Fields"},{"location":"reference/rel/#func-document-flag","text":"func ( d Document ) Flag ( flag DocumentFlag ) bool Flag returns true if struct contains specified flag.","title":"func (Document) Flag"},{"location":"reference/rel/#func-document-get","text":"func ( d * Document ) Get ( index int ) * Document Get always returns this document, this is a noop for compatibility with collection.","title":"func (*Document) Get"},{"location":"reference/rel/#func-document-hasmany","text":"func ( d Document ) HasMany () [] string HasMany fields of this document.","title":"func (Document) HasMany"},{"location":"reference/rel/#func-document-hasone","text":"func ( d Document ) HasOne () [] string HasOne fields of this document.","title":"func (Document) HasOne"},{"location":"reference/rel/#func-document-index","text":"func ( d Document ) Index () map [ string ] int Index returns map of column name and it's struct index.","title":"func (Document) Index"},{"location":"reference/rel/#func-document-len","text":"func ( d * Document ) Len () int Len always returns 1 for document, this is a noop for compatibility with collection.","title":"func (*Document) Len"},{"location":"reference/rel/#func-document-persisted","text":"func ( d Document ) Persisted () bool Persisted returns true if document primary key is not zero.","title":"func (Document) Persisted"},{"location":"reference/rel/#func-document-primaryfield","text":"func ( d Document ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key.","title":"func (Document) PrimaryField"},{"location":"reference/rel/#func-document-primaryfields","text":"func ( d Document ) PrimaryFields () [] string PrimaryFields column name of this document.","title":"func (Document) PrimaryFields"},{"location":"reference/rel/#func-document-primaryvalue","text":"func ( d Document ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key.","title":"func (Document) PrimaryValue"},{"location":"reference/rel/#func-document-primaryvalues","text":"func ( d Document ) PrimaryValues () [] interface {} PrimaryValues of this document.","title":"func (Document) PrimaryValues"},{"location":"reference/rel/#func-document-reflectvalue","text":"func ( d Document ) ReflectValue () reflect . Value ReflectValue of referenced document.","title":"func (Document) ReflectValue"},{"location":"reference/rel/#func-document-reset","text":"func ( d Document ) Reset () Reset this document, this is a noop for compatibility with collection.","title":"func (Document) Reset"},{"location":"reference/rel/#func-document-scanners","text":"func ( d Document ) Scanners ( fields [] string ) [] interface {} Scanners returns slice of sql.Scanner for given fields.","title":"func (Document) Scanners"},{"location":"reference/rel/#func-document-setvalue","text":"func ( d Document ) SetValue ( field string , value interface {}) bool SetValue of the field, it returns false if field does not exist, or it's not assignable.","title":"func (Document) SetValue"},{"location":"reference/rel/#func-document-table","text":"func ( d Document ) Table () string Table returns name of the table.","title":"func (Document) Table"},{"location":"reference/rel/#func-document-type","text":"func ( d Document ) Type ( field string ) ( reflect . Type , bool ) Type returns reflect.Type of given field. if field does not exist, second returns value will be false.","title":"func (Document) Type"},{"location":"reference/rel/#func-document-value","text":"func ( d Document ) Value ( field string ) ( interface {}, bool ) Value returns value of given field. if field does not exist, second returns value will be false.","title":"func (Document) Value"},{"location":"reference/rel/#type-documentflag","text":"type DocumentFlag int8 DocumentFlag stores information about document as a flag. const ( // Invalid flag. Invalid DocumentFlag = 1 << iota // HasCreatedAt flag. HasCreatedAt // HasUpdatedAt flag. HasUpdatedAt // HasDeletedAt flag. HasDeletedAt )","title":"type DocumentFlag"},{"location":"reference/rel/#func-documentflag-is","text":"func ( df DocumentFlag ) Is ( flag DocumentFlag ) bool Is returns true if it's defined.","title":"func (DocumentFlag) Is"},{"location":"reference/rel/#type-errorfunc","text":"type ErrorFunc func ( error ) error ErrorFunc allows conversion REL's error to Application custom errors.","title":"type ErrorFunc"},{"location":"reference/rel/#func-errorfunc-apply","text":"func ( ef ErrorFunc ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (ErrorFunc) Apply"},{"location":"reference/rel/#type-filterop","text":"type FilterOp int FilterOp defines enumeration of all supported filter types. const ( // FilterAndOp is filter type for and operator. FilterAndOp FilterOp = iota // FilterOrOp is filter type for or operator. FilterOrOp // FilterNotOp is filter type for not operator. FilterNotOp // FilterEqOp is filter type for equal comparison. FilterEqOp // FilterNeOp is filter type for not equal comparison. FilterNeOp // FilterLtOp is filter type for less than comparison. FilterLtOp // FilterLteOp is filter type for less than or equal comparison. FilterLteOp // FilterGtOp is filter type for greater than comparison. FilterGtOp // FilterGteOp is filter type for greter than or equal comparison. FilterGteOp // FilterNilOp is filter type for nil check. FilterNilOp // FilterNotNilOp is filter type for not nil check. FilterNotNilOp // FilterInOp is filter type for inclusion comparison. FilterInOp // FilterNinOp is filter type for not inclusion comparison. FilterNinOp // FilterLikeOp is filter type for like comparison. FilterLikeOp // FilterNotLikeOp is filter type for not like comparison. FilterNotLikeOp // FilterFragmentOp is filter type for custom filter. FilterFragmentOp )","title":"type FilterOp"},{"location":"reference/rel/#type-filterquery","text":"type FilterQuery struct { Type FilterOp Field string Value interface {} Inner [] FilterQuery } FilterQuery defines details of a coundition type.","title":"type FilterQuery"},{"location":"reference/rel/#func-and","text":"func And ( inner ... FilterQuery ) FilterQuery And compares other filters using and.","title":"func And"},{"location":"reference/rel/#func-eq","text":"func Eq ( field string , value interface {}) FilterQuery Eq expression field equal to value.","title":"func Eq"},{"location":"reference/rel/#func-filterfragment","text":"func FilterFragment ( expr string , values ... interface {}) FilterQuery FilterFragment add custom filter.","title":"func FilterFragment"},{"location":"reference/rel/#func-gt","text":"func Gt ( field string , value interface {}) FilterQuery Gt compares that left value is greater than to right value.","title":"func Gt"},{"location":"reference/rel/#func-gte","text":"func Gte ( field string , value interface {}) FilterQuery Gte compares that left value is greater than or equal to right value.","title":"func Gte"},{"location":"reference/rel/#func-in","text":"func In ( field string , values ... interface {}) FilterQuery In check whethers value of the field is included in values.","title":"func In"},{"location":"reference/rel/#func-inint","text":"func InInt ( field string , values [] int ) FilterQuery InInt check whethers integer values of the field is included.","title":"func InInt"},{"location":"reference/rel/#func-instring","text":"func InString ( field string , values [] string ) FilterQuery InString check whethers string values of the field is included.","title":"func InString"},{"location":"reference/rel/#func-inuint","text":"func InUint ( field string , values [] uint ) FilterQuery InUint check whethers unsigned integer values of the field is included.","title":"func InUint"},{"location":"reference/rel/#func-like","text":"func Like ( field string , pattern string ) FilterQuery Like compares value of field to match string pattern.","title":"func Like"},{"location":"reference/rel/#func-lt","text":"func Lt ( field string , value interface {}) FilterQuery Lt compares that left value is less than to right value.","title":"func Lt"},{"location":"reference/rel/#func-lte","text":"func Lte ( field string , value interface {}) FilterQuery Lte compares that left value is less than or equal to right value.","title":"func Lte"},{"location":"reference/rel/#func-ne","text":"func Ne ( field string , value interface {}) FilterQuery Ne compares that left value is not equal to right value.","title":"func Ne"},{"location":"reference/rel/#func-nil","text":"func Nil ( field string ) FilterQuery Nil check whether field is nil.","title":"func Nil"},{"location":"reference/rel/#func-nin","text":"func Nin ( field string , values ... interface {}) FilterQuery Nin check whethers value of the field is not included in values.","title":"func Nin"},{"location":"reference/rel/#func-ninint","text":"func NinInt ( field string , values [] int ) FilterQuery NinInt check whethers integer values of the is not included.","title":"func NinInt"},{"location":"reference/rel/#func-ninstring","text":"func NinString ( field string , values [] string ) FilterQuery NinString check whethers string values of the is not included.","title":"func NinString"},{"location":"reference/rel/#func-ninuint","text":"func NinUint ( field string , values [] uint ) FilterQuery NinUint check whethers unsigned integer values of the is not included.","title":"func NinUint"},{"location":"reference/rel/#func-not","text":"func Not ( inner ... FilterQuery ) FilterQuery Not wraps filters using not. It'll negate the filter type if possible.","title":"func Not"},{"location":"reference/rel/#func-notlike","text":"func NotLike ( field string , pattern string ) FilterQuery NotLike compares value of field to not match string pattern.","title":"func NotLike"},{"location":"reference/rel/#func-notnil","text":"func NotNil ( field string ) FilterQuery NotNil check whether field is not nil.","title":"func NotNil"},{"location":"reference/rel/#func-or","text":"func Or ( inner ... FilterQuery ) FilterQuery Or compares other filters using and.","title":"func Or"},{"location":"reference/rel/#func-filterquery-and","text":"func ( fq FilterQuery ) And ( filters ... FilterQuery ) FilterQuery And wraps filters using and.","title":"func (FilterQuery) And"},{"location":"reference/rel/#func-filterquery-andeq","text":"func ( fq FilterQuery ) AndEq ( field string , value interface {}) FilterQuery AndEq append equal expression using and.","title":"func (FilterQuery) AndEq"},{"location":"reference/rel/#func-filterquery-andfragment","text":"func ( fq FilterQuery ) AndFragment ( expr string , values ... interface {}) FilterQuery AndFragment append fragment using and.","title":"func (FilterQuery) AndFragment"},{"location":"reference/rel/#func-filterquery-andgt","text":"func ( fq FilterQuery ) AndGt ( field string , value interface {}) FilterQuery AndGt append greater than expression using and.","title":"func (FilterQuery) AndGt"},{"location":"reference/rel/#func-filterquery-andgte","text":"func ( fq FilterQuery ) AndGte ( field string , value interface {}) FilterQuery AndGte append greater than or equal expression using and.","title":"func (FilterQuery) AndGte"},{"location":"reference/rel/#func-filterquery-andin","text":"func ( fq FilterQuery ) AndIn ( field string , values ... interface {}) FilterQuery AndIn append is in expression using and.","title":"func (FilterQuery) AndIn"},{"location":"reference/rel/#func-filterquery-andlike","text":"func ( fq FilterQuery ) AndLike ( field string , pattern string ) FilterQuery AndLike append like expression using and.","title":"func (FilterQuery) AndLike"},{"location":"reference/rel/#func-filterquery-andlt","text":"func ( fq FilterQuery ) AndLt ( field string , value interface {}) FilterQuery AndLt append lesser than expression using and.","title":"func (FilterQuery) AndLt"},{"location":"reference/rel/#func-filterquery-andlte","text":"func ( fq FilterQuery ) AndLte ( field string , value interface {}) FilterQuery AndLte append lesser than or equal expression using and.","title":"func (FilterQuery) AndLte"},{"location":"reference/rel/#func-filterquery-andne","text":"func ( fq FilterQuery ) AndNe ( field string , value interface {}) FilterQuery AndNe append not equal expression using and.","title":"func (FilterQuery) AndNe"},{"location":"reference/rel/#func-filterquery-andnil","text":"func ( fq FilterQuery ) AndNil ( field string ) FilterQuery AndNil append is nil expression using and.","title":"func (FilterQuery) AndNil"},{"location":"reference/rel/#func-filterquery-andnin","text":"func ( fq FilterQuery ) AndNin ( field string , values ... interface {}) FilterQuery AndNin append is not in expression using and.","title":"func (FilterQuery) AndNin"},{"location":"reference/rel/#func-filterquery-andnotlike","text":"func ( fq FilterQuery ) AndNotLike ( field string , pattern string ) FilterQuery AndNotLike append not like expression using and.","title":"func (FilterQuery) AndNotLike"},{"location":"reference/rel/#func-filterquery-andnotnil","text":"func ( fq FilterQuery ) AndNotNil ( field string ) FilterQuery AndNotNil append is not nil expression using and.","title":"func (FilterQuery) AndNotNil"},{"location":"reference/rel/#func-filterquery-build","text":"func ( fq FilterQuery ) Build ( query * Query ) Build Filter query.","title":"func (FilterQuery) Build"},{"location":"reference/rel/#func-filterquery-none","text":"func ( fq FilterQuery ) None () bool None returns true if no filter is specified.","title":"func (FilterQuery) None"},{"location":"reference/rel/#func-filterquery-or","text":"func ( fq FilterQuery ) Or ( filter ... FilterQuery ) FilterQuery Or wraps filters using or.","title":"func (FilterQuery) Or"},{"location":"reference/rel/#func-filterquery-oreq","text":"func ( fq FilterQuery ) OrEq ( field string , value interface {}) FilterQuery OrEq append equal expression using or.","title":"func (FilterQuery) OrEq"},{"location":"reference/rel/#func-filterquery-orfragment","text":"func ( fq FilterQuery ) OrFragment ( expr string , values ... interface {}) FilterQuery OrFragment append fragment using or.","title":"func (FilterQuery) OrFragment"},{"location":"reference/rel/#func-filterquery-orgt","text":"func ( fq FilterQuery ) OrGt ( field string , value interface {}) FilterQuery OrGt append greater than expression using or.","title":"func (FilterQuery) OrGt"},{"location":"reference/rel/#func-filterquery-orgte","text":"func ( fq FilterQuery ) OrGte ( field string , value interface {}) FilterQuery OrGte append greater than or equal expression using or.","title":"func (FilterQuery) OrGte"},{"location":"reference/rel/#func-filterquery-orin","text":"func ( fq FilterQuery ) OrIn ( field string , values ... interface {}) FilterQuery OrIn append is in expression using or.","title":"func (FilterQuery) OrIn"},{"location":"reference/rel/#func-filterquery-orlike","text":"func ( fq FilterQuery ) OrLike ( field string , pattern string ) FilterQuery OrLike append like expression using or.","title":"func (FilterQuery) OrLike"},{"location":"reference/rel/#func-filterquery-orlt","text":"func ( fq FilterQuery ) OrLt ( field string , value interface {}) FilterQuery OrLt append lesser than expression using or.","title":"func (FilterQuery) OrLt"},{"location":"reference/rel/#func-filterquery-orlte","text":"func ( fq FilterQuery ) OrLte ( field string , value interface {}) FilterQuery OrLte append lesser than or equal expression using or.","title":"func (FilterQuery) OrLte"},{"location":"reference/rel/#func-filterquery-orne","text":"func ( fq FilterQuery ) OrNe ( field string , value interface {}) FilterQuery OrNe append not equal expression using or.","title":"func (FilterQuery) OrNe"},{"location":"reference/rel/#func-filterquery-ornil","text":"func ( fq FilterQuery ) OrNil ( field string ) FilterQuery OrNil append is nil expression using or.","title":"func (FilterQuery) OrNil"},{"location":"reference/rel/#func-filterquery-ornin","text":"func ( fq FilterQuery ) OrNin ( field string , values ... interface {}) FilterQuery OrNin append is not in expression using or.","title":"func (FilterQuery) OrNin"},{"location":"reference/rel/#func-filterquery-ornotlike","text":"func ( fq FilterQuery ) OrNotLike ( field string , pattern string ) FilterQuery OrNotLike append not like expression using or.","title":"func (FilterQuery) OrNotLike"},{"location":"reference/rel/#func-filterquery-ornotnil","text":"func ( fq FilterQuery ) OrNotNil ( field string ) FilterQuery OrNotNil append is not nil expression using or.","title":"func (FilterQuery) OrNotNil"},{"location":"reference/rel/#type-foreignkeyreference","text":"type ForeignKeyReference struct { Table string Columns [] string OnDelete string OnUpdate string } ForeignKeyReference definition.","title":"type ForeignKeyReference"},{"location":"reference/rel/#type-groupquery","text":"type GroupQuery struct { Fields [] string Filter FilterQuery } GroupQuery defines group clause of the query.","title":"type GroupQuery"},{"location":"reference/rel/#func-newgroup","text":"func NewGroup ( fields ... string ) GroupQuery NewGroup query.","title":"func NewGroup"},{"location":"reference/rel/#func-groupquery-build","text":"func ( gq GroupQuery ) Build ( query * Query ) Build query.","title":"func (GroupQuery) Build"},{"location":"reference/rel/#func-groupquery-having","text":"func ( gq GroupQuery ) Having ( filters ... FilterQuery ) GroupQuery Having appends filter for group query with and operand.","title":"func (GroupQuery) Having"},{"location":"reference/rel/#func-groupquery-orhaving","text":"func ( gq GroupQuery ) OrHaving ( filters ... FilterQuery ) GroupQuery OrHaving appends filter for group query with or operand.","title":"func (GroupQuery) OrHaving"},{"location":"reference/rel/#func-groupquery-orwhere","text":"func ( gq GroupQuery ) OrWhere ( filters ... FilterQuery ) GroupQuery OrWhere is alias for OrHaving.","title":"func (GroupQuery) OrWhere"},{"location":"reference/rel/#func-groupquery-where","text":"func ( gq GroupQuery ) Where ( filters ... FilterQuery ) GroupQuery Where is alias for having.","title":"func (GroupQuery) Where"},{"location":"reference/rel/#type-index","text":"type Index struct { Op SchemaOp Table string Name string Unique bool Columns [] string Optional bool Options string } Index definition.","title":"type Index"},{"location":"reference/rel/#type-indexoption","text":"type IndexOption interface { // contains filtered or unexported methods } IndexOption interface. Available options are: Comment, Options.","title":"type IndexOption"},{"location":"reference/rel/#type-instrumenter","text":"type Instrumenter func ( ctx context . Context , op string , message string ) func ( err error ) Instrumenter defines function type that can be used for instrumetation. This function should return a function with no argument as a callback for finished execution.","title":"type Instrumenter"},{"location":"reference/rel/#type-iterator","text":"type Iterator interface { io . Closer Next ( record interface {}) error } Iterator alllows iterating through all record in database in batch.","title":"type Iterator"},{"location":"reference/rel/#type-iteratoroption","text":"type IteratorOption interface { // contains filtered or unexported methods } IteratorOption is used to configure iteration behaviour, such as batch size, start id and finish id.","title":"type IteratorOption"},{"location":"reference/rel/#func-batchsize","text":"func BatchSize ( size int ) IteratorOption BatchSize specifies the size of iterator batch. Defaults to 1000.","title":"func BatchSize"},{"location":"reference/rel/#func-finish","text":"func Finish ( id ... interface {}) IteratorOption Finish specfies the primary value to finish at (inclusive).","title":"func Finish"},{"location":"reference/rel/#func-start","text":"func Start ( id ... interface {}) IteratorOption Start specfies the primary value to start from (inclusive).","title":"func Start"},{"location":"reference/rel/#type-joinquery","text":"type JoinQuery struct { Mode string Table string From string To string Arguments [] interface {} } JoinQuery defines join clause in query.","title":"type JoinQuery"},{"location":"reference/rel/#func-newfulljoin","text":"func NewFullJoin ( table string ) JoinQuery NewFullJoin with given table.","title":"func NewFullJoin"},{"location":"reference/rel/#func-newfulljoinon","text":"func NewFullJoinOn ( table string , from string , to string ) JoinQuery NewFullJoinOn table with given field.","title":"func NewFullJoinOn"},{"location":"reference/rel/#func-newinnerjoin","text":"func NewInnerJoin ( table string ) JoinQuery NewInnerJoin with given table.","title":"func NewInnerJoin"},{"location":"reference/rel/#func-newinnerjoinon","text":"func NewInnerJoinOn ( table string , from string , to string ) JoinQuery NewInnerJoinOn table with given field.","title":"func NewInnerJoinOn"},{"location":"reference/rel/#func-newjoin","text":"func NewJoin ( table string ) JoinQuery NewJoin with given table.","title":"func NewJoin"},{"location":"reference/rel/#func-newjoinfragment","text":"func NewJoinFragment ( expr string , args ... interface {}) JoinQuery NewJoinFragment defines a join clause using raw query.","title":"func NewJoinFragment"},{"location":"reference/rel/#func-newjoinon","text":"func NewJoinOn ( table string , from string , to string ) JoinQuery NewJoinOn table with given field.","title":"func NewJoinOn"},{"location":"reference/rel/#func-newjoinwith","text":"func NewJoinWith ( mode string , table string , from string , to string ) JoinQuery NewJoinWith query with custom join mode, table and field.","title":"func NewJoinWith"},{"location":"reference/rel/#func-newleftjoin","text":"func NewLeftJoin ( table string ) JoinQuery NewLeftJoin with given table.","title":"func NewLeftJoin"},{"location":"reference/rel/#func-newleftjoinon","text":"func NewLeftJoinOn ( table string , from string , to string ) JoinQuery NewLeftJoinOn table with given field.","title":"func NewLeftJoinOn"},{"location":"reference/rel/#func-newrightjoin","text":"func NewRightJoin ( table string ) JoinQuery NewRightJoin with given table.","title":"func NewRightJoin"},{"location":"reference/rel/#func-newrightjoinon","text":"func NewRightJoinOn ( table string , from string , to string ) JoinQuery NewRightJoinOn table with given field.","title":"func NewRightJoinOn"},{"location":"reference/rel/#func-joinquery-build","text":"func ( jq JoinQuery ) Build ( query * Query ) Build query.","title":"func (JoinQuery) Build"},{"location":"reference/rel/#type-key","text":"type Key struct { Op SchemaOp Name string Type KeyType Columns [] string Rename string Reference ForeignKeyReference Options string } Key definition.","title":"type Key"},{"location":"reference/rel/#type-keyoption","text":"type KeyOption interface { // contains filtered or unexported methods } KeyOption interface. Available options are: Comment, Options.","title":"type KeyOption"},{"location":"reference/rel/#type-keytype","text":"type KeyType string KeyType definition. const ( // PrimaryKey KeyType. PrimaryKey KeyType = \"PRIMARY KEY\" // ForeignKey KeyType. ForeignKey KeyType = \"FOREIGN KEY\" // UniqueKey KeyType. UniqueKey = \"UNIQUE\" )","title":"type KeyType"},{"location":"reference/rel/#type-limit","text":"type Limit int Limit options. When passed as query, it limits returned result from database. When passed as column option, it sets the maximum size of the string/text/binary/integer columns.","title":"type Limit"},{"location":"reference/rel/#func-limit-build","text":"func ( l Limit ) Build ( query * Query ) Build query.","title":"func (Limit) Build"},{"location":"reference/rel/#type-lock","text":"type Lock string Lock query. This query will be ignored if used outside of transaction.","title":"type Lock"},{"location":"reference/rel/#func-forupdate","text":"func ForUpdate () Lock ForUpdate lock query.","title":"func ForUpdate"},{"location":"reference/rel/#func-lock-build","text":"func ( l Lock ) Build ( query * Query ) Build query.","title":"func (Lock) Build"},{"location":"reference/rel/#type-map","text":"type Map map [ string ] interface {} Map can be used as mutation for repository insert or update operation. This allows inserting or updating only on specified field. Insert/Update of has one or belongs to can be done using other Map as a value. Insert/Update of has many can be done using slice of Map as a value. Map is intended to be used internally within application, and not to be exposed directly as an APIs.","title":"type Map"},{"location":"reference/rel/#func-map-apply","text":"func ( m Map ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Map) Apply"},{"location":"reference/rel/#type-migration","text":"type Migration interface { // contains filtered or unexported methods } Migration definition.","title":"type Migration"},{"location":"reference/rel/#type-mutate","text":"type Mutate struct { Type ChangeOp Field string Value interface {} } Mutate stores mutation instruction.","title":"type Mutate"},{"location":"reference/rel/#func-dec","text":"func Dec ( field string ) Mutate Dec create a mutate using deccrement operation.","title":"func Dec"},{"location":"reference/rel/#func-decby","text":"func DecBy ( field string , n int ) Mutate DecBy create a mutate using decrement operation with custom decrement value.","title":"func DecBy"},{"location":"reference/rel/#func-inc","text":"func Inc ( field string ) Mutate Inc create a mutate using increment operation.","title":"func Inc"},{"location":"reference/rel/#func-incby","text":"func IncBy ( field string , n int ) Mutate IncBy create a mutate using increment operation with custom increment value.","title":"func IncBy"},{"location":"reference/rel/#func-set","text":"func Set ( field string , value interface {}) Mutate Set create a mutate using set operation.","title":"func Set"},{"location":"reference/rel/#func-setfragment","text":"func SetFragment ( raw string , args ... interface {}) Mutate SetFragment create a mutate operation using randoc fragment operation. Only available for Update.","title":"func SetFragment"},{"location":"reference/rel/#func-mutate-apply","text":"func ( m Mutate ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Mutate) Apply"},{"location":"reference/rel/#type-mutation","text":"type Mutation struct { Mutates map [ string ] Mutate Assoc map [ string ] AssocMutation Unscoped Unscoped Reload Reload Cascade Cascade ErrorFunc ErrorFunc } Mutation represents value to be inserted or updated to database. It's not safe to be used multiple time. some operation my alter mutation data.","title":"type Mutation"},{"location":"reference/rel/#func-apply","text":"func Apply ( doc * Document , mutators ... Mutator ) Mutation Apply using given mutators.","title":"func Apply"},{"location":"reference/rel/#func-mutation-add","text":"func ( m * Mutation ) Add ( mut Mutate ) Add a mutate.","title":"func (*Mutation) Add"},{"location":"reference/rel/#func-mutation-isassocempty","text":"func ( m * Mutation ) IsAssocEmpty () bool IsAssocEmpty returns true if no assoc's mutation is defined.","title":"func (*Mutation) IsAssocEmpty"},{"location":"reference/rel/#func-mutation-isempty","text":"func ( m * Mutation ) IsEmpty () bool IsEmpty returns true if no mutates operation and assoc's mutation is defined.","title":"func (*Mutation) IsEmpty"},{"location":"reference/rel/#func-mutation-ismutatesempty","text":"func ( m * Mutation ) IsMutatesEmpty () bool IsMutatesEmpty returns true if no mutates operation is defined.","title":"func (*Mutation) IsMutatesEmpty"},{"location":"reference/rel/#func-mutation-setassoc","text":"func ( m * Mutation ) SetAssoc ( field string , muts ... Mutation ) SetAssoc mutation.","title":"func (*Mutation) SetAssoc"},{"location":"reference/rel/#func-mutation-setdeletedids","text":"func ( m * Mutation ) SetDeletedIDs ( field string , ids [] interface {}) SetDeletedIDs mutation. nil slice will clear association.","title":"func (*Mutation) SetDeletedIDs"},{"location":"reference/rel/#type-mutator","text":"type Mutator interface { Apply ( doc * Document , mutation * Mutation ) } Mutator is interface for a record mutator.","title":"type Mutator"},{"location":"reference/rel/#type-name","text":"type Name string Name option for defining custom index name.","title":"type Name"},{"location":"reference/rel/#type-notfounderror","text":"type NotFoundError struct {} NotFoundError returned whenever Find returns no result.","title":"type NotFoundError"},{"location":"reference/rel/#func-notfounderror-error","text":"func ( nfe NotFoundError ) Error () string Error message.","title":"func (NotFoundError) Error"},{"location":"reference/rel/#type-offset","text":"type Offset int Offset Query.","title":"type Offset"},{"location":"reference/rel/#func-offset-build","text":"func ( o Offset ) Build ( query * Query ) Build query.","title":"func (Offset) Build"},{"location":"reference/rel/#type-ondelete","text":"type OnDelete string OnDelete option for foreign key.","title":"type OnDelete"},{"location":"reference/rel/#type-onupdate","text":"type OnUpdate string OnUpdate option for foreign key.","title":"type OnUpdate"},{"location":"reference/rel/#type-optional","text":"type Optional bool Optional option. when used with create table, will create table only if it's not exists. when used with drop table, will drop table only if it's exists.","title":"type Optional"},{"location":"reference/rel/#type-options","text":"type Options string Options options for table, column and index.","title":"type Options"},{"location":"reference/rel/#type-precision","text":"type Precision int Precision defines the precision for the decimal fields, representing the total number of digits in the number.","title":"type Precision"},{"location":"reference/rel/#type-querier","text":"type Querier interface { Build ( * Query ) } Querier interface defines contract to be used for query builder.","title":"type Querier"},{"location":"reference/rel/#type-query","text":"type Query struct { Table string SelectQuery SelectQuery JoinQuery [] JoinQuery WhereQuery FilterQuery GroupQuery GroupQuery SortQuery [] SortQuery OffsetQuery Offset LimitQuery Limit LockQuery Lock UnscopedQuery Unscoped ReloadQuery Reload SQLQuery SQLQuery // contains filtered or unexported fields } Query defines information about query generated by query builder.","title":"type Query"},{"location":"reference/rel/#func-build","text":"func Build ( table string , queriers ... Querier ) Query Build for given table using given queriers.","title":"func Build"},{"location":"reference/rel/#func-from","text":"func From ( table string ) Query From create a query with chainable syntax, using from as the starting point.","title":"func From"},{"location":"reference/rel/#func-join","text":"func Join ( table string ) Query Join create a query with chainable syntax, using join as the starting point.","title":"func Join"},{"location":"reference/rel/#func-joinon","text":"func JoinOn ( table string , from string , to string ) Query JoinOn create a query with chainable syntax, using join as the starting point.","title":"func JoinOn"},{"location":"reference/rel/#func-joinwith","text":"func JoinWith ( mode string , table string , from string , to string ) Query JoinWith create a query with chainable syntax, using join as the starting point.","title":"func JoinWith"},{"location":"reference/rel/#func-joinf","text":"func Joinf ( expr string , args ... interface {}) Query Joinf create a query with chainable syntax, using join as the starting point.","title":"func Joinf"},{"location":"reference/rel/#func-select","text":"func Select ( fields ... string ) Query Select query create a query with chainable syntax, using select as the starting point.","title":"func Select"},{"location":"reference/rel/#func-where","text":"func Where ( filters ... FilterQuery ) Query Where create a query with chainable syntax, using where as the starting point.","title":"func Where"},{"location":"reference/rel/#func-query-build","text":"func ( q Query ) Build ( query * Query ) Build query.","title":"func (Query) Build"},{"location":"reference/rel/#func-query-distinct","text":"func ( q Query ) Distinct () Query Distinct sets select query to be distinct.","title":"func (Query) Distinct"},{"location":"reference/rel/#func-query-from","text":"func ( q Query ) From ( table string ) Query From set the table to be used for query.","title":"func (Query) From"},{"location":"reference/rel/#func-query-group","text":"func ( q Query ) Group ( fields ... string ) Query Group query.","title":"func (Query) Group"},{"location":"reference/rel/#func-query-having","text":"func ( q Query ) Having ( filters ... FilterQuery ) Query Having query.","title":"func (Query) Having"},{"location":"reference/rel/#func-query-havingf","text":"func ( q Query ) Havingf ( expr string , args ... interface {}) Query Havingf create having query using a raw query.","title":"func (Query) Havingf"},{"location":"reference/rel/#func-query-join","text":"func ( q Query ) Join ( table string ) Query Join current table with other table.","title":"func (Query) Join"},{"location":"reference/rel/#func-query-joinon","text":"func ( q Query ) JoinOn ( table string , from string , to string ) Query JoinOn current table with other table.","title":"func (Query) JoinOn"},{"location":"reference/rel/#func-query-joinwith","text":"func ( q Query ) JoinWith ( mode string , table string , from string , to string ) Query JoinWith current table with other table with custom join mode.","title":"func (Query) JoinWith"},{"location":"reference/rel/#func-query-joinf","text":"func ( q Query ) Joinf ( expr string , args ... interface {}) Query Joinf create join query using a raw query.","title":"func (Query) Joinf"},{"location":"reference/rel/#func-query-limit","text":"func ( q Query ) Limit ( limit int ) Query Limit result returned by database.","title":"func (Query) Limit"},{"location":"reference/rel/#func-query-lock","text":"func ( q Query ) Lock ( lock string ) Query Lock query expression.","title":"func (Query) Lock"},{"location":"reference/rel/#func-query-offset","text":"func ( q Query ) Offset ( offset int ) Query Offset the result returned by database.","title":"func (Query) Offset"},{"location":"reference/rel/#func-query-orhaving","text":"func ( q Query ) OrHaving ( filters ... FilterQuery ) Query OrHaving query.","title":"func (Query) OrHaving"},{"location":"reference/rel/#func-query-orhavingf","text":"func ( q Query ) OrHavingf ( expr string , args ... interface {}) Query OrHavingf create having query using a raw query.","title":"func (Query) OrHavingf"},{"location":"reference/rel/#func-query-orwhere","text":"func ( q Query ) OrWhere ( filters ... FilterQuery ) Query OrWhere query.","title":"func (Query) OrWhere"},{"location":"reference/rel/#func-query-orwheref","text":"func ( q Query ) OrWheref ( expr string , args ... interface {}) Query OrWheref create where query using a raw query.","title":"func (Query) OrWheref"},{"location":"reference/rel/#func-query-reload","text":"func ( q Query ) Reload () Query Reload force reloading association on preload.","title":"func (Query) Reload"},{"location":"reference/rel/#func-query-select","text":"func ( q Query ) Select ( fields ... string ) Query Select filter fields to be selected from database.","title":"func (Query) Select"},{"location":"reference/rel/#func-query-sort","text":"func ( q Query ) Sort ( fields ... string ) Query Sort query.","title":"func (Query) Sort"},{"location":"reference/rel/#func-query-sortasc","text":"func ( q Query ) SortAsc ( fields ... string ) Query SortAsc query.","title":"func (Query) SortAsc"},{"location":"reference/rel/#func-query-sortdesc","text":"func ( q Query ) SortDesc ( fields ... string ) Query SortDesc query.","title":"func (Query) SortDesc"},{"location":"reference/rel/#func-query-unscoped","text":"func ( q Query ) Unscoped () Query Unscoped allows soft-delete to be ignored.","title":"func (Query) Unscoped"},{"location":"reference/rel/#func-query-where","text":"func ( q Query ) Where ( filters ... FilterQuery ) Query Where query.","title":"func (Query) Where"},{"location":"reference/rel/#func-query-wheref","text":"func ( q Query ) Wheref ( expr string , args ... interface {}) Query Wheref create where query using a raw query.","title":"func (Query) Wheref"},{"location":"reference/rel/#type-raw","text":"type Raw string Raw string","title":"type Raw"},{"location":"reference/rel/#type-reload","text":"type Reload bool Reload force reload after insert/update. Default to false.","title":"type Reload"},{"location":"reference/rel/#func-reload-apply","text":"func ( r Reload ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Reload) Apply"},{"location":"reference/rel/#func-reload-build","text":"func ( r Reload ) Build ( query * Query ) Build query.","title":"func (Reload) Build"},{"location":"reference/rel/#type-repository","text":"type Repository interface { Adapter ( ctx context . Context ) Adapter Instrumentation ( instrumenter Instrumenter ) Ping ( ctx context . Context ) error Iterate ( ctx context . Context , query Query , option ... IteratorOption ) Iterator Aggregate ( ctx context . Context , query Query , aggregate string , field string ) ( int , error ) MustAggregate ( ctx context . Context , query Query , aggregate string , field string ) int Count ( ctx context . Context , collection string , queriers ... Querier ) ( int , error ) MustCount ( ctx context . Context , collection string , queriers ... Querier ) int Find ( ctx context . Context , record interface {}, queriers ... Querier ) error MustFind ( ctx context . Context , record interface {}, queriers ... Querier ) FindAll ( ctx context . Context , records interface {}, queriers ... Querier ) error MustFindAll ( ctx context . Context , records interface {}, queriers ... Querier ) FindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) ( int , error ) MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) int Insert ( ctx context . Context , record interface {}, mutators ... Mutator ) error MustInsert ( ctx context . Context , record interface {}, mutators ... Mutator ) InsertAll ( ctx context . Context , records interface {}) error MustInsertAll ( ctx context . Context , records interface {}) Update ( ctx context . Context , record interface {}, mutators ... Mutator ) error MustUpdate ( ctx context . Context , record interface {}, mutators ... Mutator ) UpdateAll ( ctx context . Context , query Query , mutates ... Mutate ) error MustUpdateAll ( ctx context . Context , query Query , mutates ... Mutate ) Delete ( ctx context . Context , record interface {}, options ... Cascade ) error MustDelete ( ctx context . Context , record interface {}, options ... Cascade ) DeleteAll ( ctx context . Context , query Query ) error MustDeleteAll ( ctx context . Context , query Query ) Preload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) error MustPreload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error } Repository defines sets of available database operations.","title":"type Repository"},{"location":"reference/rel/#func-new","text":"func New ( adapter Adapter ) Repository New create new repo using adapter.","title":"func New"},{"location":"reference/rel/#type-required","text":"type Required bool Required disallows nil values in the column.","title":"type Required"},{"location":"reference/rel/#type-sqlquery","text":"type SQLQuery struct { Statement string Values [] interface {} } SQLQuery allows querying using native query supported by database.","title":"type SQLQuery"},{"location":"reference/rel/#func-sql","text":"func SQL ( statement string , values ... interface {}) SQLQuery SQL Query.","title":"func SQL"},{"location":"reference/rel/#func-sqlquery-build","text":"func ( sq SQLQuery ) Build ( query * Query ) Build Raw Query.","title":"func (SQLQuery) Build"},{"location":"reference/rel/#type-scale","text":"type Scale int Scale Defines the scale for the decimal fields, representing the number of digits after the decimal point.","title":"type Scale"},{"location":"reference/rel/#type-schema","text":"type Schema struct { Migrations [] Migration } Schema builder.","title":"type Schema"},{"location":"reference/rel/#func-schema-addcolumn","text":"func ( s * Schema ) AddColumn ( table string , name string , typ ColumnType , options ... ColumnOption ) AddColumn with name and type.","title":"func (*Schema) AddColumn"},{"location":"reference/rel/#func-schema-altertable","text":"func ( s * Schema ) AlterTable ( name string , fn func ( t * AlterTable ), options ... TableOption ) AlterTable with name and its definition.","title":"func (*Schema) AlterTable"},{"location":"reference/rel/#func-schema-createindex","text":"func ( s * Schema ) CreateIndex ( table string , name string , column [] string , options ... IndexOption ) CreateIndex for columns on a table.","title":"func (*Schema) CreateIndex"},{"location":"reference/rel/#func-schema-createtable","text":"func ( s * Schema ) CreateTable ( name string , fn func ( t * Table ), options ... TableOption ) CreateTable with name and its definition.","title":"func (*Schema) CreateTable"},{"location":"reference/rel/#func-schema-createtableifnotexists","text":"func ( s * Schema ) CreateTableIfNotExists ( name string , fn func ( t * Table ), options ... TableOption ) CreateTableIfNotExists with name and its definition.","title":"func (*Schema) CreateTableIfNotExists"},{"location":"reference/rel/#func-schema-createuniqueindex","text":"func ( s * Schema ) CreateUniqueIndex ( table string , name string , column [] string , options ... IndexOption ) CreateUniqueIndex for columns on a table.","title":"func (*Schema) CreateUniqueIndex"},{"location":"reference/rel/#func-schema-do","text":"func ( s * Schema ) Do ( fn Do ) Do migration using golang codes.","title":"func (*Schema) Do"},{"location":"reference/rel/#func-schema-dropcolumn","text":"func ( s * Schema ) DropColumn ( table string , name string , options ... ColumnOption ) DropColumn by name.","title":"func (*Schema) DropColumn"},{"location":"reference/rel/#func-schema-dropindex","text":"func ( s * Schema ) DropIndex ( table string , name string , options ... IndexOption ) DropIndex by name.","title":"func (*Schema) DropIndex"},{"location":"reference/rel/#func-schema-droptable","text":"func ( s * Schema ) DropTable ( name string , options ... TableOption ) DropTable by name.","title":"func (*Schema) DropTable"},{"location":"reference/rel/#func-schema-droptableifexists","text":"func ( s * Schema ) DropTableIfExists ( name string , options ... TableOption ) DropTableIfExists by name.","title":"func (*Schema) DropTableIfExists"},{"location":"reference/rel/#func-schema-exec","text":"func ( s * Schema ) Exec ( raw Raw ) Exec queries.","title":"func (*Schema) Exec"},{"location":"reference/rel/#func-schema-renamecolumn","text":"func ( s * Schema ) RenameColumn ( table string , name string , newName string , options ... ColumnOption ) RenameColumn by name.","title":"func (*Schema) RenameColumn"},{"location":"reference/rel/#func-schema-renametable","text":"func ( s * Schema ) RenameTable ( name string , newName string , options ... TableOption ) RenameTable by name.","title":"func (*Schema) RenameTable"},{"location":"reference/rel/#type-schemaop","text":"type SchemaOp uint8 SchemaOp type. const ( // SchemaCreate operation. SchemaCreate SchemaOp = iota // SchemaAlter operation. SchemaAlter // SchemaRename operation. SchemaRename // SchemaDrop operation. SchemaDrop )","title":"type SchemaOp"},{"location":"reference/rel/#type-selectquery","text":"type SelectQuery struct { OnlyDistinct bool Fields [] string } SelectQuery defines select clause of the query.","title":"type SelectQuery"},{"location":"reference/rel/#func-newselect","text":"func NewSelect ( fields ... string ) SelectQuery NewSelect query.","title":"func NewSelect"},{"location":"reference/rel/#func-selectquery-distinct","text":"func ( sq SelectQuery ) Distinct () SelectQuery Distinct select query.","title":"func (SelectQuery) Distinct"},{"location":"reference/rel/#type-sortquery","text":"type SortQuery struct { Field string Sort int } SortQuery defines sort information of query.","title":"type SortQuery"},{"location":"reference/rel/#func-newsortasc","text":"func NewSortAsc ( field string ) SortQuery NewSortAsc sorts field with ascending sort.","title":"func NewSortAsc"},{"location":"reference/rel/#func-newsortdesc","text":"func NewSortDesc ( field string ) SortQuery NewSortDesc sorts field with descending sort.","title":"func NewSortDesc"},{"location":"reference/rel/#func-sortquery-asc","text":"func ( sq SortQuery ) Asc () bool Asc returns true if sort is ascending.","title":"func (SortQuery) Asc"},{"location":"reference/rel/#func-sortquery-build","text":"func ( sq SortQuery ) Build ( query * Query ) Build sort query.","title":"func (SortQuery) Build"},{"location":"reference/rel/#func-sortquery-desc","text":"func ( sq SortQuery ) Desc () bool Desc returns true if s is descending.","title":"func (SortQuery) Desc"},{"location":"reference/rel/#type-structset","text":"type Structset struct { // contains filtered or unexported fields } Structset can be used as mutation for repository insert or update operation. This will save every field in struct and it's association as long as it's loaded. This is the default mutator used by repository.","title":"type Structset"},{"location":"reference/rel/#func-newstructset","text":"func NewStructset ( record interface {}, skipZero bool ) Structset NewStructset from a struct.","title":"func NewStructset"},{"location":"reference/rel/#func-structset-apply","text":"func ( s Structset ) Apply ( doc * Document , mut * Mutation ) Apply mutation.","title":"func (Structset) Apply"},{"location":"reference/rel/#type-table","text":"type Table struct { Op SchemaOp Name string Rename string Definitions [] TableDefinition Optional bool Options string } Table definition.","title":"type Table"},{"location":"reference/rel/#func-table-bigint","text":"func ( t * Table ) BigInt ( name string , options ... ColumnOption ) BigInt defines a column with name and BigInt type.","title":"func (*Table) BigInt"},{"location":"reference/rel/#func-table-bool","text":"func ( t * Table ) Bool ( name string , options ... ColumnOption ) Bool defines a column with name and Bool type.","title":"func (*Table) Bool"},{"location":"reference/rel/#func-table-column","text":"func ( t * Table ) Column ( name string , typ ColumnType , options ... ColumnOption ) Column defines a column with name and type.","title":"func (*Table) Column"},{"location":"reference/rel/#func-table-date","text":"func ( t * Table ) Date ( name string , options ... ColumnOption ) Date defines a column with name and Date type.","title":"func (*Table) Date"},{"location":"reference/rel/#func-table-datetime","text":"func ( t * Table ) DateTime ( name string , options ... ColumnOption ) DateTime defines a column with name and DateTime type.","title":"func (*Table) DateTime"},{"location":"reference/rel/#func-table-decimal","text":"func ( t * Table ) Decimal ( name string , options ... ColumnOption ) Decimal defines a column with name and Decimal type.","title":"func (*Table) Decimal"},{"location":"reference/rel/#func-table-float","text":"func ( t * Table ) Float ( name string , options ... ColumnOption ) Float defines a column with name and Float type.","title":"func (*Table) Float"},{"location":"reference/rel/#func-table-foreignkey","text":"func ( t * Table ) ForeignKey ( column string , refTable string , refColumn string , options ... KeyOption ) ForeignKey defines foreign key index.","title":"func (*Table) ForeignKey"},{"location":"reference/rel/#func-table-fragment","text":"func ( t * Table ) Fragment ( fragment string ) Fragment defines anything using sql fragment.","title":"func (*Table) Fragment"},{"location":"reference/rel/#func-table-id","text":"func ( t * Table ) ID ( name string , options ... ColumnOption ) ID defines a column with name and ID type. the resulting database type will depends on database.","title":"func (*Table) ID"},{"location":"reference/rel/#func-table-int","text":"func ( t * Table ) Int ( name string , options ... ColumnOption ) Int defines a column with name and Int type.","title":"func (*Table) Int"},{"location":"reference/rel/#func-table-primarykey","text":"func ( t * Table ) PrimaryKey ( column string , options ... KeyOption ) PrimaryKey defines a primary key for table.","title":"func (*Table) PrimaryKey"},{"location":"reference/rel/#func-table-primarykeys","text":"func ( t * Table ) PrimaryKeys ( columns [] string , options ... KeyOption ) PrimaryKeys defines composite primary keys for table.","title":"func (*Table) PrimaryKeys"},{"location":"reference/rel/#func-table-string","text":"func ( t * Table ) String ( name string , options ... ColumnOption ) String defines a column with name and String type.","title":"func (*Table) String"},{"location":"reference/rel/#func-table-text","text":"func ( t * Table ) Text ( name string , options ... ColumnOption ) Text defines a column with name and Text type.","title":"func (*Table) Text"},{"location":"reference/rel/#func-table-time","text":"func ( t * Table ) Time ( name string , options ... ColumnOption ) Time defines a column with name and Time type.","title":"func (*Table) Time"},{"location":"reference/rel/#func-table-timestamp","text":"func ( t * Table ) Timestamp ( name string , options ... ColumnOption ) Timestamp defines a column with name and Timestamp type.","title":"func (*Table) Timestamp"},{"location":"reference/rel/#func-table-unique","text":"func ( t * Table ) Unique ( columns [] string , options ... KeyOption ) Unique defines an unique key for columns.","title":"func (*Table) Unique"},{"location":"reference/rel/#type-tabledefinition","text":"type TableDefinition interface { // contains filtered or unexported methods } TableDefinition interface.","title":"type TableDefinition"},{"location":"reference/rel/#type-tableoption","text":"type TableOption interface { // contains filtered or unexported methods } TableOption interface. Available options are: Comment, Options.","title":"type TableOption"},{"location":"reference/rel/#type-unique","text":"type Unique bool Unique set column as unique.","title":"type Unique"},{"location":"reference/rel/#type-unscoped","text":"type Unscoped bool Unscoped query.","title":"type Unscoped"},{"location":"reference/rel/#func-unscoped-apply","text":"func ( u Unscoped ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Unscoped) Apply"},{"location":"reference/rel/#func-unscoped-build","text":"func ( u Unscoped ) Build ( query * Query ) Build query.","title":"func (Unscoped) Build"},{"location":"reference/rel/#type-unsigned","text":"type Unsigned bool Unsigned sets integer column to be unsigned.","title":"type Unsigned"},{"location":"reference/reltest/","text":"reltest \u00b6 import \"github.com/Fs02/rel/reltest\" Overview \u00b6 Variables \u00b6 var ( // ErrConnectionClosed is alias for sql.ErrConnDone. ErrConnectionClosed = sql . ErrConnDone ) type Aggregate \u00b6 type Aggregate struct { * Expect } Aggregate asserts and simulate aggregate function for test. func ExpectAggregate \u00b6 func ExpectAggregate ( r * Repository , query rel . Query , aggregate string , field string ) * Aggregate ExpectAggregate to be called with given field and queries. func ExpectCount \u00b6 func ExpectCount ( r * Repository , collection string , queriers [] rel . Querier ) * Aggregate ExpectCount to be called with given field and queries. func (*Aggregate) ConnectionClosed \u00b6 func ( a * Aggregate ) ConnectionClosed () ConnectionClosed sets this error to be returned. func (*Aggregate) Error \u00b6 func ( a * Aggregate ) Error ( err error ) Error sets error to be returned. func (*Aggregate) Result \u00b6 func ( a * Aggregate ) Result ( count int ) Result sets the result of this query. type Delete \u00b6 type Delete struct { * Expect } Delete asserts and simulate delete function for test. func ExpectDelete \u00b6 func ExpectDelete ( r * Repository , options [] rel . Cascade ) * Delete ExpectDelete to be called. func (*Delete) For \u00b6 func ( d * Delete ) For ( record interface {}) * Delete For match expect calls for given record. func (*Delete) ForType \u00b6 func ( d * Delete ) ForType ( typ string ) * Delete ForType match expect calls for given type. Type must include package name, example: model.User . type Expect \u00b6 type Expect struct { * mock . Call } Expect is base behaviour for all reltest expectations. func (*Expect) ConnectionClosed \u00b6 func ( e * Expect ) ConnectionClosed () ConnectionClosed sets this error to be returned. func (*Expect) Error \u00b6 func ( e * Expect ) Error ( err error ) Error sets error to be returned. type Find \u00b6 type Find struct { * FindAll } Find asserts and simulate find function for test. func ExpectFind \u00b6 func ExpectFind ( r * Repository , queriers [] rel . Querier ) * Find ExpectFind to be called with given field and queries. func (*Find) NotFound \u00b6 func ( f * Find ) NotFound () NotFound sets NotFoundError to be returned. type FindAll \u00b6 type FindAll struct { * Expect } FindAll asserts and simulate find all function for test. func ExpectFindAll \u00b6 func ExpectFindAll ( r * Repository , queriers [] rel . Querier ) * FindAll ExpectFindAll to be called with given field and queries. func (*FindAll) Result \u00b6 func ( fa * FindAll ) Result ( records interface {}) Result sets the result of this query. type FindAndCountAll \u00b6 type FindAndCountAll struct { * Expect } FindAndCountAll asserts and simulate find all function for test. func ExpectFindAndCountAll \u00b6 func ExpectFindAndCountAll ( r * Repository , queriers [] rel . Querier ) * FindAndCountAll ExpectFindAndCountAll to be called with given field and queries. func (*FindAndCountAll) ConnectionClosed \u00b6 func ( fa * FindAndCountAll ) ConnectionClosed () ConnectionClosed sets this error to be returned. func (*FindAndCountAll) Error \u00b6 func ( fa * FindAndCountAll ) Error ( err error ) Error sets error to be returned. func (*FindAndCountAll) Result \u00b6 func ( fa * FindAndCountAll ) Result ( records interface {}, count int ) Result sets the result of this query. type Iterate \u00b6 type Iterate iterator Iterate asserts and simulate iterate function for test. func ExpectIterate \u00b6 func ExpectIterate ( r * Repository , query rel . Query , options [] rel . IteratorOption ) * Iterate ExpectIterate to be called. func (*Iterate) ConnectionClosed \u00b6 func ( i * Iterate ) ConnectionClosed () ConnectionClosed sets this error to be returned. func (*Iterate) Error \u00b6 func ( i * Iterate ) Error ( err error ) Error sets error to be returned. func (*Iterate) Result \u00b6 func ( i * Iterate ) Result ( records interface {}) Result sets the result of this query. type Mutate \u00b6 type Mutate struct { * Expect } Mutate asserts and simulate insert or update function for test. func ExpectInsert \u00b6 func ExpectInsert ( r * Repository , mutators [] rel . Mutator ) * Mutate ExpectInsert to be called with given field and queries. func ExpectInsertAll \u00b6 func ExpectInsertAll ( r * Repository ) * Mutate ExpectInsertAll to be called. func ExpectUpdate \u00b6 func ExpectUpdate ( r * Repository , mutators [] rel . Mutator ) * Mutate ExpectUpdate to be called with given field and queries. func (*Mutate) For \u00b6 func ( m * Mutate ) For ( record interface {}) * Mutate For match expect calls for given record. func (*Mutate) ForType \u00b6 func ( m * Mutate ) ForType ( typ string ) * Mutate ForType match expect calls for given type. Type must include package name, example: model.User . func (*Mutate) NotUnique \u00b6 func ( m * Mutate ) NotUnique ( key string ) NotUnique sets not unique error to be returned. type MutateAll \u00b6 type MutateAll struct { * Expect } MutateAll asserts and simulate mutate all function for test. func ExpectDeleteAll \u00b6 func ExpectDeleteAll ( r * Repository , query rel . Query ) * MutateAll ExpectDeleteAll to be called. func ExpectUpdateAll \u00b6 func ExpectUpdateAll ( r * Repository , query rel . Query , mutates [] rel . Mutate ) * MutateAll ExpectUpdateAll to be called. func (*MutateAll) Unsafe \u00b6 func ( ema * MutateAll ) Unsafe () Unsafe allows for unsafe operation that doesn't contains where clause. type Preload \u00b6 type Preload struct { * Expect } Preload asserts and simulate preload function for test. func ExpectPreload \u00b6 func ExpectPreload ( r * Repository , field string , queriers [] rel . Querier ) * Preload ExpectPreload to be called with given field and queries. func (*Preload) For \u00b6 func ( p * Preload ) For ( record interface {}) * Preload For match expect calls for given record. func (*Preload) ForType \u00b6 func ( p * Preload ) ForType ( typ string ) * Preload ForType match expect calls for given type. Type must include package name, example: model.User . func (*Preload) Result \u00b6 func ( p * Preload ) Result ( records interface {}) Result sets the result of Preload query. type Repository \u00b6 type Repository struct { // contains filtered or unexported fields } Repository is an autogenerated mock type for the Repository type func New \u00b6 func New () * Repository New test repository. func (*Repository) Adapter \u00b6 func ( r * Repository ) Adapter ( ctx context . Context ) rel . Adapter Adapter provides a mock function with given fields: func (*Repository) Aggregate \u00b6 func ( r * Repository ) Aggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) ( int , error ) Aggregate provides a mock function with given fields: query, aggregate, field func (*Repository) AssertExpectations \u00b6 func ( r * Repository ) AssertExpectations ( t * testing . T ) bool AssertExpectations asserts that everything was in fact called as expected. Calls may have occurred in any order. func (*Repository) Count \u00b6 func ( r * Repository ) Count ( ctx context . Context , collection string , queriers ... rel . Querier ) ( int , error ) Count provides a mock function with given fields: collection, queriers func (*Repository) Delete \u00b6 func ( r * Repository ) Delete ( ctx context . Context , record interface {}, options ... rel . Cascade ) error Delete provides a mock function with given fields: record func (*Repository) DeleteAll \u00b6 func ( r * Repository ) DeleteAll ( ctx context . Context , query rel . Query ) error DeleteAll provides a mock function with given fields: query func (*Repository) ExpectAggregate \u00b6 func ( r * Repository ) ExpectAggregate ( query rel . Query , aggregate string , field string ) * Aggregate ExpectAggregate apply mocks and expectations for Aggregate func (*Repository) ExpectCount \u00b6 func ( r * Repository ) ExpectCount ( collection string , queriers ... rel . Querier ) * Aggregate ExpectCount apply mocks and expectations for Count func (*Repository) ExpectDelete \u00b6 func ( r * Repository ) ExpectDelete ( options ... rel . Cascade ) * Delete ExpectDelete apply mocks and expectations for Delete func (*Repository) ExpectDeleteAll \u00b6 func ( r * Repository ) ExpectDeleteAll ( query rel . Query ) * MutateAll ExpectDeleteAll apply mocks and expectations for DeleteAll func (*Repository) ExpectFind \u00b6 func ( r * Repository ) ExpectFind ( queriers ... rel . Querier ) * Find ExpectFind apply mocks and expectations for Find func (*Repository) ExpectFindAll \u00b6 func ( r * Repository ) ExpectFindAll ( queriers ... rel . Querier ) * FindAll ExpectFindAll apply mocks and expectations for FindAll func (*Repository) ExpectFindAndCountAll \u00b6 func ( r * Repository ) ExpectFindAndCountAll ( queriers ... rel . Querier ) * FindAndCountAll ExpectFindAndCountAll apply mocks and expectations for FindAndCountAll func (*Repository) ExpectInsert \u00b6 func ( r * Repository ) ExpectInsert ( mutators ... rel . Mutator ) * Mutate ExpectInsert apply mocks and expectations for Insert func (*Repository) ExpectInsertAll \u00b6 func ( r * Repository ) ExpectInsertAll () * Mutate ExpectInsertAll records. func (*Repository) ExpectIterate \u00b6 func ( r * Repository ) ExpectIterate ( query rel . Query , options ... rel . IteratorOption ) * Iterate ExpectIterate apply mocks and expectations for Iterate func (*Repository) ExpectPreload \u00b6 func ( r * Repository ) ExpectPreload ( field string , queriers ... rel . Querier ) * Preload ExpectPreload apply mocks and expectations for Preload func (*Repository) ExpectTransaction \u00b6 func ( r * Repository ) ExpectTransaction ( fn func ( * Repository )) ExpectTransaction declare expectation inside transaction. func (*Repository) ExpectUpdate \u00b6 func ( r * Repository ) ExpectUpdate ( mutators ... rel . Mutator ) * Mutate ExpectUpdate apply mocks and expectations for Update func (*Repository) ExpectUpdateAll \u00b6 func ( r * Repository ) ExpectUpdateAll ( query rel . Query , mutates ... rel . Mutate ) * MutateAll ExpectUpdateAll apply mocks and expectations for UpdateAll func (*Repository) Find \u00b6 func ( r * Repository ) Find ( ctx context . Context , record interface {}, queriers ... rel . Querier ) error Find provides a mock function with given fields: record, queriers func (*Repository) FindAll \u00b6 func ( r * Repository ) FindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) error FindAll provides a mock function with given fields: records, queriers func (*Repository) FindAndCountAll \u00b6 func ( r * Repository ) FindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) ( int , error ) FindAndCountAll provides a mock function with given fields: records, queriers func (*Repository) Insert \u00b6 func ( r * Repository ) Insert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Insert provides a mock function with given fields: record, mutators func (*Repository) InsertAll \u00b6 func ( r * Repository ) InsertAll ( ctx context . Context , records interface {}) error InsertAll records. func (*Repository) Instrumentation \u00b6 func ( r * Repository ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation provides a mock function with given fields: instrumenter func (*Repository) Iterate \u00b6 func ( r * Repository ) Iterate ( ctx context . Context , query rel . Query , options ... rel . IteratorOption ) rel . Iterator Iterate through a collection of records from database in batches. This function returns iterator that can be used to loop all records. Limit, Offset and Sort query is automatically ignored. func (*Repository) MustAggregate \u00b6 func ( r * Repository ) MustAggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) int MustAggregate provides a mock function with given fields: query, aggregate, field func (*Repository) MustCount \u00b6 func ( r * Repository ) MustCount ( ctx context . Context , collection string , queriers ... rel . Querier ) int MustCount provides a mock function with given fields: collection, queriers func (*Repository) MustDelete \u00b6 func ( r * Repository ) MustDelete ( ctx context . Context , record interface {}, options ... rel . Cascade ) MustDelete provides a mock function with given fields: record func (*Repository) MustDeleteAll \u00b6 func ( r * Repository ) MustDeleteAll ( ctx context . Context , query rel . Query ) MustDeleteAll provides a mock function with given fields: query func (*Repository) MustFind \u00b6 func ( r * Repository ) MustFind ( ctx context . Context , record interface {}, queriers ... rel . Querier ) MustFind provides a mock function with given fields: record, queriers func (*Repository) MustFindAll \u00b6 func ( r * Repository ) MustFindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) MustFindAll provides a mock function with given fields: records, queriers func (*Repository) MustFindAndCountAll \u00b6 func ( r * Repository ) MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) int MustFindAndCountAll provides a mock function with given fields: records, queriers func (*Repository) MustInsert \u00b6 func ( r * Repository ) MustInsert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustInsert provides a mock function with given fields: record, mutators func (*Repository) MustInsertAll \u00b6 func ( r * Repository ) MustInsertAll ( ctx context . Context , records interface {}) MustInsertAll records. func (*Repository) MustPreload \u00b6 func ( r * Repository ) MustPreload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) MustPreload provides a mock function with given fields: records, field, queriers func (*Repository) MustUpdate \u00b6 func ( r * Repository ) MustUpdate ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustUpdate provides a mock function with given fields: record, mutators func (*Repository) MustUpdateAll \u00b6 func ( r * Repository ) MustUpdateAll ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) MustUpdateAll provides a mock function with given fields: query func (*Repository) Ping \u00b6 func ( r * Repository ) Ping ( ctx context . Context ) error Ping database. func (*Repository) Preload \u00b6 func ( r * Repository ) Preload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) error Preload provides a mock function with given fields: records, field, queriers func (*Repository) Transaction \u00b6 func ( r * Repository ) Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error Transaction provides a mock function with given fields: fn func (*Repository) Update \u00b6 func ( r * Repository ) Update ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Update provides a mock function with given fields: record, mutators func (*Repository) UpdateAll \u00b6 func ( r * Repository ) UpdateAll ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) error UpdateAll provides a mock function with given fields: query","title":"github.com/Fs02/rel/reltest"},{"location":"reference/reltest/#reltest","text":"import \"github.com/Fs02/rel/reltest\"","title":"reltest"},{"location":"reference/reltest/#overview","text":"","title":"Overview"},{"location":"reference/reltest/#variables","text":"var ( // ErrConnectionClosed is alias for sql.ErrConnDone. ErrConnectionClosed = sql . ErrConnDone )","title":"Variables"},{"location":"reference/reltest/#type-aggregate","text":"type Aggregate struct { * Expect } Aggregate asserts and simulate aggregate function for test.","title":"type Aggregate"},{"location":"reference/reltest/#func-expectaggregate","text":"func ExpectAggregate ( r * Repository , query rel . Query , aggregate string , field string ) * Aggregate ExpectAggregate to be called with given field and queries.","title":"func ExpectAggregate"},{"location":"reference/reltest/#func-expectcount","text":"func ExpectCount ( r * Repository , collection string , queriers [] rel . Querier ) * Aggregate ExpectCount to be called with given field and queries.","title":"func ExpectCount"},{"location":"reference/reltest/#func-aggregate-connectionclosed","text":"func ( a * Aggregate ) ConnectionClosed () ConnectionClosed sets this error to be returned.","title":"func (*Aggregate) ConnectionClosed"},{"location":"reference/reltest/#func-aggregate-error","text":"func ( a * Aggregate ) Error ( err error ) Error sets error to be returned.","title":"func (*Aggregate) Error"},{"location":"reference/reltest/#func-aggregate-result","text":"func ( a * Aggregate ) Result ( count int ) Result sets the result of this query.","title":"func (*Aggregate) Result"},{"location":"reference/reltest/#type-delete","text":"type Delete struct { * Expect } Delete asserts and simulate delete function for test.","title":"type Delete"},{"location":"reference/reltest/#func-expectdelete","text":"func ExpectDelete ( r * Repository , options [] rel . Cascade ) * Delete ExpectDelete to be called.","title":"func ExpectDelete"},{"location":"reference/reltest/#func-delete-for","text":"func ( d * Delete ) For ( record interface {}) * Delete For match expect calls for given record.","title":"func (*Delete) For"},{"location":"reference/reltest/#func-delete-fortype","text":"func ( d * Delete ) ForType ( typ string ) * Delete ForType match expect calls for given type. Type must include package name, example: model.User .","title":"func (*Delete) ForType"},{"location":"reference/reltest/#type-expect","text":"type Expect struct { * mock . Call } Expect is base behaviour for all reltest expectations.","title":"type Expect"},{"location":"reference/reltest/#func-expect-connectionclosed","text":"func ( e * Expect ) ConnectionClosed () ConnectionClosed sets this error to be returned.","title":"func (*Expect) ConnectionClosed"},{"location":"reference/reltest/#func-expect-error","text":"func ( e * Expect ) Error ( err error ) Error sets error to be returned.","title":"func (*Expect) Error"},{"location":"reference/reltest/#type-find","text":"type Find struct { * FindAll } Find asserts and simulate find function for test.","title":"type Find"},{"location":"reference/reltest/#func-expectfind","text":"func ExpectFind ( r * Repository , queriers [] rel . Querier ) * Find ExpectFind to be called with given field and queries.","title":"func ExpectFind"},{"location":"reference/reltest/#func-find-notfound","text":"func ( f * Find ) NotFound () NotFound sets NotFoundError to be returned.","title":"func (*Find) NotFound"},{"location":"reference/reltest/#type-findall","text":"type FindAll struct { * Expect } FindAll asserts and simulate find all function for test.","title":"type FindAll"},{"location":"reference/reltest/#func-expectfindall","text":"func ExpectFindAll ( r * Repository , queriers [] rel . Querier ) * FindAll ExpectFindAll to be called with given field and queries.","title":"func ExpectFindAll"},{"location":"reference/reltest/#func-findall-result","text":"func ( fa * FindAll ) Result ( records interface {}) Result sets the result of this query.","title":"func (*FindAll) Result"},{"location":"reference/reltest/#type-findandcountall","text":"type FindAndCountAll struct { * Expect } FindAndCountAll asserts and simulate find all function for test.","title":"type FindAndCountAll"},{"location":"reference/reltest/#func-expectfindandcountall","text":"func ExpectFindAndCountAll ( r * Repository , queriers [] rel . Querier ) * FindAndCountAll ExpectFindAndCountAll to be called with given field and queries.","title":"func ExpectFindAndCountAll"},{"location":"reference/reltest/#func-findandcountall-connectionclosed","text":"func ( fa * FindAndCountAll ) ConnectionClosed () ConnectionClosed sets this error to be returned.","title":"func (*FindAndCountAll) ConnectionClosed"},{"location":"reference/reltest/#func-findandcountall-error","text":"func ( fa * FindAndCountAll ) Error ( err error ) Error sets error to be returned.","title":"func (*FindAndCountAll) Error"},{"location":"reference/reltest/#func-findandcountall-result","text":"func ( fa * FindAndCountAll ) Result ( records interface {}, count int ) Result sets the result of this query.","title":"func (*FindAndCountAll) Result"},{"location":"reference/reltest/#type-iterate","text":"type Iterate iterator Iterate asserts and simulate iterate function for test.","title":"type Iterate"},{"location":"reference/reltest/#func-expectiterate","text":"func ExpectIterate ( r * Repository , query rel . Query , options [] rel . IteratorOption ) * Iterate ExpectIterate to be called.","title":"func ExpectIterate"},{"location":"reference/reltest/#func-iterate-connectionclosed","text":"func ( i * Iterate ) ConnectionClosed () ConnectionClosed sets this error to be returned.","title":"func (*Iterate) ConnectionClosed"},{"location":"reference/reltest/#func-iterate-error","text":"func ( i * Iterate ) Error ( err error ) Error sets error to be returned.","title":"func (*Iterate) Error"},{"location":"reference/reltest/#func-iterate-result","text":"func ( i * Iterate ) Result ( records interface {}) Result sets the result of this query.","title":"func (*Iterate) Result"},{"location":"reference/reltest/#type-mutate","text":"type Mutate struct { * Expect } Mutate asserts and simulate insert or update function for test.","title":"type Mutate"},{"location":"reference/reltest/#func-expectinsert","text":"func ExpectInsert ( r * Repository , mutators [] rel . Mutator ) * Mutate ExpectInsert to be called with given field and queries.","title":"func ExpectInsert"},{"location":"reference/reltest/#func-expectinsertall","text":"func ExpectInsertAll ( r * Repository ) * Mutate ExpectInsertAll to be called.","title":"func ExpectInsertAll"},{"location":"reference/reltest/#func-expectupdate","text":"func ExpectUpdate ( r * Repository , mutators [] rel . Mutator ) * Mutate ExpectUpdate to be called with given field and queries.","title":"func ExpectUpdate"},{"location":"reference/reltest/#func-mutate-for","text":"func ( m * Mutate ) For ( record interface {}) * Mutate For match expect calls for given record.","title":"func (*Mutate) For"},{"location":"reference/reltest/#func-mutate-fortype","text":"func ( m * Mutate ) ForType ( typ string ) * Mutate ForType match expect calls for given type. Type must include package name, example: model.User .","title":"func (*Mutate) ForType"},{"location":"reference/reltest/#func-mutate-notunique","text":"func ( m * Mutate ) NotUnique ( key string ) NotUnique sets not unique error to be returned.","title":"func (*Mutate) NotUnique"},{"location":"reference/reltest/#type-mutateall","text":"type MutateAll struct { * Expect } MutateAll asserts and simulate mutate all function for test.","title":"type MutateAll"},{"location":"reference/reltest/#func-expectdeleteall","text":"func ExpectDeleteAll ( r * Repository , query rel . Query ) * MutateAll ExpectDeleteAll to be called.","title":"func ExpectDeleteAll"},{"location":"reference/reltest/#func-expectupdateall","text":"func ExpectUpdateAll ( r * Repository , query rel . Query , mutates [] rel . Mutate ) * MutateAll ExpectUpdateAll to be called.","title":"func ExpectUpdateAll"},{"location":"reference/reltest/#func-mutateall-unsafe","text":"func ( ema * MutateAll ) Unsafe () Unsafe allows for unsafe operation that doesn't contains where clause.","title":"func (*MutateAll) Unsafe"},{"location":"reference/reltest/#type-preload","text":"type Preload struct { * Expect } Preload asserts and simulate preload function for test.","title":"type Preload"},{"location":"reference/reltest/#func-expectpreload","text":"func ExpectPreload ( r * Repository , field string , queriers [] rel . Querier ) * Preload ExpectPreload to be called with given field and queries.","title":"func ExpectPreload"},{"location":"reference/reltest/#func-preload-for","text":"func ( p * Preload ) For ( record interface {}) * Preload For match expect calls for given record.","title":"func (*Preload) For"},{"location":"reference/reltest/#func-preload-fortype","text":"func ( p * Preload ) ForType ( typ string ) * Preload ForType match expect calls for given type. Type must include package name, example: model.User .","title":"func (*Preload) ForType"},{"location":"reference/reltest/#func-preload-result","text":"func ( p * Preload ) Result ( records interface {}) Result sets the result of Preload query.","title":"func (*Preload) Result"},{"location":"reference/reltest/#type-repository","text":"type Repository struct { // contains filtered or unexported fields } Repository is an autogenerated mock type for the Repository type","title":"type Repository"},{"location":"reference/reltest/#func-new","text":"func New () * Repository New test repository.","title":"func New"},{"location":"reference/reltest/#func-repository-adapter","text":"func ( r * Repository ) Adapter ( ctx context . Context ) rel . Adapter Adapter provides a mock function with given fields:","title":"func (*Repository) Adapter"},{"location":"reference/reltest/#func-repository-aggregate","text":"func ( r * Repository ) Aggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) ( int , error ) Aggregate provides a mock function with given fields: query, aggregate, field","title":"func (*Repository) Aggregate"},{"location":"reference/reltest/#func-repository-assertexpectations","text":"func ( r * Repository ) AssertExpectations ( t * testing . T ) bool AssertExpectations asserts that everything was in fact called as expected. Calls may have occurred in any order.","title":"func (*Repository) AssertExpectations"},{"location":"reference/reltest/#func-repository-count","text":"func ( r * Repository ) Count ( ctx context . Context , collection string , queriers ... rel . Querier ) ( int , error ) Count provides a mock function with given fields: collection, queriers","title":"func (*Repository) Count"},{"location":"reference/reltest/#func-repository-delete","text":"func ( r * Repository ) Delete ( ctx context . Context , record interface {}, options ... rel . Cascade ) error Delete provides a mock function with given fields: record","title":"func (*Repository) Delete"},{"location":"reference/reltest/#func-repository-deleteall","text":"func ( r * Repository ) DeleteAll ( ctx context . Context , query rel . Query ) error DeleteAll provides a mock function with given fields: query","title":"func (*Repository) DeleteAll"},{"location":"reference/reltest/#func-repository-expectaggregate","text":"func ( r * Repository ) ExpectAggregate ( query rel . Query , aggregate string , field string ) * Aggregate ExpectAggregate apply mocks and expectations for Aggregate","title":"func (*Repository) ExpectAggregate"},{"location":"reference/reltest/#func-repository-expectcount","text":"func ( r * Repository ) ExpectCount ( collection string , queriers ... rel . Querier ) * Aggregate ExpectCount apply mocks and expectations for Count","title":"func (*Repository) ExpectCount"},{"location":"reference/reltest/#func-repository-expectdelete","text":"func ( r * Repository ) ExpectDelete ( options ... rel . Cascade ) * Delete ExpectDelete apply mocks and expectations for Delete","title":"func (*Repository) ExpectDelete"},{"location":"reference/reltest/#func-repository-expectdeleteall","text":"func ( r * Repository ) ExpectDeleteAll ( query rel . Query ) * MutateAll ExpectDeleteAll apply mocks and expectations for DeleteAll","title":"func (*Repository) ExpectDeleteAll"},{"location":"reference/reltest/#func-repository-expectfind","text":"func ( r * Repository ) ExpectFind ( queriers ... rel . Querier ) * Find ExpectFind apply mocks and expectations for Find","title":"func (*Repository) ExpectFind"},{"location":"reference/reltest/#func-repository-expectfindall","text":"func ( r * Repository ) ExpectFindAll ( queriers ... rel . Querier ) * FindAll ExpectFindAll apply mocks and expectations for FindAll","title":"func (*Repository) ExpectFindAll"},{"location":"reference/reltest/#func-repository-expectfindandcountall","text":"func ( r * Repository ) ExpectFindAndCountAll ( queriers ... rel . Querier ) * FindAndCountAll ExpectFindAndCountAll apply mocks and expectations for FindAndCountAll","title":"func (*Repository) ExpectFindAndCountAll"},{"location":"reference/reltest/#func-repository-expectinsert","text":"func ( r * Repository ) ExpectInsert ( mutators ... rel . Mutator ) * Mutate ExpectInsert apply mocks and expectations for Insert","title":"func (*Repository) ExpectInsert"},{"location":"reference/reltest/#func-repository-expectinsertall","text":"func ( r * Repository ) ExpectInsertAll () * Mutate ExpectInsertAll records.","title":"func (*Repository) ExpectInsertAll"},{"location":"reference/reltest/#func-repository-expectiterate","text":"func ( r * Repository ) ExpectIterate ( query rel . Query , options ... rel . IteratorOption ) * Iterate ExpectIterate apply mocks and expectations for Iterate","title":"func (*Repository) ExpectIterate"},{"location":"reference/reltest/#func-repository-expectpreload","text":"func ( r * Repository ) ExpectPreload ( field string , queriers ... rel . Querier ) * Preload ExpectPreload apply mocks and expectations for Preload","title":"func (*Repository) ExpectPreload"},{"location":"reference/reltest/#func-repository-expecttransaction","text":"func ( r * Repository ) ExpectTransaction ( fn func ( * Repository )) ExpectTransaction declare expectation inside transaction.","title":"func (*Repository) ExpectTransaction"},{"location":"reference/reltest/#func-repository-expectupdate","text":"func ( r * Repository ) ExpectUpdate ( mutators ... rel . Mutator ) * Mutate ExpectUpdate apply mocks and expectations for Update","title":"func (*Repository) ExpectUpdate"},{"location":"reference/reltest/#func-repository-expectupdateall","text":"func ( r * Repository ) ExpectUpdateAll ( query rel . Query , mutates ... rel . Mutate ) * MutateAll ExpectUpdateAll apply mocks and expectations for UpdateAll","title":"func (*Repository) ExpectUpdateAll"},{"location":"reference/reltest/#func-repository-find","text":"func ( r * Repository ) Find ( ctx context . Context , record interface {}, queriers ... rel . Querier ) error Find provides a mock function with given fields: record, queriers","title":"func (*Repository) Find"},{"location":"reference/reltest/#func-repository-findall","text":"func ( r * Repository ) FindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) error FindAll provides a mock function with given fields: records, queriers","title":"func (*Repository) FindAll"},{"location":"reference/reltest/#func-repository-findandcountall","text":"func ( r * Repository ) FindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) ( int , error ) FindAndCountAll provides a mock function with given fields: records, queriers","title":"func (*Repository) FindAndCountAll"},{"location":"reference/reltest/#func-repository-insert","text":"func ( r * Repository ) Insert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Insert provides a mock function with given fields: record, mutators","title":"func (*Repository) Insert"},{"location":"reference/reltest/#func-repository-insertall","text":"func ( r * Repository ) InsertAll ( ctx context . Context , records interface {}) error InsertAll records.","title":"func (*Repository) InsertAll"},{"location":"reference/reltest/#func-repository-instrumentation","text":"func ( r * Repository ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation provides a mock function with given fields: instrumenter","title":"func (*Repository) Instrumentation"},{"location":"reference/reltest/#func-repository-iterate","text":"func ( r * Repository ) Iterate ( ctx context . Context , query rel . Query , options ... rel . IteratorOption ) rel . Iterator Iterate through a collection of records from database in batches. This function returns iterator that can be used to loop all records. Limit, Offset and Sort query is automatically ignored.","title":"func (*Repository) Iterate"},{"location":"reference/reltest/#func-repository-mustaggregate","text":"func ( r * Repository ) MustAggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) int MustAggregate provides a mock function with given fields: query, aggregate, field","title":"func (*Repository) MustAggregate"},{"location":"reference/reltest/#func-repository-mustcount","text":"func ( r * Repository ) MustCount ( ctx context . Context , collection string , queriers ... rel . Querier ) int MustCount provides a mock function with given fields: collection, queriers","title":"func (*Repository) MustCount"},{"location":"reference/reltest/#func-repository-mustdelete","text":"func ( r * Repository ) MustDelete ( ctx context . Context , record interface {}, options ... rel . Cascade ) MustDelete provides a mock function with given fields: record","title":"func (*Repository) MustDelete"},{"location":"reference/reltest/#func-repository-mustdeleteall","text":"func ( r * Repository ) MustDeleteAll ( ctx context . Context , query rel . Query ) MustDeleteAll provides a mock function with given fields: query","title":"func (*Repository) MustDeleteAll"},{"location":"reference/reltest/#func-repository-mustfind","text":"func ( r * Repository ) MustFind ( ctx context . Context , record interface {}, queriers ... rel . Querier ) MustFind provides a mock function with given fields: record, queriers","title":"func (*Repository) MustFind"},{"location":"reference/reltest/#func-repository-mustfindall","text":"func ( r * Repository ) MustFindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) MustFindAll provides a mock function with given fields: records, queriers","title":"func (*Repository) MustFindAll"},{"location":"reference/reltest/#func-repository-mustfindandcountall","text":"func ( r * Repository ) MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) int MustFindAndCountAll provides a mock function with given fields: records, queriers","title":"func (*Repository) MustFindAndCountAll"},{"location":"reference/reltest/#func-repository-mustinsert","text":"func ( r * Repository ) MustInsert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustInsert provides a mock function with given fields: record, mutators","title":"func (*Repository) MustInsert"},{"location":"reference/reltest/#func-repository-mustinsertall","text":"func ( r * Repository ) MustInsertAll ( ctx context . Context , records interface {}) MustInsertAll records.","title":"func (*Repository) MustInsertAll"},{"location":"reference/reltest/#func-repository-mustpreload","text":"func ( r * Repository ) MustPreload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) MustPreload provides a mock function with given fields: records, field, queriers","title":"func (*Repository) MustPreload"},{"location":"reference/reltest/#func-repository-mustupdate","text":"func ( r * Repository ) MustUpdate ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustUpdate provides a mock function with given fields: record, mutators","title":"func (*Repository) MustUpdate"},{"location":"reference/reltest/#func-repository-mustupdateall","text":"func ( r * Repository ) MustUpdateAll ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) MustUpdateAll provides a mock function with given fields: query","title":"func (*Repository) MustUpdateAll"},{"location":"reference/reltest/#func-repository-ping","text":"func ( r * Repository ) Ping ( ctx context . Context ) error Ping database.","title":"func (*Repository) Ping"},{"location":"reference/reltest/#func-repository-preload","text":"func ( r * Repository ) Preload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) error Preload provides a mock function with given fields: records, field, queriers","title":"func (*Repository) Preload"},{"location":"reference/reltest/#func-repository-transaction","text":"func ( r * Repository ) Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error Transaction provides a mock function with given fields: fn","title":"func (*Repository) Transaction"},{"location":"reference/reltest/#func-repository-update","text":"func ( r * Repository ) Update ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Update provides a mock function with given fields: record, mutators","title":"func (*Repository) Update"},{"location":"reference/reltest/#func-repository-updateall","text":"func ( r * Repository ) UpdateAll ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) error UpdateAll provides a mock function with given fields: query","title":"func (*Repository) UpdateAll"},{"location":"reference/sort/","text":"sort \u00b6 import \"github.com/Fs02/rel/sort\" Overview \u00b6 Package sort is syntatic sugar for building sort query. Variables \u00b6 var ( // Asc creates a query that sort the result ascending by specified field. Asc = rel . NewSortAsc // Desc creates a query that sort the result descending by specified field. Desc = rel . NewSortDesc )","title":"github.com/Fs02/rel/sort"},{"location":"reference/sort/#sort","text":"import \"github.com/Fs02/rel/sort\"","title":"sort"},{"location":"reference/sort/#overview","text":"Package sort is syntatic sugar for building sort query.","title":"Overview"},{"location":"reference/sort/#variables","text":"var ( // Asc creates a query that sort the result ascending by specified field. Asc = rel . NewSortAsc // Desc creates a query that sort the result descending by specified field. Desc = rel . NewSortDesc )","title":"Variables"},{"location":"reference/where/","text":"where \u00b6 import \"github.com/Fs02/rel/where\" Overview \u00b6 Package where is syntatic sugar for building where query. Variables \u00b6 var ( // And compares other filters using and. And = rel . And // Or compares other filters using and. Or = rel . Or // Not wraps filters using not. // It'll negate the filter type if possible. Not = rel . Not // Eq expression field equal to value. Eq = rel . Eq // Ne compares that left value is not equal to right value. Ne = rel . Ne // Lt compares that left value is less than to right value. Lt = rel . Lt // Lte compares that left value is less than or equal to right value. Lte = rel . Lte // Gt compares that left value is greater than to right value. Gt = rel . Gt // Gte compares that left value is greater than or equal to right value. Gte = rel . Gte // Nil check whether field is nil. Nil = rel . Nil // NotNil check whether field is not nil. NotNil = rel . NotNil // In check whethers value of the field is included in values. In = rel . In // InInt check whethers integer value of the field is included in values. InInt = rel . InInt // InUint check whethers unsigned integer value of the field is included in values. InUint = rel . InUint // InString check whethers string value of the field is included in values. InString = rel . InString // Nin check whethers value of the field is not included in values. Nin = rel . Nin // NinInt check whethers integer value of the field is not included in values. NinInt = rel . NinInt // NinUint check whethers unsigned integer value of the field is not included in values. NinUint = rel . NinUint // NinString check whethers string value of the field is not included in values. NinString = rel . NinString // Like compares value of field to match string pattern. Like = rel . Like // NotLike compares value of field to not match string pattern. NotLike = rel . NotLike // Fragment add custom filter. Fragment = rel . FilterFragment )","title":"github.com/Fs02/rel/where"},{"location":"reference/where/#where","text":"import \"github.com/Fs02/rel/where\"","title":"where"},{"location":"reference/where/#overview","text":"Package where is syntatic sugar for building where query.","title":"Overview"},{"location":"reference/where/#variables","text":"var ( // And compares other filters using and. And = rel . And // Or compares other filters using and. Or = rel . Or // Not wraps filters using not. // It'll negate the filter type if possible. Not = rel . Not // Eq expression field equal to value. Eq = rel . Eq // Ne compares that left value is not equal to right value. Ne = rel . Ne // Lt compares that left value is less than to right value. Lt = rel . Lt // Lte compares that left value is less than or equal to right value. Lte = rel . Lte // Gt compares that left value is greater than to right value. Gt = rel . Gt // Gte compares that left value is greater than or equal to right value. Gte = rel . Gte // Nil check whether field is nil. Nil = rel . Nil // NotNil check whether field is not nil. NotNil = rel . NotNil // In check whethers value of the field is included in values. In = rel . In // InInt check whethers integer value of the field is included in values. InInt = rel . InInt // InUint check whethers unsigned integer value of the field is included in values. InUint = rel . InUint // InString check whethers string value of the field is included in values. InString = rel . InString // Nin check whethers value of the field is not included in values. Nin = rel . Nin // NinInt check whethers integer value of the field is not included in values. NinInt = rel . NinInt // NinUint check whethers unsigned integer value of the field is not included in values. NinUint = rel . NinUint // NinString check whethers string value of the field is not included in values. NinString = rel . NinString // Like compares value of field to match string pattern. Like = rel . Like // NotLike compares value of field to not match string pattern. NotLike = rel . NotLike // Fragment add custom filter. Fragment = rel . FilterFragment )","title":"Variables"}]}