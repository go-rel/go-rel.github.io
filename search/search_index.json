{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"adapters/","text":"Adapters \u00b6 Rel uses adapter in order to generate and execute query to a database, below is the list of available adapters currently supported. Adapter Package Godoc MySQL github.com/go-rel/mysql PostgreSQL github.com/go-rel/postgres MSSQL github.com/go-rel/mssql SQLite3 github.com/go-rel/sqlite3 Using Primary Replica Connections \u00b6 REL Read Write separation for primary replica connections by using intermediary adapters. package main import ( \"context\" _ \"github.com/go-sql-driver/mysql\" \"github.com/go-rel/primaryreplica\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" ) func main () { // open mysql connections. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter := primaryreplica . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica1:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica2:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), ) defer adapter . Close () // initialize REL's repo. repo := rel . New ( adapter ) repo . Ping ( context . TODO ()) } Load Balancing of Replicas \u00b6 REL only implements a very primitive load balancing for multiple replicas. For large scale application we recommend you to use external load balancing solution.","title":"Adapters"},{"location":"adapters/#adapters","text":"Rel uses adapter in order to generate and execute query to a database, below is the list of available adapters currently supported. Adapter Package Godoc MySQL github.com/go-rel/mysql PostgreSQL github.com/go-rel/postgres MSSQL github.com/go-rel/mssql SQLite3 github.com/go-rel/sqlite3","title":"Adapters"},{"location":"adapters/#using-primary-replica-connections","text":"REL Read Write separation for primary replica connections by using intermediary adapters. package main import ( \"context\" _ \"github.com/go-sql-driver/mysql\" \"github.com/go-rel/primaryreplica\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" ) func main () { // open mysql connections. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter := primaryreplica . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica1:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica2:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), ) defer adapter . Close () // initialize REL's repo. repo := rel . New ( adapter ) repo . Ping ( context . TODO ()) }","title":"Using Primary Replica Connections"},{"location":"adapters/#load-balancing-of-replicas","text":"REL only implements a very primitive load balancing for multiple replicas. For large scale application we recommend you to use external load balancing solution.","title":"Load Balancing of Replicas"},{"location":"association/","text":"Association \u00b6 Defining Association \u00b6 Association in REL can be declared by ensuring that each association have an association field, reference id field and foreign id field. Association field is a field with the type of another struct. Reference id is an id field that can be mapped to the foreign id field in another struct. By following that convention, REL currently supports belongs to , has one and has many association. // User schema. type User struct { ID int Name string Age int CreatedAt time . Time UpdatedAt time . Time // has many transactions. // with custom reference and foreign field declaration. // ref: id refers to User.ID field. // fk: buyer_id refers to Transaction.BuyerID Transactions [] Transaction `ref:\"id\" fk:\"buyer_id\"` // has one address. // doesn't contains primary key of other struct. // REL can guess the reference and foreign field if it's not specified. // autosave tag tells rel to automatically save the association when the parent is inserted/updated/deleted. // autoload tag tells rel to automatically load the association when record is queried. // alternatively you can use auto to enable both autoload and autosave. Address Address `autosave:\"true\" autoload:\"true\"` } // Transaction schema. type Transaction struct { ID int Item string Status string // belongs to user. // contains primary key of other struct. Buyer User `ref:\"buyer_id\" fk:\"id\"` BuyerID int } // Address schema. type Address struct { ID int City string // belongs to user. User * User UserID * int } Preloading Association \u00b6 Preload will load association to structs. To preload association, use Preload . Preload Transaction's Buyer ( belongs to association): Example err := repo . Preload ( ctx , & transaction , \"buyer\" ) Mock user := User { ID : 1 , Name : \"Nabe\" } repo . ExpectPreload ( \"buyer\" ). Result ( user ) Preload User's Address ( has one association): Example err := repo . Preload ( ctx , & user , \"address\" ) Mock address := Address { ID : 1 , City : \"Nazarick\" } repo . ExpectPreload ( \"address\" ). Result ( address ) Preload User's Transactions ( has many association): Example err := repo . Preload ( ctx , & user , \"transactions\" ) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" ). Result ( transactions ) Preload only paid Transactions from users: Example err := repo . Preload ( ctx , & user , \"transactions\" , where . Eq ( \"status\" , \"paid\" )) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" , where . Eq ( \"status\" , \"paid\" )). Result ( transactions ) Preload every Buyer's Address in Transactions (Buyer needs to be preloaded before preloading Buyer's Address): Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Preload also support slice, preload multiple transactions at once: Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Inserting and Updating Association \u00b6 REL can automatically modifies association when it's parent is modified. If ID of association struct is not a zero value, REL will try to update the association, else it'll create a new association. Note Autosave feature needs to be explicitly enabled by adding ( autosave:\"true\" ) tag to the struct definition. Example: see User.Address struct. Example user := User { Name : \"rel\" , Address : Address { City : \"Bandung\" , }, } // Inserts a new record to users and address table. // Result: User{ID: 1, Name: \"rel\", Address: Address{ID: 1, City: \"Bandung\", UserID: 1}} err := repo . Insert ( ctx , & user ) Mock repo . ExpectInsert (). ForType ( \"main.User\" ) REL will try to update a new record for association if ID is a zero value. To update association, it first needs to be preloaded. Example userID := 1 user := User { ID : 1 , Name : \"rel\" , // association is loaded when the primary key (id) is not zero. Address : Address { ID : 1 , UserID : & userID , City : \"Bandung\" , }, } // Update user record with id 1. // Update address record with id 1. err := repo . Update ( ctx , & user ) Mock repo . ExpectUpdate (). ForType ( \"main.User\" ) To selectively update only specific fields or association, use rel.Map . Example mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record if it's loaded else it'll creates a new address. // only set city to bandung. err := repo . Update ( ctx , & user , mutation ) Mock mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record with id 1, only set city to bandung. repo . ExpectUpdate ( mutation ). ForType ( \"main.User\" ) Auto Saving and Loading Association \u00b6 REL supports automatic loading or saving of association in structs by specifying the following struct tags: autosave=\"true\" : Enables automatic saving of the association whenever parent is inserted/updated/deleted. autoload=\"true\" : Enables automatic preloading of the association whenever parent is queried. auto=\"true\" : Shorthand for enabling both autosave=\"true\" and autoload=\"true\" .","title":"Association"},{"location":"association/#association","text":"","title":"Association"},{"location":"association/#defining-association","text":"Association in REL can be declared by ensuring that each association have an association field, reference id field and foreign id field. Association field is a field with the type of another struct. Reference id is an id field that can be mapped to the foreign id field in another struct. By following that convention, REL currently supports belongs to , has one and has many association. // User schema. type User struct { ID int Name string Age int CreatedAt time . Time UpdatedAt time . Time // has many transactions. // with custom reference and foreign field declaration. // ref: id refers to User.ID field. // fk: buyer_id refers to Transaction.BuyerID Transactions [] Transaction `ref:\"id\" fk:\"buyer_id\"` // has one address. // doesn't contains primary key of other struct. // REL can guess the reference and foreign field if it's not specified. // autosave tag tells rel to automatically save the association when the parent is inserted/updated/deleted. // autoload tag tells rel to automatically load the association when record is queried. // alternatively you can use auto to enable both autoload and autosave. Address Address `autosave:\"true\" autoload:\"true\"` } // Transaction schema. type Transaction struct { ID int Item string Status string // belongs to user. // contains primary key of other struct. Buyer User `ref:\"buyer_id\" fk:\"id\"` BuyerID int } // Address schema. type Address struct { ID int City string // belongs to user. User * User UserID * int }","title":"Defining Association"},{"location":"association/#preloading-association","text":"Preload will load association to structs. To preload association, use Preload . Preload Transaction's Buyer ( belongs to association): Example err := repo . Preload ( ctx , & transaction , \"buyer\" ) Mock user := User { ID : 1 , Name : \"Nabe\" } repo . ExpectPreload ( \"buyer\" ). Result ( user ) Preload User's Address ( has one association): Example err := repo . Preload ( ctx , & user , \"address\" ) Mock address := Address { ID : 1 , City : \"Nazarick\" } repo . ExpectPreload ( \"address\" ). Result ( address ) Preload User's Transactions ( has many association): Example err := repo . Preload ( ctx , & user , \"transactions\" ) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" ). Result ( transactions ) Preload only paid Transactions from users: Example err := repo . Preload ( ctx , & user , \"transactions\" , where . Eq ( \"status\" , \"paid\" )) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" , where . Eq ( \"status\" , \"paid\" )). Result ( transactions ) Preload every Buyer's Address in Transactions (Buyer needs to be preloaded before preloading Buyer's Address): Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Preload also support slice, preload multiple transactions at once: Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses )","title":"Preloading Association"},{"location":"association/#inserting-and-updating-association","text":"REL can automatically modifies association when it's parent is modified. If ID of association struct is not a zero value, REL will try to update the association, else it'll create a new association. Note Autosave feature needs to be explicitly enabled by adding ( autosave:\"true\" ) tag to the struct definition. Example: see User.Address struct. Example user := User { Name : \"rel\" , Address : Address { City : \"Bandung\" , }, } // Inserts a new record to users and address table. // Result: User{ID: 1, Name: \"rel\", Address: Address{ID: 1, City: \"Bandung\", UserID: 1}} err := repo . Insert ( ctx , & user ) Mock repo . ExpectInsert (). ForType ( \"main.User\" ) REL will try to update a new record for association if ID is a zero value. To update association, it first needs to be preloaded. Example userID := 1 user := User { ID : 1 , Name : \"rel\" , // association is loaded when the primary key (id) is not zero. Address : Address { ID : 1 , UserID : & userID , City : \"Bandung\" , }, } // Update user record with id 1. // Update address record with id 1. err := repo . Update ( ctx , & user ) Mock repo . ExpectUpdate (). ForType ( \"main.User\" ) To selectively update only specific fields or association, use rel.Map . Example mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record if it's loaded else it'll creates a new address. // only set city to bandung. err := repo . Update ( ctx , & user , mutation ) Mock mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record with id 1, only set city to bandung. repo . ExpectUpdate ( mutation ). ForType ( \"main.User\" )","title":"Inserting and Updating Association"},{"location":"association/#auto-saving-and-loading-association","text":"REL supports automatic loading or saving of association in structs by specifying the following struct tags: autosave=\"true\" : Enables automatic saving of the association whenever parent is inserted/updated/deleted. autoload=\"true\" : Enables automatic preloading of the association whenever parent is queried. auto=\"true\" : Shorthand for enabling both autosave=\"true\" and autoload=\"true\" .","title":"Auto Saving and Loading Association"},{"location":"basics/","text":"Basics \u00b6 Full Example \u00b6 Below is a very basic example on how to utilize REL using mysql adapter. Testing database query using REL can be done using reltest package. main.go package main import ( \"context\" \"time\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" _ \"github.com/go-sql-driver/mysql\" ) // Author is a model that maps to authors table. type Author struct { ID int Name string } // Book is a model that maps to books table. type Book struct { ID int Title string Category string Price int Discount bool Stock int AuthorID int Author Author Publisher string CreatedAt time . Time UpdatedAt time . Time } var dsn = \"root@(127.0.0.1:3306)/db?charset=utf8&parseTime=True&loc=Local\" func main () { // initialize mysql adapter. adapter , _ := mysql . Open ( dsn ) defer adapter . Close () // initialize rel's repo. repo := rel . New ( adapter ) // run Example ( context . Background (), repo ) } // Example is an actual service function that run a complex business package. // beware: it's actually doing nonsense here. func Example ( ctx context . Context , repo rel . Repository ) error { var book Book // Quickly find a book with id 1 using short alias. if err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )); err != nil { return err } // Or use chainable query builder. query := rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 ) if err := repo . Find ( ctx , & book , query ); err != nil { return err } // Convenient method to preload Book's Author. if err := repo . Preload ( ctx , & book , \"author\" ); err != nil { return err } // Performs updates inside a transaction. return repo . Transaction ( ctx , func ( ctx context . Context ) error { // basic update using struct. book . Title = \"REL for dummies\" repo . MustUpdate ( ctx , & book ) // update only specific fields. repo . MustUpdate ( ctx , & book , rel . Set ( \"discount\" , false )) // it even supports atomic inc/dec mutation. return repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) }) } main_test.go package main import ( \"context\" \"testing\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" \"github.com/go-rel/reltest\" \"github.com/stretchr/testify/assert\" ) func TestExample ( t * testing . T ) { // create a mocked repository. var ( repo = reltest . New () book = Book { ID : 1 , Title : \"Go for dummies\" , Category : \"learning\" , AuthorID : 1 , } author = Author { ID : 1 , Name : \"CZ2I28 Delta\" } ) // mock find and return result repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) // mock find and return result using query builder. repo . ExpectFind ( rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 )). Result ( book ) // mock preload and return result repo . ExpectPreload ( \"author\" ). ForType ( \"main.Book\" ). Result ( author ) // mocks transaction repo . ExpectTransaction ( func ( repo * reltest . Repository ) { // mock updates repo . ExpectUpdate (). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"discount\" , false )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) }) // run and asserts assert . Nil ( t , Example ( context . Background (), repo )) repo . AssertExpectations ( t ) } Other Examples \u00b6 gin-example - Todo Backend using Gin and REL go-todo-backend - Todo Backend using Chi and REL iris-example - Todo Backend using Iris and REL Conventions \u00b6 Schema Definition \u00b6 REL uses a struct as the schema to infer table name , columns and primary field . // Table name: books type Book struct { ID int // id Title string // title Category string // category CreatedAt time . Time // created_at UpdatedAt time . Time // updated_at } Table Name \u00b6 Table name will be the pluralized struct name in snake case, you may create a Table() string method to override the default table name. // Default table name is `books` type Book struct {} // Override table name to be `ebooks` func ( b Book ) Table () string { return \"ebooks\" } Column Name \u00b6 Column name will be the struct field name in snake case, you may override the column name by using db tag. type Book struct { ID int // this field will be mapped to `id` column. Title string `db:\"name\"` // this field will be mapped to `name` column. Category string `db:\"-\"` // this field will be skipped } Primary Key \u00b6 REL requires every struct to have at least primary key. by default field named id will be used as primary key. To use other field as primary key, you may define it as primary using db tag. Defining multiple field as primary will forms composite primary key. type Book struct { UUID string `db:\"uuid,primary\"` // or just `db:\",primary\"` } Timestamp \u00b6 REL automatically track created and updated time of each struct if CreatedAt or UpdatedAt field exists. Embedded structs \u00b6 REL supports embedding structs and struct pointers. By default, fields of embedded structs have no column name prefix. A prefix can be set with the db tag type Model struct { ID int Owner int } type Book struct { Model `db:\"model_\"` // id and owner will mapped to model_id and model_owner Title string }","title":"Basics"},{"location":"basics/#basics","text":"","title":"Basics"},{"location":"basics/#full-example","text":"Below is a very basic example on how to utilize REL using mysql adapter. Testing database query using REL can be done using reltest package. main.go package main import ( \"context\" \"time\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" _ \"github.com/go-sql-driver/mysql\" ) // Author is a model that maps to authors table. type Author struct { ID int Name string } // Book is a model that maps to books table. type Book struct { ID int Title string Category string Price int Discount bool Stock int AuthorID int Author Author Publisher string CreatedAt time . Time UpdatedAt time . Time } var dsn = \"root@(127.0.0.1:3306)/db?charset=utf8&parseTime=True&loc=Local\" func main () { // initialize mysql adapter. adapter , _ := mysql . Open ( dsn ) defer adapter . Close () // initialize rel's repo. repo := rel . New ( adapter ) // run Example ( context . Background (), repo ) } // Example is an actual service function that run a complex business package. // beware: it's actually doing nonsense here. func Example ( ctx context . Context , repo rel . Repository ) error { var book Book // Quickly find a book with id 1 using short alias. if err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )); err != nil { return err } // Or use chainable query builder. query := rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 ) if err := repo . Find ( ctx , & book , query ); err != nil { return err } // Convenient method to preload Book's Author. if err := repo . Preload ( ctx , & book , \"author\" ); err != nil { return err } // Performs updates inside a transaction. return repo . Transaction ( ctx , func ( ctx context . Context ) error { // basic update using struct. book . Title = \"REL for dummies\" repo . MustUpdate ( ctx , & book ) // update only specific fields. repo . MustUpdate ( ctx , & book , rel . Set ( \"discount\" , false )) // it even supports atomic inc/dec mutation. return repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) }) } main_test.go package main import ( \"context\" \"testing\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" \"github.com/go-rel/reltest\" \"github.com/stretchr/testify/assert\" ) func TestExample ( t * testing . T ) { // create a mocked repository. var ( repo = reltest . New () book = Book { ID : 1 , Title : \"Go for dummies\" , Category : \"learning\" , AuthorID : 1 , } author = Author { ID : 1 , Name : \"CZ2I28 Delta\" } ) // mock find and return result repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) // mock find and return result using query builder. repo . ExpectFind ( rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 )). Result ( book ) // mock preload and return result repo . ExpectPreload ( \"author\" ). ForType ( \"main.Book\" ). Result ( author ) // mocks transaction repo . ExpectTransaction ( func ( repo * reltest . Repository ) { // mock updates repo . ExpectUpdate (). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"discount\" , false )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) }) // run and asserts assert . Nil ( t , Example ( context . Background (), repo )) repo . AssertExpectations ( t ) }","title":"Full Example"},{"location":"basics/#other-examples","text":"gin-example - Todo Backend using Gin and REL go-todo-backend - Todo Backend using Chi and REL iris-example - Todo Backend using Iris and REL","title":"Other Examples"},{"location":"basics/#conventions","text":"","title":"Conventions"},{"location":"basics/#schema-definition","text":"REL uses a struct as the schema to infer table name , columns and primary field . // Table name: books type Book struct { ID int // id Title string // title Category string // category CreatedAt time . Time // created_at UpdatedAt time . Time // updated_at }","title":"Schema Definition"},{"location":"basics/#table-name","text":"Table name will be the pluralized struct name in snake case, you may create a Table() string method to override the default table name. // Default table name is `books` type Book struct {} // Override table name to be `ebooks` func ( b Book ) Table () string { return \"ebooks\" }","title":"Table Name"},{"location":"basics/#column-name","text":"Column name will be the struct field name in snake case, you may override the column name by using db tag. type Book struct { ID int // this field will be mapped to `id` column. Title string `db:\"name\"` // this field will be mapped to `name` column. Category string `db:\"-\"` // this field will be skipped }","title":"Column Name"},{"location":"basics/#primary-key","text":"REL requires every struct to have at least primary key. by default field named id will be used as primary key. To use other field as primary key, you may define it as primary using db tag. Defining multiple field as primary will forms composite primary key. type Book struct { UUID string `db:\"uuid,primary\"` // or just `db:\",primary\"` }","title":"Primary Key"},{"location":"basics/#timestamp","text":"REL automatically track created and updated time of each struct if CreatedAt or UpdatedAt field exists.","title":"Timestamp"},{"location":"basics/#embedded-structs","text":"REL supports embedding structs and struct pointers. By default, fields of embedded structs have no column name prefix. A prefix can be set with the db tag type Model struct { ID int Owner int } type Book struct { Model `db:\"model_\"` // id and owner will mapped to model_id and model_owner Title string }","title":"Embedded structs"},{"location":"crud/","text":"Reading and Writing Record \u00b6 Create \u00b6 A new record can be inserted to database using a struct, map or set function. To insert a new record using a struct, simply pass the pointer to the instance as the only argment. Insertion using struct will update created_at and updated_at field if any. Note reltest.Repository will automatically sets any primary key value to be 1. Inserting a record: Example book := Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, } // Insert directly using struct. err := repo . Insert ( ctx , & book ) Mock Any repo . ExpectInsert () Mock by Record repo . ExpectInsert (). For ( & Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, }) Mock by Type repo . ExpectInsert (). ForType ( \"main.Book\" ) Mock Error repo . ExpectInsert (). ForType ( \"main.Book\" ). Error ( errors . New ( \"oops\" )) To inserts multiple records at once, use InsertAll : Example books := [] Book { { Title : \"Golang for dummies\" , Category : \"education\" , }, { Title : \"Rel for dummies\" , Category : \"education\" , }, } err := repo . InsertAll ( ctx , & books ) Mock repo . ExpectInsertAll (). ForType ( \"[]main.Book\" ) Read \u00b6 REL provides a powerful API for querying record from database. To query a record, simply use the Find method, it accepts the returned result as the first argument, and the conditions for the rest arguments. Retrieve a book with id 1: Example var book Book err := repo . Find ( ctx , & book , rel . Eq ( \"id\" , 1 )) Mock book := Book { Title : \"Rel for dummies\" , Category : \"education\" , } repo . ExpectFind ( rel . Eq ( \"id\" , 1 )). Result ( book ) Retrieve a book with id 1 using syntactic sugar: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock repo . ExpectFind ( where . Eq ( \"id\" , 1 )). NotFound () Querying multiple records using FindAll method: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } repo . ExpectFindAll ( where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ). Result ( books ) Using chainable query api for a more complex query use case: Example var books [] Book query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) err := repo . FindAll ( ctx , & books , query ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) repo . ExpectFindAll ( query ). Result ( books ) Update \u00b6 Similar to create, updating a record in REL can also be done using struct, map or set function. Updating using struct will also update updated_at field if any. An update using struct will cause all fields and association to be saved to database, regardless of whether it's been updated or not. Use rel.Map , rel.Set or rel.Changeset to update only specific fields. Note When updating belongs to association, it's recommended to not expose reference key ( [other]_id ) for updates directly from user, since there's no way to validate belongs to association using query. Updating a record: Example book . Title = \"REL for dummies\" err := repo . Update ( ctx , & book ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Updating records is custom query: Example updatedCount , err := repo . UpdateAny ( ctx , rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Mock repo . ExpectUpdateAny ( rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Delete \u00b6 To delete a record in rel, simply pass the record to be deleted. Note REL will automatically apply soft-delete if DeletedAt *time.Time or Deleted bool field exists in a struct. DeletedAt needs to be pointer, otherwise it won't be able to save or store null value. To query soft-deleted records, use rel.Unscoped(true) when querying. Deleting a record: Example err := repo . Delete ( ctx , & book ) Mock repo . ExpectDelete (). For ( & book ) Deleting multiple record: Example err := repo . DeleteAll ( ctx , & books ) Mock repo . ExpectDeleteAll (). For ( & books ) Deleting records using custom query: Example deletedCount , err := repo . DeleteAny ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 ))) Mock repo . ExpectDeleteAny ( rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 )))","title":"Reading and Writing Record"},{"location":"crud/#reading-and-writing-record","text":"","title":"Reading and Writing Record"},{"location":"crud/#create","text":"A new record can be inserted to database using a struct, map or set function. To insert a new record using a struct, simply pass the pointer to the instance as the only argment. Insertion using struct will update created_at and updated_at field if any. Note reltest.Repository will automatically sets any primary key value to be 1. Inserting a record: Example book := Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, } // Insert directly using struct. err := repo . Insert ( ctx , & book ) Mock Any repo . ExpectInsert () Mock by Record repo . ExpectInsert (). For ( & Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, }) Mock by Type repo . ExpectInsert (). ForType ( \"main.Book\" ) Mock Error repo . ExpectInsert (). ForType ( \"main.Book\" ). Error ( errors . New ( \"oops\" )) To inserts multiple records at once, use InsertAll : Example books := [] Book { { Title : \"Golang for dummies\" , Category : \"education\" , }, { Title : \"Rel for dummies\" , Category : \"education\" , }, } err := repo . InsertAll ( ctx , & books ) Mock repo . ExpectInsertAll (). ForType ( \"[]main.Book\" )","title":"Create"},{"location":"crud/#read","text":"REL provides a powerful API for querying record from database. To query a record, simply use the Find method, it accepts the returned result as the first argument, and the conditions for the rest arguments. Retrieve a book with id 1: Example var book Book err := repo . Find ( ctx , & book , rel . Eq ( \"id\" , 1 )) Mock book := Book { Title : \"Rel for dummies\" , Category : \"education\" , } repo . ExpectFind ( rel . Eq ( \"id\" , 1 )). Result ( book ) Retrieve a book with id 1 using syntactic sugar: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock repo . ExpectFind ( where . Eq ( \"id\" , 1 )). NotFound () Querying multiple records using FindAll method: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } repo . ExpectFindAll ( where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ). Result ( books ) Using chainable query api for a more complex query use case: Example var books [] Book query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) err := repo . FindAll ( ctx , & books , query ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) repo . ExpectFindAll ( query ). Result ( books )","title":"Read"},{"location":"crud/#update","text":"Similar to create, updating a record in REL can also be done using struct, map or set function. Updating using struct will also update updated_at field if any. An update using struct will cause all fields and association to be saved to database, regardless of whether it's been updated or not. Use rel.Map , rel.Set or rel.Changeset to update only specific fields. Note When updating belongs to association, it's recommended to not expose reference key ( [other]_id ) for updates directly from user, since there's no way to validate belongs to association using query. Updating a record: Example book . Title = \"REL for dummies\" err := repo . Update ( ctx , & book ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Updating records is custom query: Example updatedCount , err := repo . UpdateAny ( ctx , rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Mock repo . ExpectUpdateAny ( rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true ))","title":"Update"},{"location":"crud/#delete","text":"To delete a record in rel, simply pass the record to be deleted. Note REL will automatically apply soft-delete if DeletedAt *time.Time or Deleted bool field exists in a struct. DeletedAt needs to be pointer, otherwise it won't be able to save or store null value. To query soft-deleted records, use rel.Unscoped(true) when querying. Deleting a record: Example err := repo . Delete ( ctx , & book ) Mock repo . ExpectDelete (). For ( & book ) Deleting multiple record: Example err := repo . DeleteAll ( ctx , & books ) Mock repo . ExpectDeleteAll (). For ( & books ) Deleting records using custom query: Example deletedCount , err := repo . DeleteAny ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 ))) Mock repo . ExpectDeleteAny ( rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 )))","title":"Delete"},{"location":"instrumentation/","text":"Instrumentation \u00b6 REL provides hooks that can be used to log or instrument your queries. repo . Instrumentation ( func ( ctx context . Context , op string , message string ) func ( err error ) { t := time . Now () return func ( err error ) { duration := time . Since ( t ) log . Print ( \"[duration: \" , duration , \" op: \" , op , \"] \" , message , \" - \" , err ) } }) This is the list for available operations: rel-aggregate rel-count rel-find rel-find-all rel-find-and-count-all rel-scan-one rel-scan-all rel-scan-multi rel-insert rel-insert-all rel-update rel-delete rel-delete-any rel-preload rel-transaction adapter-aggregate adapter-query adapter-exec adapter-begin adapter-commit adapter-rollback","title":"Instrumentation"},{"location":"instrumentation/#instrumentation","text":"REL provides hooks that can be used to log or instrument your queries. repo . Instrumentation ( func ( ctx context . Context , op string , message string ) func ( err error ) { t := time . Now () return func ( err error ) { duration := time . Since ( t ) log . Print ( \"[duration: \" , duration , \" op: \" , op , \"] \" , message , \" - \" , err ) } }) This is the list for available operations: rel-aggregate rel-count rel-find rel-find-all rel-find-and-count-all rel-scan-one rel-scan-all rel-scan-multi rel-insert rel-insert-all rel-update rel-delete rel-delete-any rel-preload rel-transaction adapter-aggregate adapter-query adapter-exec adapter-begin adapter-commit adapter-rollback","title":"Instrumentation"},{"location":"introduction/","text":"Introduction \u00b6 REL is golang orm-ish database layer for layered architecture. It's testable and comes with it's own test library. REL also features extendable query builder that allows you to write query using builder or plain sql. Features \u00b6 Testable repository with builtin reltest package. Seamless nested transactions. Elegant, yet extendable query builder with mix of syntactic sugar. Supports Eager loading. Composite Primary Key. Multi adapter. Soft Deletion. Pagination. Schema Migration. Install \u00b6 go get github.com/go-rel/rel Why rel \u00b6 Easy to test \u00b6 Most (if not all) orm for golang is written as a chainable API, meaning all of the query need to be called before performing actual action as a chain of method invocations. example: db . Where ( \"id = ?\" , 1 ). First ( & user ) Chainable api is very hard to be unit tested without writing a wrapper. One way to make it testable is to make an interface that also acts as a wrapper, which is usually ends up as its own repository package resides somewhere in your project: // mockable interface. type UserRepository interface { Find ( user * User , id int ) error } // actual implementation type userRepository struct { db * DB } func ( ur userRepository ) Find ( user * User , id int ) error { return db . Where ( \"id = ?\" , 1 ). First ( & user ) } Compared to other orm, REL api is built with testability in mind. REL uses interface to define contract of every database query or execution, all while making a chainable query possible. The ultimate goal of REL is to be your database package without the needs of making your own wrapper. Seamless transactions \u00b6 When starting a transaction using builtin database/sql package or other orm, special transaction instance that's similar to non-transaction instance is returned, and all execution needs to be called using that instance to be in transaction: // start transaction tx := db . Begin () // do some database operations in the transaction (use 'tx' from this point, not 'db') tx . Create ( ... ) // Or commit the transaction tx . Commit () Now what happens if you want to introduce a shared function, that might execute it's operation on a transaction or on a regular connection depending on the caller? you may end up with a function that may not only accepts conventional context argument, but also a tx or connection argument. tx := db . Begin () tx . Create ( ... ) // UpdateOtherEntity(txOrDb TxOrDbInterface, ...) UpdateOtherEntity ( tx , ... ) tx . Commit () REL attempts to solve that problem by managing transaction state using context, the REL repository can decide whether to use transaction or not based on provided context, performs commit or rollback in case of exception, and even supports nested transaction (see: transactions ).","title":"Introduction"},{"location":"introduction/#introduction","text":"REL is golang orm-ish database layer for layered architecture. It's testable and comes with it's own test library. REL also features extendable query builder that allows you to write query using builder or plain sql.","title":"Introduction"},{"location":"introduction/#features","text":"Testable repository with builtin reltest package. Seamless nested transactions. Elegant, yet extendable query builder with mix of syntactic sugar. Supports Eager loading. Composite Primary Key. Multi adapter. Soft Deletion. Pagination. Schema Migration.","title":"Features"},{"location":"introduction/#install","text":"go get github.com/go-rel/rel","title":"Install"},{"location":"introduction/#why-rel","text":"","title":"Why rel"},{"location":"introduction/#easy-to-test","text":"Most (if not all) orm for golang is written as a chainable API, meaning all of the query need to be called before performing actual action as a chain of method invocations. example: db . Where ( \"id = ?\" , 1 ). First ( & user ) Chainable api is very hard to be unit tested without writing a wrapper. One way to make it testable is to make an interface that also acts as a wrapper, which is usually ends up as its own repository package resides somewhere in your project: // mockable interface. type UserRepository interface { Find ( user * User , id int ) error } // actual implementation type userRepository struct { db * DB } func ( ur userRepository ) Find ( user * User , id int ) error { return db . Where ( \"id = ?\" , 1 ). First ( & user ) } Compared to other orm, REL api is built with testability in mind. REL uses interface to define contract of every database query or execution, all while making a chainable query possible. The ultimate goal of REL is to be your database package without the needs of making your own wrapper.","title":"Easy to test"},{"location":"introduction/#seamless-transactions","text":"When starting a transaction using builtin database/sql package or other orm, special transaction instance that's similar to non-transaction instance is returned, and all execution needs to be called using that instance to be in transaction: // start transaction tx := db . Begin () // do some database operations in the transaction (use 'tx' from this point, not 'db') tx . Create ( ... ) // Or commit the transaction tx . Commit () Now what happens if you want to introduce a shared function, that might execute it's operation on a transaction or on a regular connection depending on the caller? you may end up with a function that may not only accepts conventional context argument, but also a tx or connection argument. tx := db . Begin () tx . Create ( ... ) // UpdateOtherEntity(txOrDb TxOrDbInterface, ...) UpdateOtherEntity ( tx , ... ) tx . Commit () REL attempts to solve that problem by managing transaction state using context, the REL repository can decide whether to use transaction or not based on provided context, performs commit or rollback in case of exception, and even supports nested transaction (see: transactions ).","title":"Seamless transactions"},{"location":"migration/","text":"Migration \u00b6 Overview \u00b6 Migration is a feature that allows you to evolve your database schema over time, REL provides DSL that allows you to write migration in Golang. Defining Migration \u00b6 Migration package usually located inside your-repo/db/migrations package. It's a standalone package that should not be imported by the rest of your application. Each migration file is named as number_name.go , and each migration file must define a pair of migration and rollback functions: MigrateName and RollbackName . Migrate and rollback function name is the camel cased file name without version. Note Sample project that demonstrate this setup can be found at go-rel/gin-example // 20202806225100_create_todos.go package migrations import ( \"context\" \"github.com/go-rel/rel\" ) // MigrateCreateTodos definition func MigrateCreateTodos ( schema * rel . Schema ) { schema . CreateTable ( \"todos\" , func ( t * rel . Table ) { t . ID ( \"id\" ) t . DateTime ( \"created_at\" ) t . DateTime ( \"updated_at\" ) t . String ( \"title\" ) t . Bool ( \"completed\" ) t . Int ( \"order\" ) }) schema . CreateIndex ( \"todos\" , \"order\" , [] string { \"order\" }) schema . Do ( func ( repo rel . Repository ) error { // add seeds return repo . Insert ( context . TODO (), & Todo { Title : \"Do homework\" }) }) } // RollbackCreateTodos definition func RollbackCreateTodos ( schema * rel . Schema ) { schema . DropTable ( \"todos\" ) } Running Migration \u00b6 REL provides CLI that can be used to run your migration, it can be installed using homebrew , go get or downloaded from release page . Install using homebrew: brew tap go-rel/tap brew install rel Or, Install using go get: go get github.com/go-rel/rel/cmd/rel Verify installation: rel -version Migrate to the latest version: rel migrate Rollback one migration step: rel rollback Configuring Database Connection \u00b6 By default, REL will try to use database connection info that available as environment variable. Variable Description DATABASE_URL Database connection string (Optional) DATABASE_ADAPTER Adapter package (Required if DATABASE_URL specified) DATABASE_DRIVER Driver package (Required if DATABASE_URL specified) MYSQL_HOST MySQL host (Optional) MYSQL_PORT MySQL port (Optional) MYSQL_DATABASE MySQL database (Required, if MYSQL_HOST specified) MYSQL_USERNAME MySQL host (Required, if MYSQL_HOST specified) MYSQL_PASSWORD MySQL host (Optional) POSTGRES_HOST PostgreSQL host (Optional) POSTGRES_PORT PostgreSQL port (Optional) POSTGRES_DATABASE PostgreSQL database (Required, if POSTGRES_HOST specified) POSTGRES_USERNAME PostgreSQL username (Required, if POSTGRES_HOST specified) POSTGRES_PASSWORD PostgreSQL password (Optional) SQLITE3_DATABASE SQLite3 database (Optional) Database connection info can also be specified using command line options: dsn , adapter and driver : rel migrate -adapter = github.com/go-rel/rel/adapter/sqlite3 -driver = github.com/mattn/go-sqlite3 -dsn = :memory: Migration API \u00b6 If you need more flexibility, migration API can be used to manually execute migrations. package main import ( \"context\" \"github.com/go-rel/doc/examples/db/migrations\" \"github.com/go-rel/migration\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" _ \"github.com/go-sql-driver/mysql\" ) func main () { var ( ctx = context . TODO () repo = rel . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" )) m = migration . New ( repo ) ) // Register migrations m . Register ( 20202806225100 , migrations . MigrateCreateTodos , migrations . RollbackCreateTodos ) // Run migrations m . Migrate ( ctx ) // OR: // m.Rollback(ctx) }","title":"Migration"},{"location":"migration/#migration","text":"","title":"Migration"},{"location":"migration/#overview","text":"Migration is a feature that allows you to evolve your database schema over time, REL provides DSL that allows you to write migration in Golang.","title":"Overview"},{"location":"migration/#defining-migration","text":"Migration package usually located inside your-repo/db/migrations package. It's a standalone package that should not be imported by the rest of your application. Each migration file is named as number_name.go , and each migration file must define a pair of migration and rollback functions: MigrateName and RollbackName . Migrate and rollback function name is the camel cased file name without version. Note Sample project that demonstrate this setup can be found at go-rel/gin-example // 20202806225100_create_todos.go package migrations import ( \"context\" \"github.com/go-rel/rel\" ) // MigrateCreateTodos definition func MigrateCreateTodos ( schema * rel . Schema ) { schema . CreateTable ( \"todos\" , func ( t * rel . Table ) { t . ID ( \"id\" ) t . DateTime ( \"created_at\" ) t . DateTime ( \"updated_at\" ) t . String ( \"title\" ) t . Bool ( \"completed\" ) t . Int ( \"order\" ) }) schema . CreateIndex ( \"todos\" , \"order\" , [] string { \"order\" }) schema . Do ( func ( repo rel . Repository ) error { // add seeds return repo . Insert ( context . TODO (), & Todo { Title : \"Do homework\" }) }) } // RollbackCreateTodos definition func RollbackCreateTodos ( schema * rel . Schema ) { schema . DropTable ( \"todos\" ) }","title":"Defining Migration"},{"location":"migration/#running-migration","text":"REL provides CLI that can be used to run your migration, it can be installed using homebrew , go get or downloaded from release page . Install using homebrew: brew tap go-rel/tap brew install rel Or, Install using go get: go get github.com/go-rel/rel/cmd/rel Verify installation: rel -version Migrate to the latest version: rel migrate Rollback one migration step: rel rollback","title":"Running Migration"},{"location":"migration/#configuring-database-connection","text":"By default, REL will try to use database connection info that available as environment variable. Variable Description DATABASE_URL Database connection string (Optional) DATABASE_ADAPTER Adapter package (Required if DATABASE_URL specified) DATABASE_DRIVER Driver package (Required if DATABASE_URL specified) MYSQL_HOST MySQL host (Optional) MYSQL_PORT MySQL port (Optional) MYSQL_DATABASE MySQL database (Required, if MYSQL_HOST specified) MYSQL_USERNAME MySQL host (Required, if MYSQL_HOST specified) MYSQL_PASSWORD MySQL host (Optional) POSTGRES_HOST PostgreSQL host (Optional) POSTGRES_PORT PostgreSQL port (Optional) POSTGRES_DATABASE PostgreSQL database (Required, if POSTGRES_HOST specified) POSTGRES_USERNAME PostgreSQL username (Required, if POSTGRES_HOST specified) POSTGRES_PASSWORD PostgreSQL password (Optional) SQLITE3_DATABASE SQLite3 database (Optional) Database connection info can also be specified using command line options: dsn , adapter and driver : rel migrate -adapter = github.com/go-rel/rel/adapter/sqlite3 -driver = github.com/mattn/go-sqlite3 -dsn = :memory:","title":"Configuring Database Connection"},{"location":"migration/#migration-api","text":"If you need more flexibility, migration API can be used to manually execute migrations. package main import ( \"context\" \"github.com/go-rel/doc/examples/db/migrations\" \"github.com/go-rel/migration\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" _ \"github.com/go-sql-driver/mysql\" ) func main () { var ( ctx = context . TODO () repo = rel . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" )) m = migration . New ( repo ) ) // Register migrations m . Register ( 20202806225100 , migrations . MigrateCreateTodos , migrations . RollbackCreateTodos ) // Run migrations m . Migrate ( ctx ) // OR: // m.Rollback(ctx) }","title":"Migration API"},{"location":"mutations/","text":"Mutations \u00b6 Basic Mutator \u00b6 REL uses mutator to define inserts and updates operation. Using basic mutator won't update created_at and updated_at fields. Mutator Description Dec(field string) Decrement a field value by 1 DecBy(field string, n int) Decrement a field value by n Inc(field string) Increase a field value by 1 IncBy(field string, n int) Increase a field value by n Set(field string, value interface{}) Set a value to a field SetFragment(raw string, args ...interface{}) Set a value of a field using SQL fragment Set title and category values: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ). For ( & book ) Decrement stock: Example err := repo . Update ( ctx , & book , rel . DecBy ( \"stock\" , 2 )) Mock repo . ExpectUpdate ( rel . DecBy ( \"stock\" , 2 )). For ( & book ) Update title using SQL fragment: Example err := repo . Update ( ctx , & book , rel . SetFragment ( \"title=?\" , \"REL for dummies\" )) Mock repo . ExpectUpdate ( rel . SetFragment ( \"title=?\" , \"REL for dummies\" )). For ( & book ) Structset \u00b6 Structset is a mutator that generates list of Set mutators based on a struct value. Using Structset will result in replacing the intire record in the database using provided struct, It'll always clear a has many association and re-insert it on updates if it's loaded. Changeset can be used to avoid clearing has many association on updates. Note Structset is the default mutator used when none is provided explicitly. Inserting a struct using structset mutator: Example structset := rel . NewStructset ( & book , false ) err := repo . Insert ( ctx , & book , structset ) Mock repo . ExpectInsert (). For ( & book ) Changeset \u00b6 Changeset allows you to track and update only updated values and asssociation to database. This is very efficient when dealing with a complex struct that contains a lot of fields and associations. Update only price and discount field using changeset: Example changeset := rel . NewChangeset ( & book ) book . Price = 10 if changeset . FieldChanged ( \"price\" ) { book . Discount = false } err := repo . Update ( ctx , & book , changeset ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Map \u00b6 Map allows to define group of Set mutator, this is intended to be use internally and not to be exposed directly to user. Mutation defined in the map will be applied to the struct passed as the first argument. Insert/Update using map wont update created_at or updated_at field. Insert books and its author using Map : Example data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } // Insert using map. err := repo . Insert ( ctx , & book , data ) Mock data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } repo . ExpectInsert ( data ). ForType ( \"main.Book\" ) Reloading Updated Struct \u00b6 By default, only Inc , IncBy , Dec , DecBy and SetFragment will reload struct from database, Reload mutator can be used to manually trigger reload after inserts/update operations. Update title and force reload: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ). For ( & book ) Cascade Operations \u00b6 REL supports insert/update/delete record and it's associations. Disable cascade insert (default enabled): Example err := repo . Insert ( ctx , & book , rel . Cascade ( false )) Mock repo . ExpectInsert ( rel . Cascade ( false )). For ( & book ) Enable cascade delete (default disabled): Example err := repo . Delete ( ctx , & book , rel . Cascade ( true )) Mock repo . ExpectDelete ( rel . Cascade ( true )). For ( & book )","title":"Mutations"},{"location":"mutations/#mutations","text":"","title":"Mutations"},{"location":"mutations/#basic-mutator","text":"REL uses mutator to define inserts and updates operation. Using basic mutator won't update created_at and updated_at fields. Mutator Description Dec(field string) Decrement a field value by 1 DecBy(field string, n int) Decrement a field value by n Inc(field string) Increase a field value by 1 IncBy(field string, n int) Increase a field value by n Set(field string, value interface{}) Set a value to a field SetFragment(raw string, args ...interface{}) Set a value of a field using SQL fragment Set title and category values: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ). For ( & book ) Decrement stock: Example err := repo . Update ( ctx , & book , rel . DecBy ( \"stock\" , 2 )) Mock repo . ExpectUpdate ( rel . DecBy ( \"stock\" , 2 )). For ( & book ) Update title using SQL fragment: Example err := repo . Update ( ctx , & book , rel . SetFragment ( \"title=?\" , \"REL for dummies\" )) Mock repo . ExpectUpdate ( rel . SetFragment ( \"title=?\" , \"REL for dummies\" )). For ( & book )","title":"Basic Mutator"},{"location":"mutations/#structset","text":"Structset is a mutator that generates list of Set mutators based on a struct value. Using Structset will result in replacing the intire record in the database using provided struct, It'll always clear a has many association and re-insert it on updates if it's loaded. Changeset can be used to avoid clearing has many association on updates. Note Structset is the default mutator used when none is provided explicitly. Inserting a struct using structset mutator: Example structset := rel . NewStructset ( & book , false ) err := repo . Insert ( ctx , & book , structset ) Mock repo . ExpectInsert (). For ( & book )","title":"Structset"},{"location":"mutations/#changeset","text":"Changeset allows you to track and update only updated values and asssociation to database. This is very efficient when dealing with a complex struct that contains a lot of fields and associations. Update only price and discount field using changeset: Example changeset := rel . NewChangeset ( & book ) book . Price = 10 if changeset . FieldChanged ( \"price\" ) { book . Discount = false } err := repo . Update ( ctx , & book , changeset ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" )","title":"Changeset"},{"location":"mutations/#map","text":"Map allows to define group of Set mutator, this is intended to be use internally and not to be exposed directly to user. Mutation defined in the map will be applied to the struct passed as the first argument. Insert/Update using map wont update created_at or updated_at field. Insert books and its author using Map : Example data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } // Insert using map. err := repo . Insert ( ctx , & book , data ) Mock data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } repo . ExpectInsert ( data ). ForType ( \"main.Book\" )","title":"Map"},{"location":"mutations/#reloading-updated-struct","text":"By default, only Inc , IncBy , Dec , DecBy and SetFragment will reload struct from database, Reload mutator can be used to manually trigger reload after inserts/update operations. Update title and force reload: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ). For ( & book )","title":"Reloading Updated Struct"},{"location":"mutations/#cascade-operations","text":"REL supports insert/update/delete record and it's associations. Disable cascade insert (default enabled): Example err := repo . Insert ( ctx , & book , rel . Cascade ( false )) Mock repo . ExpectInsert ( rel . Cascade ( false )). For ( & book ) Enable cascade delete (default disabled): Example err := repo . Delete ( ctx , & book , rel . Cascade ( true )) Mock repo . ExpectDelete ( rel . Cascade ( true )). For ( & book )","title":"Cascade Operations"},{"location":"queries/","text":"Queries \u00b6 Retrieving Data \u00b6 REL provides two basic finders method, Find for retrieving single record, and FindAll for retrieving multiple record. Note Find only accepts struct as the first argument, and always return the first result from the query. FindAll only accepts slice as the first argument, and always return all result from the query. Retrieve a book where id=1: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock book := Book { ID : 1 , Title : \"REL for dummies\" } repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) Retrieve all books: Example var books [] Book err := repo . FindAll ( ctx , & books ) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll (). Result ( books ) Conditions \u00b6 To retrieve filtered recods from database, you can use filter api to specify condition . For example, to filter all books that available, you can use rel.Eq in the query builder. Retrieve all available books using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true )). Result ( books ) Alias can be used to boost readability when dealing with short query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true )). Result ( books ) Use fragment to specify custom SQL query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Fragment ( \"available=?\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Fragment ( \"available=?\" , true )). Result ( books ) You can use rel.And or rel.Or to specify more conditions. Retrieve all available books where price is at least 100 or in discount using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using chained filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using alias ( github.com/go-rel/rel/where ): Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Subquery \u00b6 Subquery is supported in condition clause, you can pass any query to the where/having parameter. Retrieve all books that is cheaper than average book price: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))). Result ( books ) Sorting \u00b6 To retrieve records from database in a specific order, you can use the sort api. Sort books ascending by updated_at field: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . NewSortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . NewSortAsc ( \"updated_at\" )). Result ( books ) Using alias if you need more syntactic sugar: Example var books [] Book err := repo . FindAll ( ctx , & books , sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( sort . Asc ( \"updated_at\" )). Result ( books ) Combining with other query is fairly easy. Chain where and sort using query builder: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )). Result ( books ) It's also possible to use variadic arguments to combine multiple queries: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )). Result ( books ) Selecting Specific Fields \u00b6 To select specific fields, you can use Select method, this way only specificied field will be mapped to books. Note Specifying select without argument ( rel.Select() ) will automatically load all fields. This is helpful when used as query builder entry point (compared to using rel.From ), because you can let REL to infer the table name. Load only id and title: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" )). Result ( books ) Using Specific Table \u00b6 By default, REL will use pluralized-snakecase struct name as the table name. To select from specific table, you can use From method. Load from ebooks table: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . From ( \"ebooks\" )). Result ( books ) Chain the query with select: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )). Result ( books ) Limit and Offset \u00b6 To set the limit and offset of query, use Limit and Offset api. Offset will be ignored if Limit is not specified. Specify limit and offset: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Limit ( 10 ), rel . Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Limit ( 10 ), rel . Offset ( 20 )). Result ( books ) As a chainable api: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select (). Limit ( 10 ). Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select (). Limit ( 10 ). Offset ( 20 )). Result ( books ) Group \u00b6 To use group by query, you can use Group method. Retrieve count of books for every category: Example // custom struct to store the result. var results [] struct { Category string Total int } // we need to explicitly specify table name since we are using an anonymous struct. err := repo . FindAll ( ctx , & results , rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )) Mock results := [] struct { Category string Total int }{ { Category : \"education\" , Total : 100 }, } repo . ExpectFindAll ( rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )). Result ( results ) Joining Tables \u00b6 To join tables, you can use join api. Note Joining table won't load the association to struct. If you want to load association on a struct, use preload instead. Join transaction and book table, then filter only transaction that have specified book name. This methods assumes belongs to relation, which means it'll try to join using transactions.book_id=books.id : Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))). Result ( transactions ) Specifying which column to join using JoinOn: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Syntactic sugar also available for join: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Joining table with custom join mode: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Use fragment for more complex join query: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )). Result ( transactions ) Pessimistic Locking \u00b6 REL supports pessimistic locking by using mechanism provided by the underlying database. Lock can be only used only inside transaction. Retrieve and lock a row for update: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )). Result ( book ) Retrieve and lock a row using predefined lock alias: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . ForUpdate ()) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . ForUpdate ()). Result ( book ) Retrieve and lock a row using chained query: Example var book Book err := repo . Find ( ctx , & book , rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )). Result ( book ) Aggregation \u00b6 REL provides a very basic Aggregate method which can be used to count, sum, max etc. Count all available books using aggregate: Example count , err := repo . Aggregate ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ) Mock repo . ExpectAggregate ( rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ). Result ( 5 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" ) Mock repo . ExpectCount ( \"books\" ). Result ( 7 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" , where . Eq ( \"available\" , true )) Mock repo . ExpectCount ( \"books\" , where . Eq ( \"available\" , true )). Result ( 5 ) Pagination \u00b6 REL provides a convenient FindAndCountAll methods that is useful for pagination, It's a combination of FindAll and Count method. FindAndCountAll returns count of records (ignoring limit and offset query) and an error. Retrieve all books within limit and offset and also count of all books: Example var books [] Book count , err := repo . FindAndCountAll ( ctx , & books , rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAndCountAll ( rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )). Result ( books , 12 ) Batch Iteration \u00b6 REL provides records iterator that can be use for perform batch processing of large amounts of records. Options: BatchSize - The size of batches (default 1000). Start - The primary value (ID) to start from (inclusive). Finish - The primary value (ID) to finish at (inclusive). Example var ( user User iter = repo . Iterate ( ctx , rel . From ( \"users\" ), rel . BatchSize ( 500 )) ) // make sure iterator is closed after process is finish. defer iter . Close () for { // retrieve next user. if err := iter . Next ( & user ); err != nil { if err == io . EOF { break } // handle error return err } // process user SendPromotionEmail ( & user ) } Mock users := make ([] User , 5 ) repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). Result ( users ) Mock Error repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). ConnectionClosed () Native SQL Query \u00b6 REL allows querying using native SQL query, this is especially useful when using complex query that cannot be covered with the query builder. Retrieve a book using native sql query: Example var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) err := repo . Find ( ctx , & book , sql ) Mock var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) repo . ExpectFind ( sql ). Result ( book )","title":"Queries"},{"location":"queries/#queries","text":"","title":"Queries"},{"location":"queries/#retrieving-data","text":"REL provides two basic finders method, Find for retrieving single record, and FindAll for retrieving multiple record. Note Find only accepts struct as the first argument, and always return the first result from the query. FindAll only accepts slice as the first argument, and always return all result from the query. Retrieve a book where id=1: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock book := Book { ID : 1 , Title : \"REL for dummies\" } repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) Retrieve all books: Example var books [] Book err := repo . FindAll ( ctx , & books ) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll (). Result ( books )","title":"Retrieving Data"},{"location":"queries/#conditions","text":"To retrieve filtered recods from database, you can use filter api to specify condition . For example, to filter all books that available, you can use rel.Eq in the query builder. Retrieve all available books using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true )). Result ( books ) Alias can be used to boost readability when dealing with short query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true )). Result ( books ) Use fragment to specify custom SQL query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Fragment ( \"available=?\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Fragment ( \"available=?\" , true )). Result ( books ) You can use rel.And or rel.Or to specify more conditions. Retrieve all available books where price is at least 100 or in discount using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using chained filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using alias ( github.com/go-rel/rel/where ): Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books )","title":"Conditions"},{"location":"queries/#subquery","text":"Subquery is supported in condition clause, you can pass any query to the where/having parameter. Retrieve all books that is cheaper than average book price: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))). Result ( books )","title":"Subquery"},{"location":"queries/#sorting","text":"To retrieve records from database in a specific order, you can use the sort api. Sort books ascending by updated_at field: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . NewSortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . NewSortAsc ( \"updated_at\" )). Result ( books ) Using alias if you need more syntactic sugar: Example var books [] Book err := repo . FindAll ( ctx , & books , sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( sort . Asc ( \"updated_at\" )). Result ( books ) Combining with other query is fairly easy. Chain where and sort using query builder: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )). Result ( books ) It's also possible to use variadic arguments to combine multiple queries: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )). Result ( books )","title":"Sorting"},{"location":"queries/#selecting-specific-fields","text":"To select specific fields, you can use Select method, this way only specificied field will be mapped to books. Note Specifying select without argument ( rel.Select() ) will automatically load all fields. This is helpful when used as query builder entry point (compared to using rel.From ), because you can let REL to infer the table name. Load only id and title: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" )). Result ( books )","title":"Selecting Specific Fields"},{"location":"queries/#using-specific-table","text":"By default, REL will use pluralized-snakecase struct name as the table name. To select from specific table, you can use From method. Load from ebooks table: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . From ( \"ebooks\" )). Result ( books ) Chain the query with select: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )). Result ( books )","title":"Using Specific Table"},{"location":"queries/#limit-and-offset","text":"To set the limit and offset of query, use Limit and Offset api. Offset will be ignored if Limit is not specified. Specify limit and offset: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Limit ( 10 ), rel . Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Limit ( 10 ), rel . Offset ( 20 )). Result ( books ) As a chainable api: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select (). Limit ( 10 ). Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select (). Limit ( 10 ). Offset ( 20 )). Result ( books )","title":"Limit and Offset"},{"location":"queries/#group","text":"To use group by query, you can use Group method. Retrieve count of books for every category: Example // custom struct to store the result. var results [] struct { Category string Total int } // we need to explicitly specify table name since we are using an anonymous struct. err := repo . FindAll ( ctx , & results , rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )) Mock results := [] struct { Category string Total int }{ { Category : \"education\" , Total : 100 }, } repo . ExpectFindAll ( rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )). Result ( results )","title":"Group"},{"location":"queries/#joining-tables","text":"To join tables, you can use join api. Note Joining table won't load the association to struct. If you want to load association on a struct, use preload instead. Join transaction and book table, then filter only transaction that have specified book name. This methods assumes belongs to relation, which means it'll try to join using transactions.book_id=books.id : Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))). Result ( transactions ) Specifying which column to join using JoinOn: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Syntactic sugar also available for join: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Joining table with custom join mode: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Use fragment for more complex join query: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )). Result ( transactions )","title":"Joining Tables"},{"location":"queries/#pessimistic-locking","text":"REL supports pessimistic locking by using mechanism provided by the underlying database. Lock can be only used only inside transaction. Retrieve and lock a row for update: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )). Result ( book ) Retrieve and lock a row using predefined lock alias: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . ForUpdate ()) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . ForUpdate ()). Result ( book ) Retrieve and lock a row using chained query: Example var book Book err := repo . Find ( ctx , & book , rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )). Result ( book )","title":"Pessimistic Locking"},{"location":"queries/#aggregation","text":"REL provides a very basic Aggregate method which can be used to count, sum, max etc. Count all available books using aggregate: Example count , err := repo . Aggregate ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ) Mock repo . ExpectAggregate ( rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ). Result ( 5 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" ) Mock repo . ExpectCount ( \"books\" ). Result ( 7 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" , where . Eq ( \"available\" , true )) Mock repo . ExpectCount ( \"books\" , where . Eq ( \"available\" , true )). Result ( 5 )","title":"Aggregation"},{"location":"queries/#pagination","text":"REL provides a convenient FindAndCountAll methods that is useful for pagination, It's a combination of FindAll and Count method. FindAndCountAll returns count of records (ignoring limit and offset query) and an error. Retrieve all books within limit and offset and also count of all books: Example var books [] Book count , err := repo . FindAndCountAll ( ctx , & books , rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAndCountAll ( rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )). Result ( books , 12 )","title":"Pagination"},{"location":"queries/#batch-iteration","text":"REL provides records iterator that can be use for perform batch processing of large amounts of records. Options: BatchSize - The size of batches (default 1000). Start - The primary value (ID) to start from (inclusive). Finish - The primary value (ID) to finish at (inclusive). Example var ( user User iter = repo . Iterate ( ctx , rel . From ( \"users\" ), rel . BatchSize ( 500 )) ) // make sure iterator is closed after process is finish. defer iter . Close () for { // retrieve next user. if err := iter . Next ( & user ); err != nil { if err == io . EOF { break } // handle error return err } // process user SendPromotionEmail ( & user ) } Mock users := make ([] User , 5 ) repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). Result ( users ) Mock Error repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). ConnectionClosed ()","title":"Batch Iteration"},{"location":"queries/#native-sql-query","text":"REL allows querying using native SQL query, this is especially useful when using complex query that cannot be covered with the query builder. Retrieve a book using native sql query: Example var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) err := repo . Find ( ctx , & book , sql ) Mock var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) repo . ExpectFind ( sql ). Result ( book )","title":"Native SQL Query"},{"location":"transactions/","text":"Transactions \u00b6 To declare a transaction, use the Transaction method which can be called recursively to define nested transactions. Rel accepts a function with context.Context argument that is used to determine the transaction scope. Context makes it easier to call any function that involves db operation inside a transaction, because the scope of transaction is automatically passed by context. If any error occured within transaction, the transaction will be rolled back, and returns the error. If the error is a runtime error or panic with string argument, it'll panic after rollback. Example err := repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) // Any database calls inside other function will be using the same transaction as long as it share the same context. Process ( ctx , transaction ) // Nested transaction repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . UpdateAny ( ctx , rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , book . AuthorID )), rel . Inc ( \"popularity\" )) repo . UpdateAny ( ctx , rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , book . Publisher )), rel . Inc ( \"popularity\" )) return nil }) return repo . Update ( ctx , & transaction , rel . Set ( \"status\" , \"paid\" )) }) Mock repo . ExpectTransaction ( func ( repo * reltest . Repository ) { repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) // mock process repo . ExpectTransaction ( func ( r * reltest . Repository ) { repo . ExpectUpdateAny ( rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , 0 )), rel . Inc ( \"popularity\" )) repo . ExpectUpdateAny ( rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , \"\" )), rel . Inc ( \"popularity\" )) }) repo . ExpectUpdate ( rel . Set ( \"status\" , \"paid\" )). ForType ( \"main.Transaction\" ) })","title":"Transactions"},{"location":"transactions/#transactions","text":"To declare a transaction, use the Transaction method which can be called recursively to define nested transactions. Rel accepts a function with context.Context argument that is used to determine the transaction scope. Context makes it easier to call any function that involves db operation inside a transaction, because the scope of transaction is automatically passed by context. If any error occured within transaction, the transaction will be rolled back, and returns the error. If the error is a runtime error or panic with string argument, it'll panic after rollback. Example err := repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) // Any database calls inside other function will be using the same transaction as long as it share the same context. Process ( ctx , transaction ) // Nested transaction repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . UpdateAny ( ctx , rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , book . AuthorID )), rel . Inc ( \"popularity\" )) repo . UpdateAny ( ctx , rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , book . Publisher )), rel . Inc ( \"popularity\" )) return nil }) return repo . Update ( ctx , & transaction , rel . Set ( \"status\" , \"paid\" )) }) Mock repo . ExpectTransaction ( func ( repo * reltest . Repository ) { repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) // mock process repo . ExpectTransaction ( func ( r * reltest . Repository ) { repo . ExpectUpdateAny ( rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , 0 )), rel . Inc ( \"popularity\" )) repo . ExpectUpdateAny ( rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , \"\" )), rel . Inc ( \"popularity\" )) }) repo . ExpectUpdate ( rel . Set ( \"status\" , \"paid\" )). ForType ( \"main.Transaction\" ) })","title":"Transactions"},{"location":"changelog/release-notes/","text":"Release Notes \u00b6 v0.35.0 - May 29, 2022 \u00b6 Split big preloading-IN query into multiple queries ( #283 ) ( #285 ) v0.34.1 - May 26, 2022 \u00b6 Add Iris Example ( #282 ) Bump github.com/subosito/gotenv from 1.2.0 to 1.3.0 ( #284 ) Fix Unhandled exception in gopkg.in/yaml.v3 ( #286 ) v0.34.0 - March 25, 2022 \u00b6 Bump github.com/stretchr/testify from 1.7.0 to 1.7.1 ( #273 ) Optimistic locking ( #265 ) Refactor optimistic lock api and test ( #276 ) v0.33.1 - March 12, 2022 \u00b6 Fix dependencies ( #270 ) v0.33.0 - March 12, 2022 \u00b6 Basic support for insert with on conflict ( #269 ) Deprecate migrator package ( #267 ) v0.32.0 - February 20, 2022 \u00b6 :boom: Remove deprecated reltest package ( #266 ) Bump github.com/go-rel/reltest from 0.5.0 to 0.6.0 ( #264 ) v0.31.0 - February 15, 2022 \u00b6 Bump github.com/go-rel/reltest from 0.4.0 to 0.5.0 ( #259 ) Setup codeql analysis ( #263 ) Support embeddable structs ( #262 ) v0.30.0 - November 14, 2021 \u00b6 :boom: Remove builtin base sql adapter ( #258 ) :boom: Remove builtin mysql adapter ( #256 ) :boom: Remove builtin postgres adapter ( #255 ) :boom: Remove builtin sqlite3 adapter ( #257 ) Bump github.com/lib/pq from 1.10.3 to 1.10.4 ( #254 ) v0.29.2 - November 8, 2021 \u00b6 Fix Structset to handle uuid ([16]byte) correctly ( #253 ) v0.29.1 - November 5, 2021 \u00b6 Correctly handle nil values in arrays ( #251 ) Fix panics when array ptr is used for InsertAll and DeleteAll ( #250 ) v0.29.0 - November 5, 2021 \u00b6 Fix to find records to collection of pointer type ( #246 ) Fix typo in comments ( #248 ) Implement option to specify any column as primary key ( #247 ) Test migrator using new reltest package ( #243 ) v0.28.0 - October 29, 2021 \u00b6 Add .deepsource.toml ( #237 ) Add filter conditions for Join helpers ( #239 ) Add support for primary-replica connections ( #238 ) Replace bytes.Compare with bytes.Equal ( #236 ) v0.27.0 - October 20, 2021 \u00b6 Add option to specify addtional filters for joins ( #234 ) v0.26.1 - October 19, 2021 \u00b6 Add workflow to bump patch version ( #232 ) Bump github.com/mattn/go-sqlite3 from 1.14.8 to 1.14.9 ( #230 ) Fix find and count all for soft deleteable records ( #231 ) v0.26.0 - October 13, 2021 \u00b6 Add alternative soft delete scheme ( #225 ) Add option to define JSON datatype column ( #223 ) Add partial unique index for specs ( #221 ) Allow FilterQuery to be specified for partial indexes and unique key constraints ( #219 ) Remove Filter for key as it is not directly supported by SQL ( #220 ) v0.25.0 - September 27, 2021 \u00b6 Add deprecation notices in constructors ( #214 ) Deprecate builtin mysql package ( #211 ) Deprecate builtin sqlite3 package ( #212 ) Fix preload ptr field with custom table ( #216 ) v0.24.0 - September 25, 2021 \u00b6 Add Close() error to Adapter interface ( #209 ) Deprecate reltest ( #208 ) Fix bump-minor workflow ( #210 ) v0.23.0 - September 13, 2021 \u00b6 Deprecate NewSelect for Select ( #205 ) Deprecate NewSortAsc/Desc for SortAsc/Desc ( #204 ) Implement Map.String() ( #206 ) v0.22.0 - September 7, 2021 \u00b6 Add doc to use clientFoundRows=true to mysql adapter ( #202 ) Allow the function that returns the time to be replaced ( #201 ) Bump github.com/lib/pq from 1.10.2 to 1.10.3 ( #203 ) v0.21.0 - August 25, 2021 \u00b6 Set pointer association fields to nil if preload fails ( #197 ) Fix merge sorts query ( #195 ) Fix string of empty query ( #196 ) If the preload fails, the intermediate association fields will also remain nil ( #198 ) v0.20.0 - August 19, 2021 \u00b6 Fix Merge sort query ( #189 ) Fix deleting empty has many ( #191 ) Support stringer interface on query and mutator ( #194 ) v0.19.0 - August 14, 2021 \u00b6 Support NotFoundError is sql.ErrNoRows ( #188 ) v0.18.0 - August 7, 2021 \u00b6 Bump github.com/go-sql-driver/mysql from 1.5.0 to 1.6.0 ( #177 ) Bump github.com/lib/pq from 1.9.0 to 1.10.2 ( #178 ) Bump github.com/mattn/go-sqlite3 from 1.14.6 to 1.14.8 ( #179 ) Fix setting tag auto: true panics in reltest ( #183 ) Improve preload doc ( #180 ) Setup homebrew tap ( #181 ) v0.17.0 - July 2, 2021 \u00b6 \ud83d\udca5 Rename DeleteAll to DeleteAny ( #172 ) \ud83d\udca5 Rename MutateAll to MutateAny ( #174 ) \ud83d\udca5 Rename UpdateAll to UpdateAny ( #171 ) Add DeleteAll records ( #173 ) v0.16.0 - June 23, 2021 \u00b6 Allow to insert association with predefined primary keys ( #168 ) v0.15.0 - June 16, 2021 \u00b6 Update association only if primary and foreign keys are set ( #167 ) v0.14.1 - June 11, 2021 \u00b6 Fix: Use text/template instead html/template #166 ( #166 ) v0.14.0 - May 15, 2021 \u00b6 Added Exec method to repository ( #133 ) Returns affected rows on UpdateAll and DeleteAll ( #164 ) Small improvement to query builder ( #163 ) Update README.md ( #161 ) v0.13.0 - April 3, 2021 \u00b6 Add subquery test specs ( #159 ) Fix convert time coverage on github action ( #158 ) Remove timestamp from schema migration builder ( #160 ) Support Where using Subquery ( #142 ) v0.12.0 - March 19, 2021 \u00b6 Add gin example ( #154 ) Better test pipeline ( #152 ) Deprecate Timestamp Column Builder ( #156 ) Provide PrimaryField to Adapter.Update function ( #153 ) Support BigID Column Builder ( #155 ) Support go 1.16 ( #157 )","title":"Release Notes"},{"location":"changelog/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"changelog/release-notes/#v0350---may-29-2022","text":"Split big preloading-IN query into multiple queries ( #283 ) ( #285 )","title":"v0.35.0 - May 29, 2022"},{"location":"changelog/release-notes/#v0341---may-26-2022","text":"Add Iris Example ( #282 ) Bump github.com/subosito/gotenv from 1.2.0 to 1.3.0 ( #284 ) Fix Unhandled exception in gopkg.in/yaml.v3 ( #286 )","title":"v0.34.1 - May 26, 2022"},{"location":"changelog/release-notes/#v0340---march-25-2022","text":"Bump github.com/stretchr/testify from 1.7.0 to 1.7.1 ( #273 ) Optimistic locking ( #265 ) Refactor optimistic lock api and test ( #276 )","title":"v0.34.0 - March 25, 2022"},{"location":"changelog/release-notes/#v0331---march-12-2022","text":"Fix dependencies ( #270 )","title":"v0.33.1 - March 12, 2022"},{"location":"changelog/release-notes/#v0330---march-12-2022","text":"Basic support for insert with on conflict ( #269 ) Deprecate migrator package ( #267 )","title":"v0.33.0 - March 12, 2022"},{"location":"changelog/release-notes/#v0320---february-20-2022","text":":boom: Remove deprecated reltest package ( #266 ) Bump github.com/go-rel/reltest from 0.5.0 to 0.6.0 ( #264 )","title":"v0.32.0 - February 20, 2022"},{"location":"changelog/release-notes/#v0310---february-15-2022","text":"Bump github.com/go-rel/reltest from 0.4.0 to 0.5.0 ( #259 ) Setup codeql analysis ( #263 ) Support embeddable structs ( #262 )","title":"v0.31.0 - February 15, 2022"},{"location":"changelog/release-notes/#v0300---november-14-2021","text":":boom: Remove builtin base sql adapter ( #258 ) :boom: Remove builtin mysql adapter ( #256 ) :boom: Remove builtin postgres adapter ( #255 ) :boom: Remove builtin sqlite3 adapter ( #257 ) Bump github.com/lib/pq from 1.10.3 to 1.10.4 ( #254 )","title":"v0.30.0 - November 14, 2021"},{"location":"changelog/release-notes/#v0292---november-8-2021","text":"Fix Structset to handle uuid ([16]byte) correctly ( #253 )","title":"v0.29.2 - November 8, 2021"},{"location":"changelog/release-notes/#v0291---november-5-2021","text":"Correctly handle nil values in arrays ( #251 ) Fix panics when array ptr is used for InsertAll and DeleteAll ( #250 )","title":"v0.29.1 - November 5, 2021"},{"location":"changelog/release-notes/#v0290---november-5-2021","text":"Fix to find records to collection of pointer type ( #246 ) Fix typo in comments ( #248 ) Implement option to specify any column as primary key ( #247 ) Test migrator using new reltest package ( #243 )","title":"v0.29.0 - November 5, 2021"},{"location":"changelog/release-notes/#v0280---october-29-2021","text":"Add .deepsource.toml ( #237 ) Add filter conditions for Join helpers ( #239 ) Add support for primary-replica connections ( #238 ) Replace bytes.Compare with bytes.Equal ( #236 )","title":"v0.28.0 - October 29, 2021"},{"location":"changelog/release-notes/#v0270---october-20-2021","text":"Add option to specify addtional filters for joins ( #234 )","title":"v0.27.0 - October 20, 2021"},{"location":"changelog/release-notes/#v0261---october-19-2021","text":"Add workflow to bump patch version ( #232 ) Bump github.com/mattn/go-sqlite3 from 1.14.8 to 1.14.9 ( #230 ) Fix find and count all for soft deleteable records ( #231 )","title":"v0.26.1 - October 19, 2021"},{"location":"changelog/release-notes/#v0260---october-13-2021","text":"Add alternative soft delete scheme ( #225 ) Add option to define JSON datatype column ( #223 ) Add partial unique index for specs ( #221 ) Allow FilterQuery to be specified for partial indexes and unique key constraints ( #219 ) Remove Filter for key as it is not directly supported by SQL ( #220 )","title":"v0.26.0 - October 13, 2021"},{"location":"changelog/release-notes/#v0250---september-27-2021","text":"Add deprecation notices in constructors ( #214 ) Deprecate builtin mysql package ( #211 ) Deprecate builtin sqlite3 package ( #212 ) Fix preload ptr field with custom table ( #216 )","title":"v0.25.0 - September 27, 2021"},{"location":"changelog/release-notes/#v0240---september-25-2021","text":"Add Close() error to Adapter interface ( #209 ) Deprecate reltest ( #208 ) Fix bump-minor workflow ( #210 )","title":"v0.24.0 - September 25, 2021"},{"location":"changelog/release-notes/#v0230---september-13-2021","text":"Deprecate NewSelect for Select ( #205 ) Deprecate NewSortAsc/Desc for SortAsc/Desc ( #204 ) Implement Map.String() ( #206 )","title":"v0.23.0 - September 13, 2021"},{"location":"changelog/release-notes/#v0220---september-7-2021","text":"Add doc to use clientFoundRows=true to mysql adapter ( #202 ) Allow the function that returns the time to be replaced ( #201 ) Bump github.com/lib/pq from 1.10.2 to 1.10.3 ( #203 )","title":"v0.22.0 - September 7, 2021"},{"location":"changelog/release-notes/#v0210---august-25-2021","text":"Set pointer association fields to nil if preload fails ( #197 ) Fix merge sorts query ( #195 ) Fix string of empty query ( #196 ) If the preload fails, the intermediate association fields will also remain nil ( #198 )","title":"v0.21.0 - August 25, 2021"},{"location":"changelog/release-notes/#v0200---august-19-2021","text":"Fix Merge sort query ( #189 ) Fix deleting empty has many ( #191 ) Support stringer interface on query and mutator ( #194 )","title":"v0.20.0 - August 19, 2021"},{"location":"changelog/release-notes/#v0190---august-14-2021","text":"Support NotFoundError is sql.ErrNoRows ( #188 )","title":"v0.19.0 - August 14, 2021"},{"location":"changelog/release-notes/#v0180---august-7-2021","text":"Bump github.com/go-sql-driver/mysql from 1.5.0 to 1.6.0 ( #177 ) Bump github.com/lib/pq from 1.9.0 to 1.10.2 ( #178 ) Bump github.com/mattn/go-sqlite3 from 1.14.6 to 1.14.8 ( #179 ) Fix setting tag auto: true panics in reltest ( #183 ) Improve preload doc ( #180 ) Setup homebrew tap ( #181 )","title":"v0.18.0 - August 7, 2021"},{"location":"changelog/release-notes/#v0170---july-2-2021","text":"\ud83d\udca5 Rename DeleteAll to DeleteAny ( #172 ) \ud83d\udca5 Rename MutateAll to MutateAny ( #174 ) \ud83d\udca5 Rename UpdateAll to UpdateAny ( #171 ) Add DeleteAll records ( #173 )","title":"v0.17.0 - July 2, 2021"},{"location":"changelog/release-notes/#v0160---june-23-2021","text":"Allow to insert association with predefined primary keys ( #168 )","title":"v0.16.0 - June 23, 2021"},{"location":"changelog/release-notes/#v0150---june-16-2021","text":"Update association only if primary and foreign keys are set ( #167 )","title":"v0.15.0 - June 16, 2021"},{"location":"changelog/release-notes/#v0141---june-11-2021","text":"Fix: Use text/template instead html/template #166 ( #166 )","title":"v0.14.1 - June 11, 2021"},{"location":"changelog/release-notes/#v0140---may-15-2021","text":"Added Exec method to repository ( #133 ) Returns affected rows on UpdateAll and DeleteAll ( #164 ) Small improvement to query builder ( #163 ) Update README.md ( #161 )","title":"v0.14.0 - May 15, 2021"},{"location":"changelog/release-notes/#v0130---april-3-2021","text":"Add subquery test specs ( #159 ) Fix convert time coverage on github action ( #158 ) Remove timestamp from schema migration builder ( #160 ) Support Where using Subquery ( #142 )","title":"v0.13.0 - April 3, 2021"},{"location":"changelog/release-notes/#v0120---march-19-2021","text":"Add gin example ( #154 ) Better test pipeline ( #152 ) Deprecate Timestamp Column Builder ( #156 ) Provide PrimaryField to Adapter.Update function ( #153 ) Support BigID Column Builder ( #155 ) Support go 1.16 ( #157 )","title":"v0.12.0 - March 19, 2021"},{"location":"changelog/upgrading/","text":"Upgrading \u00b6 Upgrading from 0.32.x to 0.33.x \u00b6 Rel v0.33.x adds rel.OnConflict mutator that requires adapter interface changes. because of that, when upgrading to this version, other Rel packages need to be upgraded at the same time as well . Upgrading from 0.31.x to 0.32.x \u00b6 Import Path \u00b6 Builtin github.com/go-rel/rel/reltest adapter has been refactored to github.com/go-rel/reltest . 0.31.x import \"github.com/go-rel/rel/reltest\" 0.32.x import \"github.com/go-rel/rel\" Upgrading from 0.29.x to 0.30.x \u00b6 SQLite3 Adapter \u00b6 Builtin github.com/go-rel/rel/adapter/sqlite3 adapter has been extracted to github.com/go-rel/sqlite3 . 0.29.x import \"github.com/go-rel/rel/adapter/sqlite3\" 0.30.x import \"github.com/go-rel/sqlite3\" MySQL Adapter \u00b6 Builtin github.com/go-rel/rel/adapter/mysql adapter has been extracted to github.com/go-rel/mysql . 0.29.x import \"github.com/go-rel/rel/adapter/mysql\" 0.30.x import \"github.com/go-rel/mysql\" Postgres Adapter \u00b6 Builtin github.com/go-rel/rel/adapter/postgres adapter has been extracted to github.com/go-rel/postgres . 0.29.x import \"github.com/go-rel/rel/adapter/postgres\" 0.30.x import \"github.com/go-rel/postgres\" Upgrading from 0.16.x to 0.17.x \u00b6 UpdateAll and DeleteAll \u00b6 UpdateAll and DeleteAll now renamed to UpdateAny and DeleteAny respectively. 0.16.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.17.x // UpdateAny updatedCount , err := repo . UpdateAny ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAny deletedCount , err := repo . DeleteAny ( ctx , query ) Upgrading from 0.13.x to 0.14.x \u00b6 UpdateAll and DeleteAll \u00b6 UpdateAll and DeleteAll function now returns affected rows instead of just error. 0.13.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.14.x // UpdateAll updatedCount , err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll deletedCount , err := repo . DeleteAll ( ctx , query ) Upgrading from 0.8.x to 0.9.x \u00b6 Association Definition \u00b6 Before 0.9.x all association is saved as is when its parent is modified, after this PR ( !127 ) this feature needs to be explicitly enabled. 0.8.x // User schema. type User struct { ID int Name string Address Address } 0.9.x // User schema. type User struct { ID int Name string Address Address `autosave:\"true\"` } Upgrading from 0.7.x to 0.8.x \u00b6 Import Path \u00b6 REL is migrated to a new github organization and all import path need to be moved from Fs02 to go-rel 0.7.x import github . com / Fs02 / rel 0.8.x import github . com / go - rel / rel","title":"Upgrading"},{"location":"changelog/upgrading/#upgrading","text":"","title":"Upgrading"},{"location":"changelog/upgrading/#upgrading-from-032x-to-033x","text":"Rel v0.33.x adds rel.OnConflict mutator that requires adapter interface changes. because of that, when upgrading to this version, other Rel packages need to be upgraded at the same time as well .","title":"Upgrading from 0.32.x to 0.33.x"},{"location":"changelog/upgrading/#upgrading-from-031x-to-032x","text":"","title":"Upgrading from 0.31.x to 0.32.x"},{"location":"changelog/upgrading/#import-path","text":"Builtin github.com/go-rel/rel/reltest adapter has been refactored to github.com/go-rel/reltest . 0.31.x import \"github.com/go-rel/rel/reltest\" 0.32.x import \"github.com/go-rel/rel\"","title":"Import Path"},{"location":"changelog/upgrading/#upgrading-from-029x-to-030x","text":"","title":"Upgrading from 0.29.x to 0.30.x"},{"location":"changelog/upgrading/#sqlite3-adapter","text":"Builtin github.com/go-rel/rel/adapter/sqlite3 adapter has been extracted to github.com/go-rel/sqlite3 . 0.29.x import \"github.com/go-rel/rel/adapter/sqlite3\" 0.30.x import \"github.com/go-rel/sqlite3\"","title":"SQLite3 Adapter"},{"location":"changelog/upgrading/#mysql-adapter","text":"Builtin github.com/go-rel/rel/adapter/mysql adapter has been extracted to github.com/go-rel/mysql . 0.29.x import \"github.com/go-rel/rel/adapter/mysql\" 0.30.x import \"github.com/go-rel/mysql\"","title":"MySQL Adapter"},{"location":"changelog/upgrading/#postgres-adapter","text":"Builtin github.com/go-rel/rel/adapter/postgres adapter has been extracted to github.com/go-rel/postgres . 0.29.x import \"github.com/go-rel/rel/adapter/postgres\" 0.30.x import \"github.com/go-rel/postgres\"","title":"Postgres Adapter"},{"location":"changelog/upgrading/#upgrading-from-016x-to-017x","text":"","title":"Upgrading from 0.16.x to 0.17.x"},{"location":"changelog/upgrading/#updateall-and-deleteall","text":"UpdateAll and DeleteAll now renamed to UpdateAny and DeleteAny respectively. 0.16.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.17.x // UpdateAny updatedCount , err := repo . UpdateAny ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAny deletedCount , err := repo . DeleteAny ( ctx , query )","title":"UpdateAll and DeleteAll"},{"location":"changelog/upgrading/#upgrading-from-013x-to-014x","text":"","title":"Upgrading from 0.13.x to 0.14.x"},{"location":"changelog/upgrading/#updateall-and-deleteall_1","text":"UpdateAll and DeleteAll function now returns affected rows instead of just error. 0.13.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.14.x // UpdateAll updatedCount , err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll deletedCount , err := repo . DeleteAll ( ctx , query )","title":"UpdateAll and DeleteAll"},{"location":"changelog/upgrading/#upgrading-from-08x-to-09x","text":"","title":"Upgrading from 0.8.x to 0.9.x"},{"location":"changelog/upgrading/#association-definition","text":"Before 0.9.x all association is saved as is when its parent is modified, after this PR ( !127 ) this feature needs to be explicitly enabled. 0.8.x // User schema. type User struct { ID int Name string Address Address } 0.9.x // User schema. type User struct { ID int Name string Address Address `autosave:\"true\"` }","title":"Association Definition"},{"location":"changelog/upgrading/#upgrading-from-07x-to-08x","text":"","title":"Upgrading from 0.7.x to 0.8.x"},{"location":"changelog/upgrading/#import-path_1","text":"REL is migrated to a new github organization and all import path need to be moved from Fs02 to go-rel 0.7.x import github . com / Fs02 / rel 0.8.x import github . com / go - rel / rel","title":"Import Path"},{"location":"reference/adapter-mssql/","text":"mssql \u00b6 import \"github.com/go-rel/mssql\" Overview \u00b6 Package mssql wraps mssql driver as an adapter for REL. func New \u00b6 func New ( db * db . DB ) rel . Adapter New mssql adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open mssql connection using dsn. type MSSQL \u00b6 type MSSQL struct { sql . SQL } MSSQL Adapter. func (MSSQL) Begin \u00b6 func ( m MSSQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (MSSQL) Insert \u00b6 func ( m MSSQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (MSSQL) InsertAll \u00b6 func ( m MSSQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"github.com/go-rel/mssql"},{"location":"reference/adapter-mssql/#mssql","text":"import \"github.com/go-rel/mssql\"","title":"mssql"},{"location":"reference/adapter-mssql/#overview","text":"Package mssql wraps mssql driver as an adapter for REL.","title":"Overview"},{"location":"reference/adapter-mssql/#func-new","text":"func New ( db * db . DB ) rel . Adapter New mssql adapter using existing connection.","title":"func New"},{"location":"reference/adapter-mssql/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open mssql connection using dsn.","title":"func Open"},{"location":"reference/adapter-mssql/#type-mssql","text":"type MSSQL struct { sql . SQL } MSSQL Adapter.","title":"type MSSQL"},{"location":"reference/adapter-mssql/#func-mssql-begin","text":"func ( m MSSQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (MSSQL) Begin"},{"location":"reference/adapter-mssql/#func-mssql-insert","text":"func ( m MSSQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (MSSQL) Insert"},{"location":"reference/adapter-mssql/#func-mssql-insertall","text":"func ( m MSSQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (MSSQL) InsertAll"},{"location":"reference/adapter-mysql/","text":"mysql \u00b6 import \"github.com/go-rel/mysql\" Overview \u00b6 Package mysql wraps mysql driver as an adapter for REL. Usage: // open mysql connection. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter, err := mysql.Open(\"root@(127.0.0.1:3306)/rel_test?clientFoundRows=true&charset=utf8&parseTime=True&loc=Local\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter) func MustOpen \u00b6 func MustOpen ( dsn string ) rel . Adapter MustOpen mysql connection using dsn. func New \u00b6 func New ( database * db . DB ) rel . Adapter New mysql adapter using existing connection. Existing connection needs to be created with clientFoundRows=true options for update and delete to works correctly. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open mysql connection using dsn. type Quote \u00b6 type Quote struct {} Quote MySQL identifiers and literals. func (Quote) ID \u00b6 func ( q Quote ) ID ( name string ) string func (Quote) Value \u00b6 func ( q Quote ) Value ( v interface {}) string type ValueConvert \u00b6 type ValueConvert struct {} ValueConvert converts values to MySQL literals. func (ValueConvert) ConvertValue \u00b6 func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"github.com/go-rel/mysql"},{"location":"reference/adapter-mysql/#mysql","text":"import \"github.com/go-rel/mysql\"","title":"mysql"},{"location":"reference/adapter-mysql/#overview","text":"Package mysql wraps mysql driver as an adapter for REL. Usage: // open mysql connection. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter, err := mysql.Open(\"root@(127.0.0.1:3306)/rel_test?clientFoundRows=true&charset=utf8&parseTime=True&loc=Local\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-mysql/#func-mustopen","text":"func MustOpen ( dsn string ) rel . Adapter MustOpen mysql connection using dsn.","title":"func MustOpen"},{"location":"reference/adapter-mysql/#func-new","text":"func New ( database * db . DB ) rel . Adapter New mysql adapter using existing connection. Existing connection needs to be created with clientFoundRows=true options for update and delete to works correctly.","title":"func New"},{"location":"reference/adapter-mysql/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open mysql connection using dsn.","title":"func Open"},{"location":"reference/adapter-mysql/#type-quote","text":"type Quote struct {} Quote MySQL identifiers and literals.","title":"type Quote"},{"location":"reference/adapter-mysql/#func-quote-id","text":"func ( q Quote ) ID ( name string ) string","title":"func (Quote) ID"},{"location":"reference/adapter-mysql/#func-quote-value","text":"func ( q Quote ) Value ( v interface {}) string","title":"func (Quote) Value"},{"location":"reference/adapter-mysql/#type-valueconvert","text":"type ValueConvert struct {} ValueConvert converts values to MySQL literals.","title":"type ValueConvert"},{"location":"reference/adapter-mysql/#func-valueconvert-convertvalue","text":"func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"func (ValueConvert) ConvertValue"},{"location":"reference/adapter-postgres/","text":"postgres \u00b6 import \"github.com/go-rel/postgres\" Overview \u00b6 Package postgres wraps postgres (pq) driver as an adapter for REL. Usage: // open postgres connection. adapter, err := postgres.Open(\"postgres://postgres@localhost/rel_test?sslmode=disable\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter) Constants \u00b6 const TimeLayout = \"2006-01-02 15:04:05.999999999Z07:00:00\" TimeLayout used by PostgreSQL adapter. func FormatTime \u00b6 func FormatTime ( t time . Time ) string FormatTime formats time to PostgreSQL format. func MustOpen \u00b6 func MustOpen ( dsn string ) rel . Adapter MustOpen postgres connection using dsn. func New \u00b6 func New ( database * db . DB ) rel . Adapter New postgres adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open postgres connection using dsn. type Postgres \u00b6 type Postgres struct { sql . SQL } Postgres adapter. func (Postgres) Begin \u00b6 func ( p Postgres ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (Postgres) Insert \u00b6 func ( p Postgres ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (Postgres) InsertAll \u00b6 func ( p Postgres ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids. type Quote \u00b6 type Quote struct {} Quote PostgreSQL identifiers and literals. func (Quote) ID \u00b6 func ( q Quote ) ID ( name string ) string func (Quote) Value \u00b6 func ( q Quote ) Value ( v interface {}) string type ValueConvert \u00b6 type ValueConvert struct {} ValueConvert converts values to PostgreSQL literals. func (ValueConvert) ConvertValue \u00b6 func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"github.com/go-rel/postgres"},{"location":"reference/adapter-postgres/#postgres","text":"import \"github.com/go-rel/postgres\"","title":"postgres"},{"location":"reference/adapter-postgres/#overview","text":"Package postgres wraps postgres (pq) driver as an adapter for REL. Usage: // open postgres connection. adapter, err := postgres.Open(\"postgres://postgres@localhost/rel_test?sslmode=disable\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-postgres/#constants","text":"const TimeLayout = \"2006-01-02 15:04:05.999999999Z07:00:00\" TimeLayout used by PostgreSQL adapter.","title":"Constants"},{"location":"reference/adapter-postgres/#func-formattime","text":"func FormatTime ( t time . Time ) string FormatTime formats time to PostgreSQL format.","title":"func FormatTime"},{"location":"reference/adapter-postgres/#func-mustopen","text":"func MustOpen ( dsn string ) rel . Adapter MustOpen postgres connection using dsn.","title":"func MustOpen"},{"location":"reference/adapter-postgres/#func-new","text":"func New ( database * db . DB ) rel . Adapter New postgres adapter using existing connection.","title":"func New"},{"location":"reference/adapter-postgres/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open postgres connection using dsn.","title":"func Open"},{"location":"reference/adapter-postgres/#type-postgres","text":"type Postgres struct { sql . SQL } Postgres adapter.","title":"type Postgres"},{"location":"reference/adapter-postgres/#func-postgres-begin","text":"func ( p Postgres ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (Postgres) Begin"},{"location":"reference/adapter-postgres/#func-postgres-insert","text":"func ( p Postgres ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (Postgres) Insert"},{"location":"reference/adapter-postgres/#func-postgres-insertall","text":"func ( p Postgres ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (Postgres) InsertAll"},{"location":"reference/adapter-postgres/#type-quote","text":"type Quote struct {} Quote PostgreSQL identifiers and literals.","title":"type Quote"},{"location":"reference/adapter-postgres/#func-quote-id","text":"func ( q Quote ) ID ( name string ) string","title":"func (Quote) ID"},{"location":"reference/adapter-postgres/#func-quote-value","text":"func ( q Quote ) Value ( v interface {}) string","title":"func (Quote) Value"},{"location":"reference/adapter-postgres/#type-valueconvert","text":"type ValueConvert struct {} ValueConvert converts values to PostgreSQL literals.","title":"type ValueConvert"},{"location":"reference/adapter-postgres/#func-valueconvert-convertvalue","text":"func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"func (ValueConvert) ConvertValue"},{"location":"reference/adapter-primaryreplica/","text":"primaryreplica \u00b6 import \"github.com/go-rel/primaryreplica\" Overview \u00b6 func New \u00b6 func New ( primary rel . Adapter , replicas ... rel . Adapter ) rel . Adapter type PrimaryReplica \u00b6 type PrimaryReplica struct { // contains filtered or unexported fields } func (*PrimaryReplica) Aggregate \u00b6 func ( pr * PrimaryReplica ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) func (*PrimaryReplica) Apply \u00b6 func ( pr * PrimaryReplica ) Apply ( ctx context . Context , migration rel . Migration ) error func (*PrimaryReplica) Begin \u00b6 func ( pr * PrimaryReplica ) Begin ( ctx context . Context ) ( rel . Adapter , error ) func (*PrimaryReplica) Close \u00b6 func ( pr * PrimaryReplica ) Close () error func (*PrimaryReplica) Commit \u00b6 func ( pr * PrimaryReplica ) Commit ( ctx context . Context ) error func (*PrimaryReplica) Delete \u00b6 func ( pr * PrimaryReplica ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) func (*PrimaryReplica) Exec \u00b6 func ( pr * PrimaryReplica ) Exec ( ctx context . Context , stmt string , args [] interface {}) ( int64 , int64 , error ) func (*PrimaryReplica) Insert \u00b6 func ( pr * PrimaryReplica ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) func (*PrimaryReplica) InsertAll \u00b6 func ( pr * PrimaryReplica ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) func (*PrimaryReplica) Instrumentation \u00b6 func ( pr * PrimaryReplica ) Instrumentation ( instrumenter rel . Instrumenter ) func (*PrimaryReplica) Ping \u00b6 func ( pr * PrimaryReplica ) Ping ( ctx context . Context ) error func (*PrimaryReplica) Query \u00b6 func ( pr * PrimaryReplica ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) func (*PrimaryReplica) Rollback \u00b6 func ( pr * PrimaryReplica ) Rollback ( ctx context . Context ) error func (*PrimaryReplica) Update \u00b6 func ( pr * PrimaryReplica ) Update ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( int , error )","title":"github.com/go-rel/primaryreplica"},{"location":"reference/adapter-primaryreplica/#primaryreplica","text":"import \"github.com/go-rel/primaryreplica\"","title":"primaryreplica"},{"location":"reference/adapter-primaryreplica/#overview","text":"","title":"Overview"},{"location":"reference/adapter-primaryreplica/#func-new","text":"func New ( primary rel . Adapter , replicas ... rel . Adapter ) rel . Adapter","title":"func New"},{"location":"reference/adapter-primaryreplica/#type-primaryreplica","text":"type PrimaryReplica struct { // contains filtered or unexported fields }","title":"type PrimaryReplica"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-aggregate","text":"func ( pr * PrimaryReplica ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error )","title":"func (*PrimaryReplica) Aggregate"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-apply","text":"func ( pr * PrimaryReplica ) Apply ( ctx context . Context , migration rel . Migration ) error","title":"func (*PrimaryReplica) Apply"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-begin","text":"func ( pr * PrimaryReplica ) Begin ( ctx context . Context ) ( rel . Adapter , error )","title":"func (*PrimaryReplica) Begin"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-close","text":"func ( pr * PrimaryReplica ) Close () error","title":"func (*PrimaryReplica) Close"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-commit","text":"func ( pr * PrimaryReplica ) Commit ( ctx context . Context ) error","title":"func (*PrimaryReplica) Commit"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-delete","text":"func ( pr * PrimaryReplica ) Delete ( ctx context . Context , query rel . Query ) ( int , error )","title":"func (*PrimaryReplica) Delete"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-exec","text":"func ( pr * PrimaryReplica ) Exec ( ctx context . Context , stmt string , args [] interface {}) ( int64 , int64 , error )","title":"func (*PrimaryReplica) Exec"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-insert","text":"func ( pr * PrimaryReplica ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error )","title":"func (*PrimaryReplica) Insert"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-insertall","text":"func ( pr * PrimaryReplica ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error )","title":"func (*PrimaryReplica) InsertAll"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-instrumentation","text":"func ( pr * PrimaryReplica ) Instrumentation ( instrumenter rel . Instrumenter )","title":"func (*PrimaryReplica) Instrumentation"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-ping","text":"func ( pr * PrimaryReplica ) Ping ( ctx context . Context ) error","title":"func (*PrimaryReplica) Ping"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-query","text":"func ( pr * PrimaryReplica ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error )","title":"func (*PrimaryReplica) Query"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-rollback","text":"func ( pr * PrimaryReplica ) Rollback ( ctx context . Context ) error","title":"func (*PrimaryReplica) Rollback"},{"location":"reference/adapter-primaryreplica/#func-primaryreplica-update","text":"func ( pr * PrimaryReplica ) Update ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( int , error )","title":"func (*PrimaryReplica) Update"},{"location":"reference/adapter-sql/","text":"sql \u00b6 import \"github.com/go-rel/sql\" Overview \u00b6 Constants \u00b6 const DefaultTimeLayout = \"2006-01-02 15:04:05\" DefaultTimeLayout default time layout. func ColumnMapper \u00b6 func ColumnMapper ( column * rel . Column ) ( string , int , int ) ColumnMapper function. func ExtractString \u00b6 func ExtractString ( s , left , right string ) string ExtractString between two string. type Cursor \u00b6 type Cursor struct { * sql . Rows } Cursor used for retrieving result. func (*Cursor) Fields \u00b6 func ( c * Cursor ) Fields () ([] string , error ) Fields returned in the result. func (*Cursor) NopScanner \u00b6 func ( c * Cursor ) NopScanner () interface {} NopScanner for this adapter. type DeleteBuilder \u00b6 type DeleteBuilder interface { Build ( table string , filter rel . FilterQuery ) ( string , [] interface {}) } type ErrorMapper \u00b6 type ErrorMapper func ( error ) error ErrorMapper function. type IncrementFunc \u00b6 type IncrementFunc func ( SQL ) int IncrementFunc function. type IndexBuilder \u00b6 type IndexBuilder interface { Build ( index rel . Index ) string } type InsertAllBuilder \u00b6 type InsertAllBuilder interface { Build ( table string , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] interface {}) } type InsertBuilder \u00b6 type InsertBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] interface {}) } type QueryBuilder \u00b6 type QueryBuilder interface { Build ( query rel . Query ) ( string , [] interface {}) } type SQL \u00b6 type SQL struct { QueryBuilder QueryBuilder InsertBuilder InsertBuilder InsertAllBuilder InsertAllBuilder UpdateBuilder UpdateBuilder DeleteBuilder DeleteBuilder TableBuilder TableBuilder IndexBuilder IndexBuilder IncrementFunc IncrementFunc ErrorMapper ErrorMapper DB * sql . DB Tx * sql . Tx Savepoint int Instrumenter rel . Instrumenter } SQL base adapter. func (SQL) Aggregate \u00b6 func ( s SQL ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) Aggregate record using given query. func (SQL) Apply \u00b6 func ( s SQL ) Apply ( ctx context . Context , migration rel . Migration ) error Apply performs migration to database. Deprecated: Use Schema Apply instead. func (SQL) Begin \u00b6 func ( s SQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (SQL) Close \u00b6 func ( s SQL ) Close () error Close database connection. TODO: add closer to adapter interface func (SQL) Commit \u00b6 func ( s SQL ) Commit ( ctx context . Context ) error Commit commits current transaction. func (SQL) Delete \u00b6 func ( s SQL ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) Delete deletes all results that match the query. func (SQL) DoExec \u00b6 func ( s SQL ) DoExec ( ctx context . Context , statement string , args [] interface {}) ( sql . Result , error ) DoExec using active database connection. func (SQL) DoQuery \u00b6 func ( s SQL ) DoQuery ( ctx context . Context , statement string , args [] interface {}) ( * sql . Rows , error ) DoQuery using active database connection. func (SQL) Exec \u00b6 func ( s SQL ) Exec ( ctx context . Context , statement string , args [] interface {}) ( int64 , int64 , error ) Exec performs exec operation. func (SQL) Insert \u00b6 func ( s SQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (SQL) InsertAll \u00b6 func ( s SQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids. func (*SQL) Instrumentation \u00b6 func ( s * SQL ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation set instrumenter for this adapter. func (SQL) Ping \u00b6 func ( s SQL ) Ping ( ctx context . Context ) error Ping database. func (SQL) Query \u00b6 func ( s SQL ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) Query performs query operation. func (SQL) Rollback \u00b6 func ( s SQL ) Rollback ( ctx context . Context ) error Rollback revert current transaction. func (SQL) SchemaApply \u00b6 func ( s SQL ) SchemaApply ( ctx context . Context , migration rel . Migration ) error SchemaApply performs migration to database. func (SQL) Update \u00b6 func ( s SQL ) Update ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( int , error ) Update updates a record in database. type TableBuilder \u00b6 type TableBuilder interface { Build ( table rel . Table ) string } type UpdateBuilder \u00b6 type UpdateBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , filter rel . FilterQuery ) ( string , [] interface {}) }","title":"github.com/go-rel/sql"},{"location":"reference/adapter-sql/#sql","text":"import \"github.com/go-rel/sql\"","title":"sql"},{"location":"reference/adapter-sql/#overview","text":"","title":"Overview"},{"location":"reference/adapter-sql/#constants","text":"const DefaultTimeLayout = \"2006-01-02 15:04:05\" DefaultTimeLayout default time layout.","title":"Constants"},{"location":"reference/adapter-sql/#func-columnmapper","text":"func ColumnMapper ( column * rel . Column ) ( string , int , int ) ColumnMapper function.","title":"func ColumnMapper"},{"location":"reference/adapter-sql/#func-extractstring","text":"func ExtractString ( s , left , right string ) string ExtractString between two string.","title":"func ExtractString"},{"location":"reference/adapter-sql/#type-cursor","text":"type Cursor struct { * sql . Rows } Cursor used for retrieving result.","title":"type Cursor"},{"location":"reference/adapter-sql/#func-cursor-fields","text":"func ( c * Cursor ) Fields () ([] string , error ) Fields returned in the result.","title":"func (*Cursor) Fields"},{"location":"reference/adapter-sql/#func-cursor-nopscanner","text":"func ( c * Cursor ) NopScanner () interface {} NopScanner for this adapter.","title":"func (*Cursor) NopScanner"},{"location":"reference/adapter-sql/#type-deletebuilder","text":"type DeleteBuilder interface { Build ( table string , filter rel . FilterQuery ) ( string , [] interface {}) }","title":"type DeleteBuilder"},{"location":"reference/adapter-sql/#type-errormapper","text":"type ErrorMapper func ( error ) error ErrorMapper function.","title":"type ErrorMapper"},{"location":"reference/adapter-sql/#type-incrementfunc","text":"type IncrementFunc func ( SQL ) int IncrementFunc function.","title":"type IncrementFunc"},{"location":"reference/adapter-sql/#type-indexbuilder","text":"type IndexBuilder interface { Build ( index rel . Index ) string }","title":"type IndexBuilder"},{"location":"reference/adapter-sql/#type-insertallbuilder","text":"type InsertAllBuilder interface { Build ( table string , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] interface {}) }","title":"type InsertAllBuilder"},{"location":"reference/adapter-sql/#type-insertbuilder","text":"type InsertBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] interface {}) }","title":"type InsertBuilder"},{"location":"reference/adapter-sql/#type-querybuilder","text":"type QueryBuilder interface { Build ( query rel . Query ) ( string , [] interface {}) }","title":"type QueryBuilder"},{"location":"reference/adapter-sql/#type-sql","text":"type SQL struct { QueryBuilder QueryBuilder InsertBuilder InsertBuilder InsertAllBuilder InsertAllBuilder UpdateBuilder UpdateBuilder DeleteBuilder DeleteBuilder TableBuilder TableBuilder IndexBuilder IndexBuilder IncrementFunc IncrementFunc ErrorMapper ErrorMapper DB * sql . DB Tx * sql . Tx Savepoint int Instrumenter rel . Instrumenter } SQL base adapter.","title":"type SQL"},{"location":"reference/adapter-sql/#func-sql-aggregate","text":"func ( s SQL ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) Aggregate record using given query.","title":"func (SQL) Aggregate"},{"location":"reference/adapter-sql/#func-sql-apply","text":"func ( s SQL ) Apply ( ctx context . Context , migration rel . Migration ) error Apply performs migration to database. Deprecated: Use Schema Apply instead.","title":"func (SQL) Apply"},{"location":"reference/adapter-sql/#func-sql-begin","text":"func ( s SQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (SQL) Begin"},{"location":"reference/adapter-sql/#func-sql-close","text":"func ( s SQL ) Close () error Close database connection. TODO: add closer to adapter interface","title":"func (SQL) Close"},{"location":"reference/adapter-sql/#func-sql-commit","text":"func ( s SQL ) Commit ( ctx context . Context ) error Commit commits current transaction.","title":"func (SQL) Commit"},{"location":"reference/adapter-sql/#func-sql-delete","text":"func ( s SQL ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) Delete deletes all results that match the query.","title":"func (SQL) Delete"},{"location":"reference/adapter-sql/#func-sql-doexec","text":"func ( s SQL ) DoExec ( ctx context . Context , statement string , args [] interface {}) ( sql . Result , error ) DoExec using active database connection.","title":"func (SQL) DoExec"},{"location":"reference/adapter-sql/#func-sql-doquery","text":"func ( s SQL ) DoQuery ( ctx context . Context , statement string , args [] interface {}) ( * sql . Rows , error ) DoQuery using active database connection.","title":"func (SQL) DoQuery"},{"location":"reference/adapter-sql/#func-sql-exec","text":"func ( s SQL ) Exec ( ctx context . Context , statement string , args [] interface {}) ( int64 , int64 , error ) Exec performs exec operation.","title":"func (SQL) Exec"},{"location":"reference/adapter-sql/#func-sql-insert","text":"func ( s SQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (SQL) Insert"},{"location":"reference/adapter-sql/#func-sql-insertall","text":"func ( s SQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (SQL) InsertAll"},{"location":"reference/adapter-sql/#func-sql-instrumentation","text":"func ( s * SQL ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation set instrumenter for this adapter.","title":"func (*SQL) Instrumentation"},{"location":"reference/adapter-sql/#func-sql-ping","text":"func ( s SQL ) Ping ( ctx context . Context ) error Ping database.","title":"func (SQL) Ping"},{"location":"reference/adapter-sql/#func-sql-query","text":"func ( s SQL ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) Query performs query operation.","title":"func (SQL) Query"},{"location":"reference/adapter-sql/#func-sql-rollback","text":"func ( s SQL ) Rollback ( ctx context . Context ) error Rollback revert current transaction.","title":"func (SQL) Rollback"},{"location":"reference/adapter-sql/#func-sql-schemaapply","text":"func ( s SQL ) SchemaApply ( ctx context . Context , migration rel . Migration ) error SchemaApply performs migration to database.","title":"func (SQL) SchemaApply"},{"location":"reference/adapter-sql/#func-sql-update","text":"func ( s SQL ) Update ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( int , error ) Update updates a record in database.","title":"func (SQL) Update"},{"location":"reference/adapter-sql/#type-tablebuilder","text":"type TableBuilder interface { Build ( table rel . Table ) string }","title":"type TableBuilder"},{"location":"reference/adapter-sql/#type-updatebuilder","text":"type UpdateBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , filter rel . FilterQuery ) ( string , [] interface {}) }","title":"type UpdateBuilder"},{"location":"reference/adapter-sqlite3/","text":"sqlite3 \u00b6 import \"github.com/go-rel/sqlite3\" Overview \u00b6 Package sqlite3 wraps go-sqlite3 driver as an adapter for rel. Usage: // open sqlite3 connection. adapter, err := sqlite3.Open(\"dev.db\") if err != nil { panic(err) } defer adapter.Close() // initialize rel's repo. repo := rel.New(adapter) func New \u00b6 func New ( database * db . DB ) rel . Adapter New sqlite3 adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open sqlite3 connection using dsn.","title":"github.com/go-rel/sqlite3"},{"location":"reference/adapter-sqlite3/#sqlite3","text":"import \"github.com/go-rel/sqlite3\"","title":"sqlite3"},{"location":"reference/adapter-sqlite3/#overview","text":"Package sqlite3 wraps go-sqlite3 driver as an adapter for rel. Usage: // open sqlite3 connection. adapter, err := sqlite3.Open(\"dev.db\") if err != nil { panic(err) } defer adapter.Close() // initialize rel's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-sqlite3/#func-new","text":"func New ( database * db . DB ) rel . Adapter New sqlite3 adapter using existing connection.","title":"func New"},{"location":"reference/adapter-sqlite3/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open sqlite3 connection using dsn.","title":"func Open"},{"location":"reference/changeset/","text":"changeset \u00b6 import \"github.com/go-rel/changeset\" Overview \u00b6 Package changeset used to cast and validate data before saving it to the database. Package changeset used to cast and validate data before saving it to the database. Variables \u00b6 var CastAssocErrorMessage = \"{field} is invalid\" CastAssocErrorMessage is the default error message for CastAssoc when its invalid. var CastAssocRequiredMessage = \"{field} is required\" CastAssocRequiredMessage is the default error message for CastAssoc when its missing. var CastErrorMessage = \"{field} is invalid\" CastErrorMessage is the default error message for Cast. var CheckConstraintMessage = \"{field} is invalid\" CheckConstraintMessage is the default error message for CheckConstraint. var ForeignKeyConstraintMessage = \"does not exist\" ForeignKeyConstraintMessage is the default error message for ForeignKeyConstraint. var PutAssocErrorMessage = \"{field} is invalid\" PutAssocErrorMessage is the default error message for PutAssoc. var PutChangeErrorMessage = \"{field} is invalid\" PutChangeErrorMessage is the default error message for PutChange. var PutDefaultErrorMessage = \"{field} is invalid\" PutDefaultErrorMessage is the default error message for PutDefault. var UniqueConstraintMessage = \"{field} has already been taken\" UniqueConstraintMessage is the default error message for UniqueConstraint. var ValidateExclusionErrorMessage = \"{field} must not be any of {values}\" ValidateExclusionErrorMessage is the default error message for ValidateExclusion. var ValidateInclusionErrorMessage = \"{field} must be one of {values}\" ValidateInclusionErrorMessage is the default error message for ValidateInclusion. var ValidateMaxErrorMessage = \"{field} must be less than {max}\" ValidateMaxErrorMessage is the default error message for ValidateMax. var ValidateMinErrorMessage = \"{field} must be more than {min}\" ValidateMinErrorMessage is the default error message for ValidateMin. var ValidatePatternErrorMessage = \"{field}'s format is invalid\" ValidatePatternErrorMessage is the default error message for ValidatePattern. var ValidateRangeErrorMessage = \"{field} must be between {min} and {max}\" ValidateRangeErrorMessage is the default error message for ValidateRange. var ValidateRegexpErrorMessage = \"{field}'s format is invalid\" ValidateRegexpErrorMessage is the default error message for ValidateRegexp. var ValidateRequiredErrorMessage = \"{field} is required\" ValidateRequiredErrorMessage is the default error message for ValidateRequired. func AddError \u00b6 func AddError ( ch * Changeset , field string , message string ) AddError adds an error to changeset. ch := changeset.Cast(user, params, fields) changeset.AddError(ch, \"field\", \"error\") ch.Errors() // []errors.Error{{Field: \"field\", Message: \"error\"}} func ApplyString \u00b6 func ApplyString ( ch * Changeset , field string , fn func ( string ) string ) ApplyString apply a function for string value. func CastAssoc \u00b6 func CastAssoc ( ch * Changeset , field string , fn ChangeFunc , opts ... Option ) CastAssoc casts association changes using changeset function. Repo insert or update won't persist any changes generated by CastAssoc. func CheckConstraint \u00b6 func CheckConstraint ( ch * Changeset , field string , opts ... Option ) CheckConstraint adds an unique constraint to changeset. func DeleteChange \u00b6 func DeleteChange ( ch * Changeset , field string ) DeleteChange from changeset. func EscapeString \u00b6 func EscapeString ( ch * Changeset , fields ... string ) EscapeString escapes special characters like \"<\" to become \"<\". this is helper for html.EscapeString func ForeignKeyConstraint \u00b6 func ForeignKeyConstraint ( ch * Changeset , field string , opts ... Option ) ForeignKeyConstraint adds an unique constraint to changeset. func PutAssoc \u00b6 func PutAssoc ( ch * Changeset , field string , value interface {}, opts ... Option ) PutAssoc to changeset. func PutChange \u00b6 func PutChange ( ch * Changeset , field string , value interface {}, opts ... Option ) PutChange to changeset. func PutDefault \u00b6 func PutDefault ( ch * Changeset , field string , value interface {}, opts ... Option ) PutDefault to changeset. func UnescapeString \u00b6 func UnescapeString ( ch * Changeset , field string ) UnescapeString unescapes entities like \"<\" to become \"<\". this is helper for html.UnescapeString. func UniqueConstraint \u00b6 func UniqueConstraint ( ch * Changeset , field string , opts ... Option ) UniqueConstraint adds an unique constraint to changeset. func ValidateExclusion \u00b6 func ValidateExclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateExclusion validates a change is not included in the given values. func ValidateInclusion \u00b6 func ValidateInclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateInclusion validates a change is included in the given values. func ValidateMax \u00b6 func ValidateMax ( ch * Changeset , field string , max int , opts ... Option ) ValidateMax validates the value of given field is not larger than max. Validation can be performed against string, slice and numbers. func ValidateMin \u00b6 func ValidateMin ( ch * Changeset , field string , min int , opts ... Option ) ValidateMin validates the value of given field is not smaller than min. Validation can be performed against string, slice and numbers. func ValidatePattern \u00b6 func ValidatePattern ( ch * Changeset , field string , pattern string , opts ... Option ) ValidatePattern validates the value of given field to match given pattern. func ValidateRange \u00b6 func ValidateRange ( ch * Changeset , field string , min int , max int , opts ... Option ) ValidateRange validates the value of given field is not larger than max and not smaller than min. Validation can be performed against string, slice and numbers. func ValidateRegexp \u00b6 func ValidateRegexp ( ch * Changeset , field string , exp * regexp . Regexp , opts ... Option ) ValidateRegexp validates the value of given field to match given regexp. func ValidateRequired \u00b6 func ValidateRequired ( ch * Changeset , fields [] string , opts ... Option ) ValidateRequired validates that one or more fields are present in the changeset. It'll add error to changeset if field in the changes is nil or string made only of whitespace. type ChangeFunc \u00b6 type ChangeFunc func ( interface {}, params . Params ) * Changeset ChangeFunc is changeset function. type Changeset \u00b6 type Changeset struct { // contains filtered or unexported fields } Changeset used to cast and validate data before saving it to the database. func Cast \u00b6 func Cast ( data interface {}, params params . Params , fields [] string , opts ... Option ) * Changeset Cast params as changes for the given data according to the permitted fields. Returns a new changeset. params will only be added as changes if it does not have the same value as the field in the data. func Change \u00b6 func Change ( schema interface {}, changes ... map [ string ] interface {}) * Changeset Change make a new changeset without changes and build from given schema. Returns new Changeset. func Convert \u00b6 func Convert ( data interface {}) * Changeset Convert a struct as changeset, every field's value will be treated as changes. Returns a new changeset. PK changes in the changeset created with this function will be ignored func (*Changeset) Apply \u00b6 func ( c * Changeset ) Apply ( doc * rel . Document , mut * rel . Mutation ) Apply mutation. func (Changeset) Changes \u00b6 func ( c Changeset ) Changes () map [ string ] interface {} Changes of changeset. func (Changeset) Constraints \u00b6 func ( c Changeset ) Constraints () Constraints Constraints of changeset. func (Changeset) Error \u00b6 func ( c Changeset ) Error () error Error of changeset, returns the first error if any. func (Changeset) Errors \u00b6 func ( c Changeset ) Errors () [] error Errors of changeset. func (Changeset) Fetch \u00b6 func ( c Changeset ) Fetch ( field string ) interface {} Fetch a change or value from changeset. func (Changeset) Get \u00b6 func ( c Changeset ) Get ( field string ) interface {} Get a change from changeset. func (Changeset) Types \u00b6 func ( c Changeset ) Types () map [ string ] reflect . Type Types of changeset. func (Changeset) Values \u00b6 func ( c Changeset ) Values () map [ string ] interface {} Values of changeset. type Constraint \u00b6 type Constraint struct { Field string Message string Code int Name string Exact bool Type rel . ConstraintType } Constraint defines information to infer constraint error. type Constraints \u00b6 type Constraints [] Constraint Constraints is slice of Constraint func (Constraints) GetError \u00b6 func ( constraints Constraints ) GetError ( err error ) error GetError converts error based on constraints. If the original error is constraint error, and it's defined in the constraint list, then it'll be updated with constraint's message. If the original error is constraint error but not defined in the constraint list, it'll be converted to unexpected error. else it'll not modify the error. type Error \u00b6 type Error struct { Message string `json:\"message\"` Field string `json:\"field,omitempty\"` Code int `json:\"code,omitempty\"` Err error `json:\"-\"` } Error struct. func (Error) Error \u00b6 func ( e Error ) Error () string Error prints error message. func (Error) Unwrap \u00b6 func ( e Error ) Unwrap () error Unwrap internal error. type Option \u00b6 type Option func ( * Options ) Option for changeset operation. func ChangeOnly \u00b6 func ChangeOnly ( changeOnly bool ) Option ChangeOnly is used to define if validate is only check change func Code \u00b6 func Code ( code int ) Option Code for changeset operation's error. func EmptyValues \u00b6 func EmptyValues ( values ... interface {}) Option EmptyValues defines list of empty values when casting. default to [\"\"] func Exact \u00b6 func Exact ( exact bool ) Option Exact is used to define how index name is matched. func Message \u00b6 func Message ( message string ) Option Message for changeset operation's error. func Name \u00b6 func Name ( name string ) Option Name is used to define index name of constraints. func Required \u00b6 func Required ( required bool ) Option Required is used to define whether an assoc needs to be required or not. func SourceField \u00b6 func SourceField ( field string ) Option SourceField to define used field name in params. type Options \u00b6 type Options struct { // contains filtered or unexported fields } Options applicable to changeset.","title":"github.com/go-rel/changeset"},{"location":"reference/changeset/#changeset","text":"import \"github.com/go-rel/changeset\"","title":"changeset"},{"location":"reference/changeset/#overview","text":"Package changeset used to cast and validate data before saving it to the database. Package changeset used to cast and validate data before saving it to the database.","title":"Overview"},{"location":"reference/changeset/#variables","text":"var CastAssocErrorMessage = \"{field} is invalid\" CastAssocErrorMessage is the default error message for CastAssoc when its invalid. var CastAssocRequiredMessage = \"{field} is required\" CastAssocRequiredMessage is the default error message for CastAssoc when its missing. var CastErrorMessage = \"{field} is invalid\" CastErrorMessage is the default error message for Cast. var CheckConstraintMessage = \"{field} is invalid\" CheckConstraintMessage is the default error message for CheckConstraint. var ForeignKeyConstraintMessage = \"does not exist\" ForeignKeyConstraintMessage is the default error message for ForeignKeyConstraint. var PutAssocErrorMessage = \"{field} is invalid\" PutAssocErrorMessage is the default error message for PutAssoc. var PutChangeErrorMessage = \"{field} is invalid\" PutChangeErrorMessage is the default error message for PutChange. var PutDefaultErrorMessage = \"{field} is invalid\" PutDefaultErrorMessage is the default error message for PutDefault. var UniqueConstraintMessage = \"{field} has already been taken\" UniqueConstraintMessage is the default error message for UniqueConstraint. var ValidateExclusionErrorMessage = \"{field} must not be any of {values}\" ValidateExclusionErrorMessage is the default error message for ValidateExclusion. var ValidateInclusionErrorMessage = \"{field} must be one of {values}\" ValidateInclusionErrorMessage is the default error message for ValidateInclusion. var ValidateMaxErrorMessage = \"{field} must be less than {max}\" ValidateMaxErrorMessage is the default error message for ValidateMax. var ValidateMinErrorMessage = \"{field} must be more than {min}\" ValidateMinErrorMessage is the default error message for ValidateMin. var ValidatePatternErrorMessage = \"{field}'s format is invalid\" ValidatePatternErrorMessage is the default error message for ValidatePattern. var ValidateRangeErrorMessage = \"{field} must be between {min} and {max}\" ValidateRangeErrorMessage is the default error message for ValidateRange. var ValidateRegexpErrorMessage = \"{field}'s format is invalid\" ValidateRegexpErrorMessage is the default error message for ValidateRegexp. var ValidateRequiredErrorMessage = \"{field} is required\" ValidateRequiredErrorMessage is the default error message for ValidateRequired.","title":"Variables"},{"location":"reference/changeset/#func-adderror","text":"func AddError ( ch * Changeset , field string , message string ) AddError adds an error to changeset. ch := changeset.Cast(user, params, fields) changeset.AddError(ch, \"field\", \"error\") ch.Errors() // []errors.Error{{Field: \"field\", Message: \"error\"}}","title":"func AddError"},{"location":"reference/changeset/#func-applystring","text":"func ApplyString ( ch * Changeset , field string , fn func ( string ) string ) ApplyString apply a function for string value.","title":"func ApplyString"},{"location":"reference/changeset/#func-castassoc","text":"func CastAssoc ( ch * Changeset , field string , fn ChangeFunc , opts ... Option ) CastAssoc casts association changes using changeset function. Repo insert or update won't persist any changes generated by CastAssoc.","title":"func CastAssoc"},{"location":"reference/changeset/#func-checkconstraint","text":"func CheckConstraint ( ch * Changeset , field string , opts ... Option ) CheckConstraint adds an unique constraint to changeset.","title":"func CheckConstraint"},{"location":"reference/changeset/#func-deletechange","text":"func DeleteChange ( ch * Changeset , field string ) DeleteChange from changeset.","title":"func DeleteChange"},{"location":"reference/changeset/#func-escapestring","text":"func EscapeString ( ch * Changeset , fields ... string ) EscapeString escapes special characters like \"<\" to become \"<\". this is helper for html.EscapeString","title":"func EscapeString"},{"location":"reference/changeset/#func-foreignkeyconstraint","text":"func ForeignKeyConstraint ( ch * Changeset , field string , opts ... Option ) ForeignKeyConstraint adds an unique constraint to changeset.","title":"func ForeignKeyConstraint"},{"location":"reference/changeset/#func-putassoc","text":"func PutAssoc ( ch * Changeset , field string , value interface {}, opts ... Option ) PutAssoc to changeset.","title":"func PutAssoc"},{"location":"reference/changeset/#func-putchange","text":"func PutChange ( ch * Changeset , field string , value interface {}, opts ... Option ) PutChange to changeset.","title":"func PutChange"},{"location":"reference/changeset/#func-putdefault","text":"func PutDefault ( ch * Changeset , field string , value interface {}, opts ... Option ) PutDefault to changeset.","title":"func PutDefault"},{"location":"reference/changeset/#func-unescapestring","text":"func UnescapeString ( ch * Changeset , field string ) UnescapeString unescapes entities like \"<\" to become \"<\". this is helper for html.UnescapeString.","title":"func UnescapeString"},{"location":"reference/changeset/#func-uniqueconstraint","text":"func UniqueConstraint ( ch * Changeset , field string , opts ... Option ) UniqueConstraint adds an unique constraint to changeset.","title":"func UniqueConstraint"},{"location":"reference/changeset/#func-validateexclusion","text":"func ValidateExclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateExclusion validates a change is not included in the given values.","title":"func ValidateExclusion"},{"location":"reference/changeset/#func-validateinclusion","text":"func ValidateInclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateInclusion validates a change is included in the given values.","title":"func ValidateInclusion"},{"location":"reference/changeset/#func-validatemax","text":"func ValidateMax ( ch * Changeset , field string , max int , opts ... Option ) ValidateMax validates the value of given field is not larger than max. Validation can be performed against string, slice and numbers.","title":"func ValidateMax"},{"location":"reference/changeset/#func-validatemin","text":"func ValidateMin ( ch * Changeset , field string , min int , opts ... Option ) ValidateMin validates the value of given field is not smaller than min. Validation can be performed against string, slice and numbers.","title":"func ValidateMin"},{"location":"reference/changeset/#func-validatepattern","text":"func ValidatePattern ( ch * Changeset , field string , pattern string , opts ... Option ) ValidatePattern validates the value of given field to match given pattern.","title":"func ValidatePattern"},{"location":"reference/changeset/#func-validaterange","text":"func ValidateRange ( ch * Changeset , field string , min int , max int , opts ... Option ) ValidateRange validates the value of given field is not larger than max and not smaller than min. Validation can be performed against string, slice and numbers.","title":"func ValidateRange"},{"location":"reference/changeset/#func-validateregexp","text":"func ValidateRegexp ( ch * Changeset , field string , exp * regexp . Regexp , opts ... Option ) ValidateRegexp validates the value of given field to match given regexp.","title":"func ValidateRegexp"},{"location":"reference/changeset/#func-validaterequired","text":"func ValidateRequired ( ch * Changeset , fields [] string , opts ... Option ) ValidateRequired validates that one or more fields are present in the changeset. It'll add error to changeset if field in the changes is nil or string made only of whitespace.","title":"func ValidateRequired"},{"location":"reference/changeset/#type-changefunc","text":"type ChangeFunc func ( interface {}, params . Params ) * Changeset ChangeFunc is changeset function.","title":"type ChangeFunc"},{"location":"reference/changeset/#type-changeset","text":"type Changeset struct { // contains filtered or unexported fields } Changeset used to cast and validate data before saving it to the database.","title":"type Changeset"},{"location":"reference/changeset/#func-cast","text":"func Cast ( data interface {}, params params . Params , fields [] string , opts ... Option ) * Changeset Cast params as changes for the given data according to the permitted fields. Returns a new changeset. params will only be added as changes if it does not have the same value as the field in the data.","title":"func Cast"},{"location":"reference/changeset/#func-change","text":"func Change ( schema interface {}, changes ... map [ string ] interface {}) * Changeset Change make a new changeset without changes and build from given schema. Returns new Changeset.","title":"func Change"},{"location":"reference/changeset/#func-convert","text":"func Convert ( data interface {}) * Changeset Convert a struct as changeset, every field's value will be treated as changes. Returns a new changeset. PK changes in the changeset created with this function will be ignored","title":"func Convert"},{"location":"reference/changeset/#func-changeset-apply","text":"func ( c * Changeset ) Apply ( doc * rel . Document , mut * rel . Mutation ) Apply mutation.","title":"func (*Changeset) Apply"},{"location":"reference/changeset/#func-changeset-changes","text":"func ( c Changeset ) Changes () map [ string ] interface {} Changes of changeset.","title":"func (Changeset) Changes"},{"location":"reference/changeset/#func-changeset-constraints","text":"func ( c Changeset ) Constraints () Constraints Constraints of changeset.","title":"func (Changeset) Constraints"},{"location":"reference/changeset/#func-changeset-error","text":"func ( c Changeset ) Error () error Error of changeset, returns the first error if any.","title":"func (Changeset) Error"},{"location":"reference/changeset/#func-changeset-errors","text":"func ( c Changeset ) Errors () [] error Errors of changeset.","title":"func (Changeset) Errors"},{"location":"reference/changeset/#func-changeset-fetch","text":"func ( c Changeset ) Fetch ( field string ) interface {} Fetch a change or value from changeset.","title":"func (Changeset) Fetch"},{"location":"reference/changeset/#func-changeset-get","text":"func ( c Changeset ) Get ( field string ) interface {} Get a change from changeset.","title":"func (Changeset) Get"},{"location":"reference/changeset/#func-changeset-types","text":"func ( c Changeset ) Types () map [ string ] reflect . Type Types of changeset.","title":"func (Changeset) Types"},{"location":"reference/changeset/#func-changeset-values","text":"func ( c Changeset ) Values () map [ string ] interface {} Values of changeset.","title":"func (Changeset) Values"},{"location":"reference/changeset/#type-constraint","text":"type Constraint struct { Field string Message string Code int Name string Exact bool Type rel . ConstraintType } Constraint defines information to infer constraint error.","title":"type Constraint"},{"location":"reference/changeset/#type-constraints","text":"type Constraints [] Constraint Constraints is slice of Constraint","title":"type Constraints"},{"location":"reference/changeset/#func-constraints-geterror","text":"func ( constraints Constraints ) GetError ( err error ) error GetError converts error based on constraints. If the original error is constraint error, and it's defined in the constraint list, then it'll be updated with constraint's message. If the original error is constraint error but not defined in the constraint list, it'll be converted to unexpected error. else it'll not modify the error.","title":"func (Constraints) GetError"},{"location":"reference/changeset/#type-error","text":"type Error struct { Message string `json:\"message\"` Field string `json:\"field,omitempty\"` Code int `json:\"code,omitempty\"` Err error `json:\"-\"` } Error struct.","title":"type Error"},{"location":"reference/changeset/#func-error-error","text":"func ( e Error ) Error () string Error prints error message.","title":"func (Error) Error"},{"location":"reference/changeset/#func-error-unwrap","text":"func ( e Error ) Unwrap () error Unwrap internal error.","title":"func (Error) Unwrap"},{"location":"reference/changeset/#type-option","text":"type Option func ( * Options ) Option for changeset operation.","title":"type Option"},{"location":"reference/changeset/#func-changeonly","text":"func ChangeOnly ( changeOnly bool ) Option ChangeOnly is used to define if validate is only check change","title":"func ChangeOnly"},{"location":"reference/changeset/#func-code","text":"func Code ( code int ) Option Code for changeset operation's error.","title":"func Code"},{"location":"reference/changeset/#func-emptyvalues","text":"func EmptyValues ( values ... interface {}) Option EmptyValues defines list of empty values when casting. default to [\"\"]","title":"func EmptyValues"},{"location":"reference/changeset/#func-exact","text":"func Exact ( exact bool ) Option Exact is used to define how index name is matched.","title":"func Exact"},{"location":"reference/changeset/#func-message","text":"func Message ( message string ) Option Message for changeset operation's error.","title":"func Message"},{"location":"reference/changeset/#func-name","text":"func Name ( name string ) Option Name is used to define index name of constraints.","title":"func Name"},{"location":"reference/changeset/#func-required","text":"func Required ( required bool ) Option Required is used to define whether an assoc needs to be required or not.","title":"func Required"},{"location":"reference/changeset/#func-sourcefield","text":"func SourceField ( field string ) Option SourceField to define used field name in params.","title":"func SourceField"},{"location":"reference/changeset/#type-options","text":"type Options struct { // contains filtered or unexported fields } Options applicable to changeset.","title":"type Options"},{"location":"reference/group/","text":"group \u00b6 import \"github.com/go-rel/rel/group\" Overview \u00b6 Package group is syntatic sugar for building group query. Variables \u00b6 var ( // By is alias for rel.NewGroup By = rel . NewGroup // Fields is alias for rel.NewGroup Fields = rel . NewGroup )","title":"github.com/go-rel/rel/group"},{"location":"reference/group/#group","text":"import \"github.com/go-rel/rel/group\"","title":"group"},{"location":"reference/group/#overview","text":"Package group is syntatic sugar for building group query.","title":"Overview"},{"location":"reference/group/#variables","text":"var ( // By is alias for rel.NewGroup By = rel . NewGroup // Fields is alias for rel.NewGroup Fields = rel . NewGroup )","title":"Variables"},{"location":"reference/join/","text":"join \u00b6 import \"github.com/go-rel/rel/join\" Overview \u00b6 Package join is syntatic sugar for building join query. Variables \u00b6 var ( // Join is alias for rel.NewJoin Join = rel . NewJoin // On is alias for rel.NewJoinOn On = rel . NewJoinOn // Inner is alias for rel.NewInnerJoin Inner = rel . NewInnerJoin // InnerOn is alias for rel.NewInnerJoinOn InnerOn = rel . NewInnerJoinOn // Left is alias for rel.NewLeftJoin Left = rel . NewLeftJoin // LeftOn is alias for rel.NewLeftJoinOn LeftOn = rel . NewLeftJoinOn // Right is alias for rel.NewRightJoin Right = rel . NewRightJoin // RightOn is alias for rel.NewRightJoinOn RightOn = rel . NewRightJoinOn // Full is alias for rel.NewFullJoin Full = rel . NewFullJoin // FullOn is alias for rel.NewFullJoinOn FullOn = rel . NewFullJoinOn )","title":"github.com/go-rel/rel/join"},{"location":"reference/join/#join","text":"import \"github.com/go-rel/rel/join\"","title":"join"},{"location":"reference/join/#overview","text":"Package join is syntatic sugar for building join query.","title":"Overview"},{"location":"reference/join/#variables","text":"var ( // Join is alias for rel.NewJoin Join = rel . NewJoin // On is alias for rel.NewJoinOn On = rel . NewJoinOn // Inner is alias for rel.NewInnerJoin Inner = rel . NewInnerJoin // InnerOn is alias for rel.NewInnerJoinOn InnerOn = rel . NewInnerJoinOn // Left is alias for rel.NewLeftJoin Left = rel . NewLeftJoin // LeftOn is alias for rel.NewLeftJoinOn LeftOn = rel . NewLeftJoinOn // Right is alias for rel.NewRightJoin Right = rel . NewRightJoin // RightOn is alias for rel.NewRightJoinOn RightOn = rel . NewRightJoinOn // Full is alias for rel.NewFullJoin Full = rel . NewFullJoin // FullOn is alias for rel.NewFullJoinOn FullOn = rel . NewFullJoinOn )","title":"Variables"},{"location":"reference/migration/","text":"migration \u00b6 import \"github.com/go-rel/migration\" Overview \u00b6 type Migration \u00b6 type Migration struct { // contains filtered or unexported fields } Migration utility that handles migration logic. func New \u00b6 func New ( repo rel . Repository ) Migration New migration manager. func (*Migration) Instrumentation \u00b6 func ( m * Migration ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation function. func (*Migration) Migrate \u00b6 func ( m * Migration ) Migrate ( ctx context . Context ) Migrate to the latest schema version. func (*Migration) Register \u00b6 func ( m * Migration ) Register ( v int , up func ( schema * rel . Schema ), down func ( schema * rel . Schema )) Register a migration. func (*Migration) Rollback \u00b6 func ( m * Migration ) Rollback ( ctx context . Context ) Rollback migration 1 step.","title":"github.com/go-rel/migration"},{"location":"reference/migration/#migration","text":"import \"github.com/go-rel/migration\"","title":"migration"},{"location":"reference/migration/#overview","text":"","title":"Overview"},{"location":"reference/migration/#type-migration","text":"type Migration struct { // contains filtered or unexported fields } Migration utility that handles migration logic.","title":"type Migration"},{"location":"reference/migration/#func-new","text":"func New ( repo rel . Repository ) Migration New migration manager.","title":"func New"},{"location":"reference/migration/#func-migration-instrumentation","text":"func ( m * Migration ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation function.","title":"func (*Migration) Instrumentation"},{"location":"reference/migration/#func-migration-migrate","text":"func ( m * Migration ) Migrate ( ctx context . Context ) Migrate to the latest schema version.","title":"func (*Migration) Migrate"},{"location":"reference/migration/#func-migration-register","text":"func ( m * Migration ) Register ( v int , up func ( schema * rel . Schema ), down func ( schema * rel . Schema )) Register a migration.","title":"func (*Migration) Register"},{"location":"reference/migration/#func-migration-rollback","text":"func ( m * Migration ) Rollback ( ctx context . Context ) Rollback migration 1 step.","title":"func (*Migration) Rollback"},{"location":"reference/rel/","text":"rel \u00b6 import \"github.com/go-rel/rel\" Overview \u00b6 Package rel contains all rel primary APIs, such as Repository. Constants \u00b6 const ( // BelongsTo association. BelongsTo = iota // HasOne association. HasOne // HasMany association. HasMany ) Variables \u00b6 var ( // ErrNotFound returned when records not found. ErrNotFound = NotFoundError {} // ErrCheckConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrCheckConstraint). ErrCheckConstraint = ConstraintError { Type : CheckConstraint } // ErrNotNullConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrNotNullConstraint). ErrNotNullConstraint = ConstraintError { Type : NotNullConstraint } // ErrUniqueConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrUniqueConstraint). ErrUniqueConstraint = ConstraintError { Type : UniqueConstraint } // ErrPrimaryKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrPrimaryKeyConstraint). ErrPrimaryKeyConstraint = ConstraintError { Type : PrimaryKeyConstraint } // ErrForeignKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrForeignKeyConstraint). ErrForeignKeyConstraint = ConstraintError { Type : ForeignKeyConstraint } ) var ( // NewSortAsc sorts field with ascending sort. // // Deprecated: use SortAsc instead NewSortAsc = SortAsc // NewSortDesc sorts field with descending sort. // // Deprecated: use SortDesc instead NewSortDesc = SortDesc ) var Setf = SetFragment Setf is an alias for SetFragment func DefaultLogger \u00b6 func DefaultLogger ( ctx context . Context , op string , message string ) func ( err error ) DefaultLogger instrumentation to log queries and rel operation. func Nullable \u00b6 func Nullable ( dest interface {}) interface {} Nullable wrap value as a nullable sql.Scanner. If value returned from database is nil, nullable scanner will set dest to zero value. type Adapter \u00b6 type Adapter interface { Close () error Instrumentation ( instrumenter Instrumenter ) Ping ( ctx context . Context ) error Aggregate ( ctx context . Context , query Query , mode string , field string ) ( int , error ) Query ( ctx context . Context , query Query ) ( Cursor , error ) Insert ( ctx context . Context , query Query , primaryField string , mutates map [ string ] Mutate , onConflict OnConflict ) ( interface {}, error ) InsertAll ( ctx context . Context , query Query , primaryField string , fields [] string , bulkMutates [] map [ string ] Mutate , onConflict OnConflict ) ([] interface {}, error ) Update ( ctx context . Context , query Query , primaryField string , mutates map [ string ] Mutate ) ( int , error ) Delete ( ctx context . Context , query Query ) ( int , error ) Exec ( ctx context . Context , stmt string , args [] interface {}) ( int64 , int64 , error ) Begin ( ctx context . Context ) ( Adapter , error ) Commit ( ctx context . Context ) error Rollback ( ctx context . Context ) error Apply ( ctx context . Context , migration Migration ) error } Adapter interface type AlterTable \u00b6 type AlterTable struct { Table } AlterTable Migrator. func (*AlterTable) DropColumn \u00b6 func ( at * AlterTable ) DropColumn ( name string , options ... ColumnOption ) DropColumn from this table. func (*AlterTable) RenameColumn \u00b6 func ( at * AlterTable ) RenameColumn ( name string , newName string , options ... ColumnOption ) RenameColumn to a new name. type AssocMutation \u00b6 type AssocMutation struct { Mutations [] Mutation DeletedIDs [] interface {} // This is array of single id, and doesn't support composite primary key. } AssocMutation represents mutation for association. type Association \u00b6 type Association struct { // contains filtered or unexported fields } Association provides abstraction to work with association of document or collection. func (Association) Autoload \u00b6 func ( a Association ) Autoload () bool Autoload assoc setting when parent is loaded. func (Association) Autosave \u00b6 func ( a Association ) Autosave () bool Autosave setting when parent is created/updated/deleted. func (Association) Collection \u00b6 func ( a Association ) Collection () ( * Collection , bool ) Collection returns association target as collection. If association is zero, second return value will be false. func (Association) Document \u00b6 func ( a Association ) Document () ( * Document , bool ) Document returns association target as document. If association is zero, second return value will be false. func (Association) ForeignField \u00b6 func ( a Association ) ForeignField () string ForeignField of the association. func (Association) ForeignValue \u00b6 func ( a Association ) ForeignValue () interface {} ForeignValue of the association. It'll panic if association type is has many. func (Association) IsZero \u00b6 func ( a Association ) IsZero () bool IsZero returns true if association is not loaded. func (Association) LazyDocument \u00b6 func ( a Association ) LazyDocument () ( * Document , bool ) LazyDocument is a lazy version of Document. If rv is a null pointer, it returns a document that delays setting the value of rv until Document#Add() is called. func (Association) ReferenceField \u00b6 func ( a Association ) ReferenceField () string ReferenceField of the association. func (Association) ReferenceValue \u00b6 func ( a Association ) ReferenceValue () interface {} ReferenceValue of the association. func (Association) Through \u00b6 func ( a Association ) Through () string Through return intermediary association. func (Association) Type \u00b6 func ( a Association ) Type () AssociationType Type of association. type AssociationType \u00b6 type AssociationType uint8 AssociationType defines the type of association in database. type Cascade \u00b6 type Cascade bool Cascade enable or disable updating associations. Default to true. func (Cascade) Apply \u00b6 func ( c Cascade ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Cascade) Build \u00b6 func ( c Cascade ) Build ( query * Query ) Build query. func (Cascade) String \u00b6 func ( c Cascade ) String () string type ChangeOp \u00b6 type ChangeOp int ChangeOp represents type of mutate operation. const ( // ChangeInvalidOp operation. ChangeInvalidOp ChangeOp = iota // ChangeSetOp operation. ChangeSetOp // ChangeIncOp operation. ChangeIncOp // ChangeFragmentOp operation. ChangeFragmentOp ) type Changeset \u00b6 type Changeset struct { // contains filtered or unexported fields } Changeset mutator for structs. This allows REL to efficiently to perform update operation only on updated fields and association. The catch is, enabling changeset will duplicates the original struct values which consumes more memory. func NewChangeset \u00b6 func NewChangeset ( record interface {}) Changeset NewChangeset returns new changeset mutator for given record. func (Changeset) Apply \u00b6 func ( c Changeset ) Apply ( doc * Document , mut * Mutation ) Apply mutation. func (Changeset) Changes \u00b6 func ( c Changeset ) Changes () map [ string ] interface {} Changes returns map of changes. func (Changeset) FieldChanged \u00b6 func ( c Changeset ) FieldChanged ( field string ) bool FieldChanged returns true if field exists and it's already changed. returns false otherwise. type Collection \u00b6 type Collection struct { // contains filtered or unexported fields } Collection provides an abstraction over reflect to easily works with slice for database purpose. func NewCollection \u00b6 func NewCollection ( records interface {}, readonly ... bool ) * Collection NewCollection used to create abstraction to work with slice. COllection can be created using interface or reflect.Value. func (Collection) Add \u00b6 func ( c Collection ) Add () * Document Add new document into collection. func (Collection) Get \u00b6 func ( c Collection ) Get ( index int ) * Document Get an element from the underlying slice as a document. func (Collection) Len \u00b6 func ( c Collection ) Len () int Len of the underlying slice. func (Collection) PrimaryField \u00b6 func ( c Collection ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key. func (Collection) PrimaryFields \u00b6 func ( c Collection ) PrimaryFields () [] string PrimaryFields column name of this collection. func (Collection) PrimaryValue \u00b6 func ( c Collection ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key. func (Collection) PrimaryValues \u00b6 func ( c Collection ) PrimaryValues () [] interface {} PrimaryValues of collection. Returned value will be interface of slice interface. func (Collection) ReflectValue \u00b6 func ( c Collection ) ReflectValue () reflect . Value ReflectValue of referenced document. func (Collection) Reset \u00b6 func ( c Collection ) Reset () Reset underlying slice to be zero length. func (Collection) Slice \u00b6 func ( c Collection ) Slice ( i , j int ) * Collection Slice returns a new collection that is a slice of the original collection.s func (Collection) Swap \u00b6 func ( c Collection ) Swap ( i , j int ) Swap element in the collection. func (*Collection) Table \u00b6 func ( c * Collection ) Table () string Table returns name of the table. func (Collection) Truncate \u00b6 func ( c Collection ) Truncate ( i , j int ) Truncate collection. type Column \u00b6 type Column struct { Op SchemaOp Name string Type ColumnType Rename string Primary bool Unique bool Required bool Unsigned bool Limit int Precision int Scale int Default interface {} Options string } Column definition. type ColumnOption \u00b6 type ColumnOption interface { // contains filtered or unexported methods } ColumnOption interface. Available options are: Nil, Unsigned, Limit, Precision, Scale, Default, Comment, Options. func Default \u00b6 func Default ( def interface {}) ColumnOption Default allows to set a default value on the column.). type ColumnType \u00b6 type ColumnType string ColumnType definition. const ( // ID ColumnType. ID ColumnType = \"ID\" // BigID ColumnType. BigID ColumnType = \"BigID\" // Bool ColumnType. Bool ColumnType = \"BOOL\" // SmallInt ColumnType. SmallInt ColumnType = \"SMALLINT\" // Int ColumnType. Int ColumnType = \"INT\" // BigInt ColumnType. BigInt ColumnType = \"BIGINT\" // Float ColumnType. Float ColumnType = \"FLOAT\" // Decimal ColumnType. Decimal ColumnType = \"DECIMAL\" // String ColumnType. String ColumnType = \"STRING\" // Text ColumnType. Text ColumnType = \"TEXT\" // JSON ColumnType that will fallback to Text ColumnType if adapter does not support it. JSON ColumnType = \"JSON\" // Date ColumnType. Date ColumnType = \"DATE\" // DateTime ColumnType. DateTime ColumnType = \"DATETIME\" // Time ColumnType. Time ColumnType = \"TIME\" ) type ConstraintError \u00b6 type ConstraintError struct { Key string Type ConstraintType Err error } ConstraintError returned whenever constraint error encountered. func (ConstraintError) Error \u00b6 func ( ce ConstraintError ) Error () string Error message. func (ConstraintError) Is \u00b6 func ( ce ConstraintError ) Is ( target error ) bool Is returns true when target error have the same type and key if defined. func (ConstraintError) Unwrap \u00b6 func ( ce ConstraintError ) Unwrap () error Unwrap internal error returned by database driver. type ConstraintType \u00b6 type ConstraintType int8 ConstraintType defines the type of constraint error. const ( // CheckConstraint error type. CheckConstraint ConstraintType = iota // NotNullConstraint error type.1 NotNullConstraint // UniqueConstraint error type.1 UniqueConstraint // PrimaryKeyConstraint error type.1 PrimaryKeyConstraint // ForeignKeyConstraint error type.1 ForeignKeyConstraint ) func (ConstraintType) String \u00b6 func ( ct ConstraintType ) String () string String representation of the constraint type. type Cursor \u00b6 type Cursor interface { Close () error Fields () ([] string , error ) Next () bool Scan ( ... interface {}) error NopScanner () interface {} // TODO: conflict with manual scanners interface } Cursor is interface to work with database result (used by adapter). type Do \u00b6 type Do func ( Repository ) error Do used internally for schema migration. type Document \u00b6 type Document struct { // contains filtered or unexported fields } Document provides an abstraction over reflect to easily works with struct for database purpose. func NewDocument \u00b6 func NewDocument ( record interface {}, readonly ... bool ) * Document NewDocument used to create abstraction to work with struct. Document can be created using interface or reflect.Value. func (*Document) Add \u00b6 func ( d * Document ) Add () * Document Add returns this document. func (Document) Association \u00b6 func ( d Document ) Association ( name string ) Association Association of this document with given name. func (Document) BelongsTo \u00b6 func ( d Document ) BelongsTo () [] string BelongsTo fields of this document. func (Document) Fields \u00b6 func ( d Document ) Fields () [] string Fields returns list of fields available on this document. func (Document) Flag \u00b6 func ( d Document ) Flag ( flag DocumentFlag ) bool Flag returns true if struct contains specified flag. func (*Document) Get \u00b6 func ( d * Document ) Get ( index int ) * Document Get always returns this document, this is a noop for compatibility with collection. func (Document) HasMany \u00b6 func ( d Document ) HasMany () [] string HasMany fields of this document. func (Document) HasOne \u00b6 func ( d Document ) HasOne () [] string HasOne fields of this document. func (Document) Index \u00b6 func ( d Document ) Index () map [ string ][] int Index returns map of column name and it's struct index. func (*Document) Len \u00b6 func ( d * Document ) Len () int Len always returns 1 for document, this is a noop for compatibility with collection. func (Document) Persisted \u00b6 func ( d Document ) Persisted () bool Persisted returns true if document primary key is not zero. func (Document) Preload \u00b6 func ( d Document ) Preload () [] string Preload fields of this document. func (Document) PrimaryField \u00b6 func ( d Document ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key. func (Document) PrimaryFields \u00b6 func ( d Document ) PrimaryFields () [] string PrimaryFields column name of this document. func (Document) PrimaryValue \u00b6 func ( d Document ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key. func (Document) PrimaryValues \u00b6 func ( d Document ) PrimaryValues () [] interface {} PrimaryValues of this document. func (Document) ReflectValue \u00b6 func ( d Document ) ReflectValue () reflect . Value ReflectValue of referenced document. func (Document) Reset \u00b6 func ( d Document ) Reset () Reset this document, this is a noop for compatibility with collection. func (Document) Scanners \u00b6 func ( d Document ) Scanners ( fields [] string ) [] interface {} Scanners returns slice of sql.Scanner for given fields. func (Document) SetValue \u00b6 func ( d Document ) SetValue ( field string , value interface {}) bool SetValue of the field, it returns false if field does not exist, or it's not assignable. func (Document) Table \u00b6 func ( d Document ) Table () string Table returns name of the table. func (Document) Type \u00b6 func ( d Document ) Type ( field string ) ( reflect . Type , bool ) Type returns reflect.Type of given field. if field does not exist, second returns value will be false. func (Document) Value \u00b6 func ( d Document ) Value ( field string ) ( interface {}, bool ) Value returns value of given field. if field does not exist, second returns value will be false. type DocumentFlag \u00b6 type DocumentFlag int8 DocumentFlag stores information about document as a flag. const ( // Invalid flag. Invalid DocumentFlag = 1 << iota // HasCreatedAt flag. HasCreatedAt // HasUpdatedAt flag. HasUpdatedAt // HasDeletedAt flag. HasDeletedAt // HasDeleted flag. HasDeleted // Versioning HasVersioning ) func (DocumentFlag) Is \u00b6 func ( df DocumentFlag ) Is ( flag DocumentFlag ) bool Is returns true if it's defined. type ErrorFunc \u00b6 type ErrorFunc func ( error ) error ErrorFunc allows conversion REL's error to Application custom errors. func (ErrorFunc) Apply \u00b6 func ( ef ErrorFunc ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. type FilterOp \u00b6 type FilterOp int FilterOp defines enumeration of all supported filter types. const ( // FilterAndOp is filter type for and operator. FilterAndOp FilterOp = iota // FilterOrOp is filter type for or operator. FilterOrOp // FilterNotOp is filter type for not operator. FilterNotOp // FilterEqOp is filter type for equal comparison. FilterEqOp // FilterNeOp is filter type for not equal comparison. FilterNeOp // FilterLtOp is filter type for less than comparison. FilterLtOp // FilterLteOp is filter type for less than or equal comparison. FilterLteOp // FilterGtOp is filter type for greater than comparison. FilterGtOp // FilterGteOp is filter type for greter than or equal comparison. FilterGteOp // FilterNilOp is filter type for nil check. FilterNilOp // FilterNotNilOp is filter type for not nil check. FilterNotNilOp // FilterInOp is filter type for inclusion comparison. FilterInOp // FilterNinOp is filter type for not inclusion comparison. FilterNinOp // FilterLikeOp is filter type for like comparison. FilterLikeOp // FilterNotLikeOp is filter type for not like comparison. FilterNotLikeOp // FilterFragmentOp is filter type for custom filter. FilterFragmentOp ) func (FilterOp) String \u00b6 func ( fo FilterOp ) String () string type FilterQuery \u00b6 type FilterQuery struct { Type FilterOp Field string Value interface {} Inner [] FilterQuery } FilterQuery defines details of a condition type. func And \u00b6 func And ( inner ... FilterQuery ) FilterQuery And compares other filters using and. func Eq \u00b6 func Eq ( field string , value interface {}) FilterQuery Eq expression field equal to value. func FilterFragment \u00b6 func FilterFragment ( expr string , values ... interface {}) FilterQuery FilterFragment add custom filter. func Gt \u00b6 func Gt ( field string , value interface {}) FilterQuery Gt compares that left value is greater than to right value. func Gte \u00b6 func Gte ( field string , value interface {}) FilterQuery Gte compares that left value is greater than or equal to right value. func In \u00b6 func In ( field string , values ... interface {}) FilterQuery In check whethers value of the field is included in values. func InInt \u00b6 func InInt ( field string , values [] int ) FilterQuery InInt check whethers integer values of the field is included. func InString \u00b6 func InString ( field string , values [] string ) FilterQuery InString check whethers string values of the field is included. func InUint \u00b6 func InUint ( field string , values [] uint ) FilterQuery InUint check whethers unsigned integer values of the field is included. func Like \u00b6 func Like ( field string , pattern string ) FilterQuery Like compares value of field to match string pattern. func Lt \u00b6 func Lt ( field string , value interface {}) FilterQuery Lt compares that left value is less than to right value. func Lte \u00b6 func Lte ( field string , value interface {}) FilterQuery Lte compares that left value is less than or equal to right value. func Ne \u00b6 func Ne ( field string , value interface {}) FilterQuery Ne compares that left value is not equal to right value. func Nil \u00b6 func Nil ( field string ) FilterQuery Nil check whether field is nil. func Nin \u00b6 func Nin ( field string , values ... interface {}) FilterQuery Nin check whethers value of the field is not included in values. func NinInt \u00b6 func NinInt ( field string , values [] int ) FilterQuery NinInt check whethers integer values of the is not included. func NinString \u00b6 func NinString ( field string , values [] string ) FilterQuery NinString check whethers string values of the is not included. func NinUint \u00b6 func NinUint ( field string , values [] uint ) FilterQuery NinUint check whethers unsigned integer values of the is not included. func Not \u00b6 func Not ( inner ... FilterQuery ) FilterQuery Not wraps filters using not. It'll negate the filter type if possible. func NotLike \u00b6 func NotLike ( field string , pattern string ) FilterQuery NotLike compares value of field to not match string pattern. func NotNil \u00b6 func NotNil ( field string ) FilterQuery NotNil check whether field is not nil. func Or \u00b6 func Or ( inner ... FilterQuery ) FilterQuery Or compares other filters using or. func (FilterQuery) And \u00b6 func ( fq FilterQuery ) And ( filters ... FilterQuery ) FilterQuery And wraps filters using and. func (FilterQuery) AndEq \u00b6 func ( fq FilterQuery ) AndEq ( field string , value interface {}) FilterQuery AndEq append equal expression using and. func (FilterQuery) AndFragment \u00b6 func ( fq FilterQuery ) AndFragment ( expr string , values ... interface {}) FilterQuery AndFragment append fragment using and. func (FilterQuery) AndGt \u00b6 func ( fq FilterQuery ) AndGt ( field string , value interface {}) FilterQuery AndGt append greater than expression using and. func (FilterQuery) AndGte \u00b6 func ( fq FilterQuery ) AndGte ( field string , value interface {}) FilterQuery AndGte append greater than or equal expression using and. func (FilterQuery) AndIn \u00b6 func ( fq FilterQuery ) AndIn ( field string , values ... interface {}) FilterQuery AndIn append is in expression using and. func (FilterQuery) AndLike \u00b6 func ( fq FilterQuery ) AndLike ( field string , pattern string ) FilterQuery AndLike append like expression using and. func (FilterQuery) AndLt \u00b6 func ( fq FilterQuery ) AndLt ( field string , value interface {}) FilterQuery AndLt append lesser than expression using and. func (FilterQuery) AndLte \u00b6 func ( fq FilterQuery ) AndLte ( field string , value interface {}) FilterQuery AndLte append lesser than or equal expression using and. func (FilterQuery) AndNe \u00b6 func ( fq FilterQuery ) AndNe ( field string , value interface {}) FilterQuery AndNe append not equal expression using and. func (FilterQuery) AndNil \u00b6 func ( fq FilterQuery ) AndNil ( field string ) FilterQuery AndNil append is nil expression using and. func (FilterQuery) AndNin \u00b6 func ( fq FilterQuery ) AndNin ( field string , values ... interface {}) FilterQuery AndNin append is not in expression using and. func (FilterQuery) AndNotLike \u00b6 func ( fq FilterQuery ) AndNotLike ( field string , pattern string ) FilterQuery AndNotLike append not like expression using and. func (FilterQuery) AndNotNil \u00b6 func ( fq FilterQuery ) AndNotNil ( field string ) FilterQuery AndNotNil append is not nil expression using and. func (FilterQuery) Build \u00b6 func ( fq FilterQuery ) Build ( query * Query ) Build Filter query. func (FilterQuery) None \u00b6 func ( fq FilterQuery ) None () bool None returns true if no filter is specified. func (FilterQuery) Or \u00b6 func ( fq FilterQuery ) Or ( filter ... FilterQuery ) FilterQuery Or wraps filters using or. func (FilterQuery) OrEq \u00b6 func ( fq FilterQuery ) OrEq ( field string , value interface {}) FilterQuery OrEq append equal expression using or. func (FilterQuery) OrFragment \u00b6 func ( fq FilterQuery ) OrFragment ( expr string , values ... interface {}) FilterQuery OrFragment append fragment using or. func (FilterQuery) OrGt \u00b6 func ( fq FilterQuery ) OrGt ( field string , value interface {}) FilterQuery OrGt append greater than expression using or. func (FilterQuery) OrGte \u00b6 func ( fq FilterQuery ) OrGte ( field string , value interface {}) FilterQuery OrGte append greater than or equal expression using or. func (FilterQuery) OrIn \u00b6 func ( fq FilterQuery ) OrIn ( field string , values ... interface {}) FilterQuery OrIn append is in expression using or. func (FilterQuery) OrLike \u00b6 func ( fq FilterQuery ) OrLike ( field string , pattern string ) FilterQuery OrLike append like expression using or. func (FilterQuery) OrLt \u00b6 func ( fq FilterQuery ) OrLt ( field string , value interface {}) FilterQuery OrLt append lesser than expression using or. func (FilterQuery) OrLte \u00b6 func ( fq FilterQuery ) OrLte ( field string , value interface {}) FilterQuery OrLte append lesser than or equal expression using or. func (FilterQuery) OrNe \u00b6 func ( fq FilterQuery ) OrNe ( field string , value interface {}) FilterQuery OrNe append not equal expression using or. func (FilterQuery) OrNil \u00b6 func ( fq FilterQuery ) OrNil ( field string ) FilterQuery OrNil append is nil expression using or. func (FilterQuery) OrNin \u00b6 func ( fq FilterQuery ) OrNin ( field string , values ... interface {}) FilterQuery OrNin append is not in expression using or. func (FilterQuery) OrNotLike \u00b6 func ( fq FilterQuery ) OrNotLike ( field string , pattern string ) FilterQuery OrNotLike append not like expression using or. func (FilterQuery) OrNotNil \u00b6 func ( fq FilterQuery ) OrNotNil ( field string ) FilterQuery OrNotNil append is not nil expression using or. func (FilterQuery) String \u00b6 func ( fq FilterQuery ) String () string type ForeignKeyReference \u00b6 type ForeignKeyReference struct { Table string Columns [] string OnDelete string OnUpdate string } ForeignKeyReference definition. type GroupQuery \u00b6 type GroupQuery struct { Fields [] string Filter FilterQuery } GroupQuery defines group clause of the query. func NewGroup \u00b6 func NewGroup ( fields ... string ) GroupQuery NewGroup query. func (GroupQuery) Build \u00b6 func ( gq GroupQuery ) Build ( query * Query ) Build query. func (GroupQuery) Having \u00b6 func ( gq GroupQuery ) Having ( filters ... FilterQuery ) GroupQuery Having appends filter for group query with and operand. func (GroupQuery) OrHaving \u00b6 func ( gq GroupQuery ) OrHaving ( filters ... FilterQuery ) GroupQuery OrHaving appends filter for group query with or operand. func (GroupQuery) OrWhere \u00b6 func ( gq GroupQuery ) OrWhere ( filters ... FilterQuery ) GroupQuery OrWhere is alias for OrHaving. func (GroupQuery) Where \u00b6 func ( gq GroupQuery ) Where ( filters ... FilterQuery ) GroupQuery Where is alias for having. type Index \u00b6 type Index struct { Op SchemaOp Table string Name string Unique bool Columns [] string Optional bool Filter FilterQuery Options string } Index definition. type IndexOption \u00b6 type IndexOption interface { // contains filtered or unexported methods } IndexOption interface. Available options are: Comment, Options. type Instrumenter \u00b6 type Instrumenter func ( ctx context . Context , op string , message string ) func ( err error ) Instrumenter defines function type that can be used for instrumetation. This function should return a function with no argument as a callback for finished execution. func (Instrumenter) Observe \u00b6 func ( i Instrumenter ) Observe ( ctx context . Context , op string , message string ) func ( err error ) Observe operation. type Iterator \u00b6 type Iterator interface { io . Closer Next ( record interface {}) error } Iterator allows iterating through all record in database in batch. type IteratorOption \u00b6 type IteratorOption interface { // contains filtered or unexported methods } IteratorOption is used to configure iteration behaviour, such as batch size, start id and finish id. func BatchSize \u00b6 func BatchSize ( size int ) IteratorOption BatchSize specifies the size of iterator batch. Defaults to 1000. func Finish \u00b6 func Finish ( id ... interface {}) IteratorOption Finish specifies the primary value to finish at (inclusive). func Start \u00b6 func Start ( id ... interface {}) IteratorOption Start specifies the primary value to start from (inclusive). type JoinQuery \u00b6 type JoinQuery struct { Mode string Table string From string To string Filter FilterQuery Arguments [] interface {} } JoinQuery defines join clause in query. func NewFullJoin \u00b6 func NewFullJoin ( table string , filter ... FilterQuery ) JoinQuery NewFullJoin with given table and optional filter. func NewFullJoinOn \u00b6 func NewFullJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewFullJoinOn table with given field and optional additional filter. func NewInnerJoin \u00b6 func NewInnerJoin ( table string , filter ... FilterQuery ) JoinQuery NewInnerJoin with given table and optional filter. func NewInnerJoinOn \u00b6 func NewInnerJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewInnerJoinOn table with given field and optional additional filter. func NewJoin \u00b6 func NewJoin ( table string , filter ... FilterQuery ) JoinQuery NewJoin with given table. func NewJoinFragment \u00b6 func NewJoinFragment ( expr string , args ... interface {}) JoinQuery NewJoinFragment defines a join clause using raw query. func NewJoinOn \u00b6 func NewJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewJoinOn table with given field and optional additional filter. func NewJoinWith \u00b6 func NewJoinWith ( mode string , table string , from string , to string , filter ... FilterQuery ) JoinQuery NewJoinWith query with custom join mode, table, field and additional filters with AND condition. func NewLeftJoin \u00b6 func NewLeftJoin ( table string , filter ... FilterQuery ) JoinQuery NewLeftJoin with given table and optional filter. func NewLeftJoinOn \u00b6 func NewLeftJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewLeftJoinOn table with given field and optional additional filter. func NewRightJoin \u00b6 func NewRightJoin ( table string , filter ... FilterQuery ) JoinQuery NewRightJoin with given table and optional filter. func NewRightJoinOn \u00b6 func NewRightJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewRightJoinOn table with given field and optional additional filter. func (JoinQuery) Build \u00b6 func ( jq JoinQuery ) Build ( query * Query ) Build query. type Key \u00b6 type Key struct { Op SchemaOp Name string Type KeyType Columns [] string Rename string Reference ForeignKeyReference Options string } Key definition. type KeyOption \u00b6 type KeyOption interface { // contains filtered or unexported methods } KeyOption interface. Available options are: Comment, Options. type KeyType \u00b6 type KeyType string KeyType definition. const ( // PrimaryKey KeyType. PrimaryKey KeyType = \"PRIMARY KEY\" // ForeignKey KeyType. ForeignKey KeyType = \"FOREIGN KEY\" // UniqueKey KeyType. UniqueKey = \"UNIQUE\" ) type Limit \u00b6 type Limit int Limit options. When passed as query, it limits returned result from database. When passed as column option, it sets the maximum size of the string/text/binary/integer columns. func (Limit) Build \u00b6 func ( l Limit ) Build ( query * Query ) Build query. type Lock \u00b6 type Lock string Lock query. This query will be ignored if used outside of transaction. func ForUpdate \u00b6 func ForUpdate () Lock ForUpdate lock query. func (Lock) Build \u00b6 func ( l Lock ) Build ( query * Query ) Build query. type Map \u00b6 type Map map [ string ] interface {} Map can be used as mutation for repository insert or update operation. This allows inserting or updating only on specified field. Insert/Update of has one or belongs to can be done using other Map as a value. Insert/Update of has many can be done using slice of Map as a value. Map is intended to be used internally within application, and not to be exposed directly as an APIs. func (Map) Apply \u00b6 func ( m Map ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Map) String \u00b6 func ( m Map ) String () string type Migration \u00b6 type Migration interface { // contains filtered or unexported methods } Migration definition. type Mutate \u00b6 type Mutate struct { Type ChangeOp Field string Value interface {} } Mutate stores mutation instruction. func Dec \u00b6 func Dec ( field string ) Mutate Dec create a mutate using deccrement operation. func DecBy \u00b6 func DecBy ( field string , n int ) Mutate DecBy create a mutate using decrement operation with custom decrement value. func Inc \u00b6 func Inc ( field string ) Mutate Inc create a mutate using increment operation. func IncBy \u00b6 func IncBy ( field string , n int ) Mutate IncBy create a mutate using increment operation with custom increment value. func Set \u00b6 func Set ( field string , value interface {}) Mutate Set create a mutate using set operation. func SetFragment \u00b6 func SetFragment ( raw string , args ... interface {}) Mutate SetFragment create a mutate operation using fragment operation. Only available for Update. func (Mutate) Apply \u00b6 func ( m Mutate ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Mutate) String \u00b6 func ( m Mutate ) String () string String representation type Mutation \u00b6 type Mutation struct { Mutates map [ string ] Mutate Assoc map [ string ] AssocMutation OnConflict OnConflict Unscoped Unscoped Reload Reload Cascade Cascade ErrorFunc ErrorFunc } Mutation represents value to be inserted or updated to database. It's not safe to be used multiple time. some operation my alter mutation data. func Apply \u00b6 func Apply ( doc * Document , mutators ... Mutator ) Mutation Apply using given mutators. func (*Mutation) Add \u00b6 func ( m * Mutation ) Add ( mut Mutate ) Add a mutate. func (*Mutation) IsAssocEmpty \u00b6 func ( m * Mutation ) IsAssocEmpty () bool IsAssocEmpty returns true if no assoc's mutation is defined. func (*Mutation) IsEmpty \u00b6 func ( m * Mutation ) IsEmpty () bool IsEmpty returns true if no mutates operation and assoc's mutation is defined. func (*Mutation) IsMutatesEmpty \u00b6 func ( m * Mutation ) IsMutatesEmpty () bool IsMutatesEmpty returns true if no mutates operation is defined. func (*Mutation) SetAssoc \u00b6 func ( m * Mutation ) SetAssoc ( field string , muts ... Mutation ) SetAssoc mutation. func (*Mutation) SetDeletedIDs \u00b6 func ( m * Mutation ) SetDeletedIDs ( field string , ids [] interface {}) SetDeletedIDs mutation. nil slice will clear association. type Mutator \u00b6 type Mutator interface { Apply ( doc * Document , mutation * Mutation ) } Mutator is interface for a record mutator. type Name \u00b6 type Name string Name option for defining custom index name. type NotFoundError \u00b6 type NotFoundError struct {} NotFoundError returned whenever Find returns no result. func (NotFoundError) Error \u00b6 func ( nfe NotFoundError ) Error () string Error message. func (NotFoundError) Is \u00b6 func ( nfe NotFoundError ) Is ( target error ) bool Is returns true when target error is sql.ErrNoRows. type NowFunc \u00b6 type NowFunc func () time . Time NowFunc is the type of function that returns the current time. var ( Now NowFunc = func () time . Time { return time . Now (). Truncate ( time . Second ) } ) type Offset \u00b6 type Offset int Offset Query. func (Offset) Build \u00b6 func ( o Offset ) Build ( query * Query ) Build query. type OnConflict \u00b6 type OnConflict struct { Keys [] string Ignore bool Replace bool Fragment string FragmentArgs [] interface {} } OnConflict mutation. func OnConflictFragment \u00b6 func OnConflictFragment ( sql string , args ... interface {}) OnConflict OnConflictFragment allows to write custom sql for on conflict. This will add custom sql after ON CONFLICT, example: ON CONFLICT [FRAGMENT] func OnConflictIgnore \u00b6 func OnConflictIgnore () OnConflict OnConflictIgnore insertion when conflict happens. func OnConflictKeyIgnore \u00b6 func OnConflictKeyIgnore ( key string ) OnConflict OnConflictKeyIgnore insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored. func OnConflictKeyReplace \u00b6 func OnConflictKeyReplace ( key string ) OnConflict OnConflictKeyReplace insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored. func OnConflictKeysIgnore \u00b6 func OnConflictKeysIgnore ( keys [] string ) OnConflict OnConflictKeysIgnore insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored. func OnConflictKeysReplace \u00b6 func OnConflictKeysReplace ( keys [] string ) OnConflict OnConflictKeysReplace insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored. func OnConflictReplace \u00b6 func OnConflictReplace () OnConflict OnConflictReplace insertion when conflict happens. func (OnConflict) Apply \u00b6 func ( ocm OnConflict ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. type OnDelete \u00b6 type OnDelete string OnDelete option for foreign key. type OnUpdate \u00b6 type OnUpdate string OnUpdate option for foreign key. type Optional \u00b6 type Optional bool Optional option. when used with create table, will create table only if it's not exists. when used with drop table, will drop table only if it's exists. type Options \u00b6 type Options string Options options for table, column and index. type Precision \u00b6 type Precision int Precision defines the precision for the decimal fields, representing the total number of digits in the number. type Preload \u00b6 type Preload string Preload query. func (Preload) Build \u00b6 func ( p Preload ) Build ( query * Query ) Build query. type Primary \u00b6 type Primary bool Primary set column as primary. type Querier \u00b6 type Querier interface { Build ( * Query ) } Querier interface defines contract to be used for query builder. type Query \u00b6 type Query struct { Table string SelectQuery SelectQuery JoinQuery [] JoinQuery WhereQuery FilterQuery GroupQuery GroupQuery SortQuery [] SortQuery OffsetQuery Offset LimitQuery Limit LockQuery Lock SQLQuery SQLQuery UnscopedQuery Unscoped ReloadQuery Reload CascadeQuery Cascade PreloadQuery [] string UsePrimaryDb bool // contains filtered or unexported fields } Query defines information about query generated by query builder. func Build \u00b6 func Build ( table string , queriers ... Querier ) Query Build for given table using given queriers. func From \u00b6 func From ( table string ) Query From create a query with chainable syntax, using from as the starting point. func Join \u00b6 func Join ( table string , filter ... FilterQuery ) Query Join create a query with chainable syntax, using join as the starting point. func JoinOn \u00b6 func JoinOn ( table string , from string , to string , filter ... FilterQuery ) Query JoinOn create a query with chainable syntax, using join as the starting point. func JoinWith \u00b6 func JoinWith ( mode string , table string , from string , to string , filter ... FilterQuery ) Query JoinWith create a query with chainable syntax, using join as the starting point. func Joinf \u00b6 func Joinf ( expr string , args ... interface {}) Query Joinf create a query with chainable syntax, using join as the starting point. func Select \u00b6 func Select ( fields ... string ) Query Select query create a query with chainable syntax, using select as the starting point. func UsePrimary \u00b6 func UsePrimary () Query func Where \u00b6 func Where ( filters ... FilterQuery ) Query Where create a query with chainable syntax, using where as the starting point. func (Query) Build \u00b6 func ( q Query ) Build ( query * Query ) Build query. func (Query) Cascade \u00b6 func ( q Query ) Cascade ( c bool ) Query Cascade enable/disable autoload association on Find and FindAll query. func (Query) Distinct \u00b6 func ( q Query ) Distinct () Query Distinct sets select query to be distinct. func (Query) From \u00b6 func ( q Query ) From ( table string ) Query From set the table to be used for query. func (Query) Group \u00b6 func ( q Query ) Group ( fields ... string ) Query Group query. func (Query) Having \u00b6 func ( q Query ) Having ( filters ... FilterQuery ) Query Having query. func (Query) Havingf \u00b6 func ( q Query ) Havingf ( expr string , args ... interface {}) Query Havingf create having query using a raw query. func (Query) Join \u00b6 func ( q Query ) Join ( table string , filter ... FilterQuery ) Query Join current table with other table. func (Query) JoinOn \u00b6 func ( q Query ) JoinOn ( table string , from string , to string , filter ... FilterQuery ) Query JoinOn current table with other table. func (Query) JoinWith \u00b6 func ( q Query ) JoinWith ( mode string , table string , from string , to string , filter ... FilterQuery ) Query JoinWith current table with other table with custom join mode. func (Query) Joinf \u00b6 func ( q Query ) Joinf ( expr string , args ... interface {}) Query Joinf create join query using a raw query. func (Query) Limit \u00b6 func ( q Query ) Limit ( limit int ) Query Limit result returned by database. func (Query) Lock \u00b6 func ( q Query ) Lock ( lock string ) Query Lock query expression. func (Query) Offset \u00b6 func ( q Query ) Offset ( offset int ) Query Offset the result returned by database. func (Query) OrHaving \u00b6 func ( q Query ) OrHaving ( filters ... FilterQuery ) Query OrHaving query. func (Query) OrHavingf \u00b6 func ( q Query ) OrHavingf ( expr string , args ... interface {}) Query OrHavingf create having query using a raw query. func (Query) OrWhere \u00b6 func ( q Query ) OrWhere ( filters ... FilterQuery ) Query OrWhere query. func (Query) OrWheref \u00b6 func ( q Query ) OrWheref ( expr string , args ... interface {}) Query OrWheref create where query using a raw query. func (Query) Preload \u00b6 func ( q Query ) Preload ( field string ) Query Preload field association. func (Query) Reload \u00b6 func ( q Query ) Reload () Query Reload force reloading association on preload. func (Query) Select \u00b6 func ( q Query ) Select ( fields ... string ) Query Select filter fields to be selected from database. func (Query) Sort \u00b6 func ( q Query ) Sort ( fields ... string ) Query Sort query. func (Query) SortAsc \u00b6 func ( q Query ) SortAsc ( fields ... string ) Query SortAsc query. func (Query) SortDesc \u00b6 func ( q Query ) SortDesc ( fields ... string ) Query SortDesc query. func (Query) String \u00b6 func ( q Query ) String () string String describe query as string. func (Query) Unscoped \u00b6 func ( q Query ) Unscoped () Query Unscoped allows soft-delete to be ignored. func (Query) UsePrimary \u00b6 func ( q Query ) UsePrimary () Query UsePrimary database. func (Query) Where \u00b6 func ( q Query ) Where ( filters ... FilterQuery ) Query Where query. func (Query) Wheref \u00b6 func ( q Query ) Wheref ( expr string , args ... interface {}) Query Wheref create where query using a raw query. type Raw \u00b6 type Raw string Raw string type Reload \u00b6 type Reload bool Reload force reload after insert/update. Default to false. func (Reload) Apply \u00b6 func ( r Reload ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Reload) Build \u00b6 func ( r Reload ) Build ( query * Query ) Build query. type Repository \u00b6 type Repository interface { // Adapter used in this repository. Adapter ( ctx context . Context ) Adapter // Instrumentation defines callback to be used as instrumenter. Instrumentation ( instrumenter Instrumenter ) // Ping database. Ping ( ctx context . Context ) error // Iterate through a collection of records from database in batches. // This function returns iterator that can be used to loop all records. // Limit, Offset and Sort query is automatically ignored. Iterate ( ctx context . Context , query Query , option ... IteratorOption ) Iterator // Aggregate over the given field. // Supported aggregate: count, sum, avg, max, min. // Any select, group, offset, limit and sort query will be ignored automatically. // If complex aggregation is needed, consider using All instead. Aggregate ( ctx context . Context , query Query , aggregate string , field string ) ( int , error ) // MustAggregate over the given field. // Supported aggregate: count, sum, avg, max, min. // Any select, group, offset, limit and sort query will be ignored automatically. // If complex aggregation is needed, consider using All instead. // It'll panic if any error eccured. MustAggregate ( ctx context . Context , query Query , aggregate string , field string ) int // Count records that match the query. Count ( ctx context . Context , collection string , queriers ... Querier ) ( int , error ) // MustCount records that match the query. // It'll panic if any error eccured. MustCount ( ctx context . Context , collection string , queriers ... Querier ) int // Find a record that match the query. // If no result found, it'll return not found error. Find ( ctx context . Context , record interface {}, queriers ... Querier ) error // MustFind a record that match the query. // If no result found, it'll panic. MustFind ( ctx context . Context , record interface {}, queriers ... Querier ) // FindAll records that match the query. FindAll ( ctx context . Context , records interface {}, queriers ... Querier ) error // MustFindAll records that match the query. // It'll panic if any error eccured. MustFindAll ( ctx context . Context , records interface {}, queriers ... Querier ) // FindAndCountAll records that match the query. // This is a convenient method that combines FindAll and Count. It's useful when dealing with queries related to pagination. // Limit and Offset property will be ignored when performing count query. FindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) ( int , error ) // MustFindAndCountAll records that match the query. // This is a convenient method that combines FindAll and Count. It's useful when dealing with queries related to pagination. // Limit and Offset property will be ignored when performing count query. // It'll panic if any error eccured. MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) int // Insert a record to database. Insert ( ctx context . Context , record interface {}, mutators ... Mutator ) error // MustInsert an record to database. // It'll panic if any error occurred. MustInsert ( ctx context . Context , record interface {}, mutators ... Mutator ) // InsertAll records. // Does not supports application cascade insert. InsertAll ( ctx context . Context , records interface {}, mutators ... Mutator ) error // MustInsertAll records. // It'll panic if any error occurred. // Does not supports application cascade insert. MustInsertAll ( ctx context . Context , records interface {}, mutators ... Mutator ) // Update a record in database. // It'll panic if any error occurred. Update ( ctx context . Context , record interface {}, mutators ... Mutator ) error // MustUpdate a record in database. // It'll panic if any error occurred. MustUpdate ( ctx context . Context , record interface {}, mutators ... Mutator ) // UpdateAny records tha match the query. // Returns number of updated records and error. UpdateAny ( ctx context . Context , query Query , mutates ... Mutate ) ( int , error ) // MustUpdateAny records that match the query. // It'll panic if any error occurred. // Returns number of updated records. MustUpdateAny ( ctx context . Context , query Query , mutates ... Mutate ) int // Delete a record. Delete ( ctx context . Context , record interface {}, mutators ... Mutator ) error // MustDelete a record. // It'll panic if any error eccured. MustDelete ( ctx context . Context , record interface {}, mutators ... Mutator ) // DeleteAll records. // Does not supports application cascade delete. DeleteAll ( ctx context . Context , records interface {}) error // MustDeleteAll records. // It'll panic if any error occurred. // Does not supports application cascade delete. MustDeleteAll ( ctx context . Context , records interface {}) // DeleteAny records that match the query. // Returns number of deleted records and error. DeleteAny ( ctx context . Context , query Query ) ( int , error ) // MustDeleteAny records that match the query. // It'll panic if any error eccured. // Returns number of updated records. MustDeleteAny ( ctx context . Context , query Query ) int // Preload association with given query. // This function can accepts either a struct or a slice of structs. // If association is already loaded, this will do nothing. // To force preloading even though association is already loaeded, add `Reload(true)` as query. Preload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) error // MustPreload association with given query. // This function can accepts either a struct or a slice of structs. // It'll panic if any error occurred. MustPreload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) // Exec raw statement. // Returns last inserted id, rows affected and error. Exec ( ctx context . Context , statement string , args ... interface {}) ( int , int , error ) // MustExec raw statement. // Returns last inserted id, rows affected and error. MustExec ( ctx context . Context , statement string , args ... interface {}) ( int , int ) // Transaction performs transaction with given function argument. // Transaction scope/connection is automatically passed using context. Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error } Repository for interacting with database. func New \u00b6 func New ( adapter Adapter ) Repository New create new repo using adapter. type Required \u00b6 type Required bool Required disallows nil values in the column. type SQLQuery \u00b6 type SQLQuery struct { Statement string Values [] interface {} } SQLQuery allows querying using native query supported by database. func SQL \u00b6 func SQL ( statement string , values ... interface {}) SQLQuery SQL Query. func (SQLQuery) Build \u00b6 func ( sq SQLQuery ) Build ( query * Query ) Build Raw Query. func (SQLQuery) String \u00b6 func ( sq SQLQuery ) String () string type Scale \u00b6 type Scale int Scale Defines the scale for the decimal fields, representing the number of digits after the decimal point. type Schema \u00b6 type Schema struct { Migrations [] Migration } Schema builder. func (*Schema) AddColumn \u00b6 func ( s * Schema ) AddColumn ( table string , name string , typ ColumnType , options ... ColumnOption ) AddColumn with name and type. func (*Schema) AlterTable \u00b6 func ( s * Schema ) AlterTable ( name string , fn func ( t * AlterTable ), options ... TableOption ) AlterTable with name and its definition. func (*Schema) CreateIndex \u00b6 func ( s * Schema ) CreateIndex ( table string , name string , column [] string , options ... IndexOption ) CreateIndex for columns on a table. func (*Schema) CreateTable \u00b6 func ( s * Schema ) CreateTable ( name string , fn func ( t * Table ), options ... TableOption ) CreateTable with name and its definition. func (*Schema) CreateTableIfNotExists \u00b6 func ( s * Schema ) CreateTableIfNotExists ( name string , fn func ( t * Table ), options ... TableOption ) CreateTableIfNotExists with name and its definition. func (*Schema) CreateUniqueIndex \u00b6 func ( s * Schema ) CreateUniqueIndex ( table string , name string , column [] string , options ... IndexOption ) CreateUniqueIndex for columns on a table. func (*Schema) Do \u00b6 func ( s * Schema ) Do ( fn Do ) Do migration using golang codes. func (*Schema) DropColumn \u00b6 func ( s * Schema ) DropColumn ( table string , name string , options ... ColumnOption ) DropColumn by name. func (*Schema) DropIndex \u00b6 func ( s * Schema ) DropIndex ( table string , name string , options ... IndexOption ) DropIndex by name. func (*Schema) DropTable \u00b6 func ( s * Schema ) DropTable ( name string , options ... TableOption ) DropTable by name. func (*Schema) DropTableIfExists \u00b6 func ( s * Schema ) DropTableIfExists ( name string , options ... TableOption ) DropTableIfExists by name. func (*Schema) Exec \u00b6 func ( s * Schema ) Exec ( raw Raw ) Exec queries. func (*Schema) RenameColumn \u00b6 func ( s * Schema ) RenameColumn ( table string , name string , newName string , options ... ColumnOption ) RenameColumn by name. func (*Schema) RenameTable \u00b6 func ( s * Schema ) RenameTable ( name string , newName string , options ... TableOption ) RenameTable by name. func (Schema) String \u00b6 func ( s Schema ) String () string String returns schema operation. type SchemaOp \u00b6 type SchemaOp uint8 SchemaOp type. const ( // SchemaCreate operation. SchemaCreate SchemaOp = iota // SchemaAlter operation. SchemaAlter // SchemaRename operation. SchemaRename // SchemaDrop operation. SchemaDrop ) func (SchemaOp) String \u00b6 func ( s SchemaOp ) String () string type SelectQuery \u00b6 type SelectQuery struct { OnlyDistinct bool Fields [] string } SelectQuery defines select clause of the query. func NewSelect \u00b6 func NewSelect ( fields ... string ) SelectQuery NewSelect query. Deprecated: use Select instead func (SelectQuery) Distinct \u00b6 func ( sq SelectQuery ) Distinct () SelectQuery Distinct select query. type SortQuery \u00b6 type SortQuery struct { Field string Sort int } SortQuery defines sort information of query. func SortAsc \u00b6 func SortAsc ( field string ) SortQuery SortAsc sorts field with ascending sort. func SortDesc \u00b6 func SortDesc ( field string ) SortQuery NewSortDesc sorts field with descending sort. func (SortQuery) Asc \u00b6 func ( sq SortQuery ) Asc () bool Asc returns true if sort is ascending. func (SortQuery) Build \u00b6 func ( sq SortQuery ) Build ( query * Query ) Build sort query. func (SortQuery) Desc \u00b6 func ( sq SortQuery ) Desc () bool Desc returns true if s is descending. type Structset \u00b6 type Structset struct { // contains filtered or unexported fields } Structset can be used as mutation for repository insert or update operation. This will save every field in struct and it's association as long as it's loaded. This is the default mutator used by repository. func NewStructset \u00b6 func NewStructset ( record interface {}, skipZero bool ) Structset NewStructset from a struct. func (Structset) Apply \u00b6 func ( s Structset ) Apply ( doc * Document , mut * Mutation ) Apply mutation. type SubQuery \u00b6 type SubQuery struct { Prefix string Query Query } SubQuery warps a query into: Prefix (Query) func All \u00b6 func All ( sub Query ) SubQuery All warp a query into ALL(sub-query) Some database may not support this keyword, please consult to your database documentation. func Any \u00b6 func Any ( sub Query ) SubQuery Any warp a query into ANY(sub-query) Some database may not support this keyword, please consult to your database documentation. type Table \u00b6 type Table struct { Op SchemaOp Name string Rename string Definitions [] TableDefinition Optional bool Options string } Table definition. func (*Table) BigID \u00b6 func ( t * Table ) BigID ( name string , options ... ColumnOption ) BigID defines a column with name and Big ID type. the resulting database type will depends on database. func (*Table) BigInt \u00b6 func ( t * Table ) BigInt ( name string , options ... ColumnOption ) BigInt defines a column with name and BigInt type. func (*Table) Bool \u00b6 func ( t * Table ) Bool ( name string , options ... ColumnOption ) Bool defines a column with name and Bool type. func (*Table) Column \u00b6 func ( t * Table ) Column ( name string , typ ColumnType , options ... ColumnOption ) Column defines a column with name and type. func (*Table) Date \u00b6 func ( t * Table ) Date ( name string , options ... ColumnOption ) Date defines a column with name and Date type. func (*Table) DateTime \u00b6 func ( t * Table ) DateTime ( name string , options ... ColumnOption ) DateTime defines a column with name and DateTime type. func (*Table) Decimal \u00b6 func ( t * Table ) Decimal ( name string , options ... ColumnOption ) Decimal defines a column with name and Decimal type. func (*Table) Float \u00b6 func ( t * Table ) Float ( name string , options ... ColumnOption ) Float defines a column with name and Float type. func (*Table) ForeignKey \u00b6 func ( t * Table ) ForeignKey ( column string , refTable string , refColumn string , options ... KeyOption ) ForeignKey defines foreign key index. func (*Table) Fragment \u00b6 func ( t * Table ) Fragment ( fragment string ) Fragment defines anything using sql fragment. func (*Table) ID \u00b6 func ( t * Table ) ID ( name string , options ... ColumnOption ) ID defines a column with name and ID type. the resulting database type will depends on database. func (*Table) Int \u00b6 func ( t * Table ) Int ( name string , options ... ColumnOption ) Int defines a column with name and Int type. func (*Table) JSON \u00b6 func ( t * Table ) JSON ( name string , options ... ColumnOption ) JSON defines a column with name and JSON type. func (*Table) PrimaryKey \u00b6 func ( t * Table ) PrimaryKey ( column string , options ... KeyOption ) PrimaryKey defines a primary key for table. func (*Table) PrimaryKeys \u00b6 func ( t * Table ) PrimaryKeys ( columns [] string , options ... KeyOption ) PrimaryKeys defines composite primary keys for table. func (*Table) SmallInt \u00b6 func ( t * Table ) SmallInt ( name string , options ... ColumnOption ) SmallInt defines a column with name and Small type. func (*Table) String \u00b6 func ( t * Table ) String ( name string , options ... ColumnOption ) String defines a column with name and String type. func (*Table) Text \u00b6 func ( t * Table ) Text ( name string , options ... ColumnOption ) Text defines a column with name and Text type. func (*Table) Time \u00b6 func ( t * Table ) Time ( name string , options ... ColumnOption ) Time defines a column with name and Time type. func (*Table) Unique \u00b6 func ( t * Table ) Unique ( columns [] string , options ... KeyOption ) Unique defines an unique key for columns. type TableDefinition \u00b6 type TableDefinition interface { // contains filtered or unexported methods } TableDefinition interface. type TableOption \u00b6 type TableOption interface { // contains filtered or unexported methods } TableOption interface. Available options are: Comment, Options. type Unique \u00b6 type Unique bool Unique set column as unique. type Unscoped \u00b6 type Unscoped bool Unscoped query. func (Unscoped) Apply \u00b6 func ( u Unscoped ) Apply ( doc * Document , mutation * Mutation ) Apply mutation. func (Unscoped) Build \u00b6 func ( u Unscoped ) Build ( query * Query ) Build query. type Unsigned \u00b6 type Unsigned bool Unsigned sets integer column to be unsigned.","title":"github.com/go-rel/rel"},{"location":"reference/rel/#rel","text":"import \"github.com/go-rel/rel\"","title":"rel"},{"location":"reference/rel/#overview","text":"Package rel contains all rel primary APIs, such as Repository.","title":"Overview"},{"location":"reference/rel/#constants","text":"const ( // BelongsTo association. BelongsTo = iota // HasOne association. HasOne // HasMany association. HasMany )","title":"Constants"},{"location":"reference/rel/#variables","text":"var ( // ErrNotFound returned when records not found. ErrNotFound = NotFoundError {} // ErrCheckConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrCheckConstraint). ErrCheckConstraint = ConstraintError { Type : CheckConstraint } // ErrNotNullConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrNotNullConstraint). ErrNotNullConstraint = ConstraintError { Type : NotNullConstraint } // ErrUniqueConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrUniqueConstraint). ErrUniqueConstraint = ConstraintError { Type : UniqueConstraint } // ErrPrimaryKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrPrimaryKeyConstraint). ErrPrimaryKeyConstraint = ConstraintError { Type : PrimaryKeyConstraint } // ErrForeignKeyConstraint is an auxiliary variable for error handling. // This is only to be used when checking error with errors.Is(err, ErrForeignKeyConstraint). ErrForeignKeyConstraint = ConstraintError { Type : ForeignKeyConstraint } ) var ( // NewSortAsc sorts field with ascending sort. // // Deprecated: use SortAsc instead NewSortAsc = SortAsc // NewSortDesc sorts field with descending sort. // // Deprecated: use SortDesc instead NewSortDesc = SortDesc ) var Setf = SetFragment Setf is an alias for SetFragment","title":"Variables"},{"location":"reference/rel/#func-defaultlogger","text":"func DefaultLogger ( ctx context . Context , op string , message string ) func ( err error ) DefaultLogger instrumentation to log queries and rel operation.","title":"func DefaultLogger"},{"location":"reference/rel/#func-nullable","text":"func Nullable ( dest interface {}) interface {} Nullable wrap value as a nullable sql.Scanner. If value returned from database is nil, nullable scanner will set dest to zero value.","title":"func Nullable"},{"location":"reference/rel/#type-adapter","text":"type Adapter interface { Close () error Instrumentation ( instrumenter Instrumenter ) Ping ( ctx context . Context ) error Aggregate ( ctx context . Context , query Query , mode string , field string ) ( int , error ) Query ( ctx context . Context , query Query ) ( Cursor , error ) Insert ( ctx context . Context , query Query , primaryField string , mutates map [ string ] Mutate , onConflict OnConflict ) ( interface {}, error ) InsertAll ( ctx context . Context , query Query , primaryField string , fields [] string , bulkMutates [] map [ string ] Mutate , onConflict OnConflict ) ([] interface {}, error ) Update ( ctx context . Context , query Query , primaryField string , mutates map [ string ] Mutate ) ( int , error ) Delete ( ctx context . Context , query Query ) ( int , error ) Exec ( ctx context . Context , stmt string , args [] interface {}) ( int64 , int64 , error ) Begin ( ctx context . Context ) ( Adapter , error ) Commit ( ctx context . Context ) error Rollback ( ctx context . Context ) error Apply ( ctx context . Context , migration Migration ) error } Adapter interface","title":"type Adapter"},{"location":"reference/rel/#type-altertable","text":"type AlterTable struct { Table } AlterTable Migrator.","title":"type AlterTable"},{"location":"reference/rel/#func-altertable-dropcolumn","text":"func ( at * AlterTable ) DropColumn ( name string , options ... ColumnOption ) DropColumn from this table.","title":"func (*AlterTable) DropColumn"},{"location":"reference/rel/#func-altertable-renamecolumn","text":"func ( at * AlterTable ) RenameColumn ( name string , newName string , options ... ColumnOption ) RenameColumn to a new name.","title":"func (*AlterTable) RenameColumn"},{"location":"reference/rel/#type-assocmutation","text":"type AssocMutation struct { Mutations [] Mutation DeletedIDs [] interface {} // This is array of single id, and doesn't support composite primary key. } AssocMutation represents mutation for association.","title":"type AssocMutation"},{"location":"reference/rel/#type-association","text":"type Association struct { // contains filtered or unexported fields } Association provides abstraction to work with association of document or collection.","title":"type Association"},{"location":"reference/rel/#func-association-autoload","text":"func ( a Association ) Autoload () bool Autoload assoc setting when parent is loaded.","title":"func (Association) Autoload"},{"location":"reference/rel/#func-association-autosave","text":"func ( a Association ) Autosave () bool Autosave setting when parent is created/updated/deleted.","title":"func (Association) Autosave"},{"location":"reference/rel/#func-association-collection","text":"func ( a Association ) Collection () ( * Collection , bool ) Collection returns association target as collection. If association is zero, second return value will be false.","title":"func (Association) Collection"},{"location":"reference/rel/#func-association-document","text":"func ( a Association ) Document () ( * Document , bool ) Document returns association target as document. If association is zero, second return value will be false.","title":"func (Association) Document"},{"location":"reference/rel/#func-association-foreignfield","text":"func ( a Association ) ForeignField () string ForeignField of the association.","title":"func (Association) ForeignField"},{"location":"reference/rel/#func-association-foreignvalue","text":"func ( a Association ) ForeignValue () interface {} ForeignValue of the association. It'll panic if association type is has many.","title":"func (Association) ForeignValue"},{"location":"reference/rel/#func-association-iszero","text":"func ( a Association ) IsZero () bool IsZero returns true if association is not loaded.","title":"func (Association) IsZero"},{"location":"reference/rel/#func-association-lazydocument","text":"func ( a Association ) LazyDocument () ( * Document , bool ) LazyDocument is a lazy version of Document. If rv is a null pointer, it returns a document that delays setting the value of rv until Document#Add() is called.","title":"func (Association) LazyDocument"},{"location":"reference/rel/#func-association-referencefield","text":"func ( a Association ) ReferenceField () string ReferenceField of the association.","title":"func (Association) ReferenceField"},{"location":"reference/rel/#func-association-referencevalue","text":"func ( a Association ) ReferenceValue () interface {} ReferenceValue of the association.","title":"func (Association) ReferenceValue"},{"location":"reference/rel/#func-association-through","text":"func ( a Association ) Through () string Through return intermediary association.","title":"func (Association) Through"},{"location":"reference/rel/#func-association-type","text":"func ( a Association ) Type () AssociationType Type of association.","title":"func (Association) Type"},{"location":"reference/rel/#type-associationtype","text":"type AssociationType uint8 AssociationType defines the type of association in database.","title":"type AssociationType"},{"location":"reference/rel/#type-cascade","text":"type Cascade bool Cascade enable or disable updating associations. Default to true.","title":"type Cascade"},{"location":"reference/rel/#func-cascade-apply","text":"func ( c Cascade ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Cascade) Apply"},{"location":"reference/rel/#func-cascade-build","text":"func ( c Cascade ) Build ( query * Query ) Build query.","title":"func (Cascade) Build"},{"location":"reference/rel/#func-cascade-string","text":"func ( c Cascade ) String () string","title":"func (Cascade) String"},{"location":"reference/rel/#type-changeop","text":"type ChangeOp int ChangeOp represents type of mutate operation. const ( // ChangeInvalidOp operation. ChangeInvalidOp ChangeOp = iota // ChangeSetOp operation. ChangeSetOp // ChangeIncOp operation. ChangeIncOp // ChangeFragmentOp operation. ChangeFragmentOp )","title":"type ChangeOp"},{"location":"reference/rel/#type-changeset","text":"type Changeset struct { // contains filtered or unexported fields } Changeset mutator for structs. This allows REL to efficiently to perform update operation only on updated fields and association. The catch is, enabling changeset will duplicates the original struct values which consumes more memory.","title":"type Changeset"},{"location":"reference/rel/#func-newchangeset","text":"func NewChangeset ( record interface {}) Changeset NewChangeset returns new changeset mutator for given record.","title":"func NewChangeset"},{"location":"reference/rel/#func-changeset-apply","text":"func ( c Changeset ) Apply ( doc * Document , mut * Mutation ) Apply mutation.","title":"func (Changeset) Apply"},{"location":"reference/rel/#func-changeset-changes","text":"func ( c Changeset ) Changes () map [ string ] interface {} Changes returns map of changes.","title":"func (Changeset) Changes"},{"location":"reference/rel/#func-changeset-fieldchanged","text":"func ( c Changeset ) FieldChanged ( field string ) bool FieldChanged returns true if field exists and it's already changed. returns false otherwise.","title":"func (Changeset) FieldChanged"},{"location":"reference/rel/#type-collection","text":"type Collection struct { // contains filtered or unexported fields } Collection provides an abstraction over reflect to easily works with slice for database purpose.","title":"type Collection"},{"location":"reference/rel/#func-newcollection","text":"func NewCollection ( records interface {}, readonly ... bool ) * Collection NewCollection used to create abstraction to work with slice. COllection can be created using interface or reflect.Value.","title":"func NewCollection"},{"location":"reference/rel/#func-collection-add","text":"func ( c Collection ) Add () * Document Add new document into collection.","title":"func (Collection) Add"},{"location":"reference/rel/#func-collection-get","text":"func ( c Collection ) Get ( index int ) * Document Get an element from the underlying slice as a document.","title":"func (Collection) Get"},{"location":"reference/rel/#func-collection-len","text":"func ( c Collection ) Len () int Len of the underlying slice.","title":"func (Collection) Len"},{"location":"reference/rel/#func-collection-primaryfield","text":"func ( c Collection ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key.","title":"func (Collection) PrimaryField"},{"location":"reference/rel/#func-collection-primaryfields","text":"func ( c Collection ) PrimaryFields () [] string PrimaryFields column name of this collection.","title":"func (Collection) PrimaryFields"},{"location":"reference/rel/#func-collection-primaryvalue","text":"func ( c Collection ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key.","title":"func (Collection) PrimaryValue"},{"location":"reference/rel/#func-collection-primaryvalues","text":"func ( c Collection ) PrimaryValues () [] interface {} PrimaryValues of collection. Returned value will be interface of slice interface.","title":"func (Collection) PrimaryValues"},{"location":"reference/rel/#func-collection-reflectvalue","text":"func ( c Collection ) ReflectValue () reflect . Value ReflectValue of referenced document.","title":"func (Collection) ReflectValue"},{"location":"reference/rel/#func-collection-reset","text":"func ( c Collection ) Reset () Reset underlying slice to be zero length.","title":"func (Collection) Reset"},{"location":"reference/rel/#func-collection-slice","text":"func ( c Collection ) Slice ( i , j int ) * Collection Slice returns a new collection that is a slice of the original collection.s","title":"func (Collection) Slice"},{"location":"reference/rel/#func-collection-swap","text":"func ( c Collection ) Swap ( i , j int ) Swap element in the collection.","title":"func (Collection) Swap"},{"location":"reference/rel/#func-collection-table","text":"func ( c * Collection ) Table () string Table returns name of the table.","title":"func (*Collection) Table"},{"location":"reference/rel/#func-collection-truncate","text":"func ( c Collection ) Truncate ( i , j int ) Truncate collection.","title":"func (Collection) Truncate"},{"location":"reference/rel/#type-column","text":"type Column struct { Op SchemaOp Name string Type ColumnType Rename string Primary bool Unique bool Required bool Unsigned bool Limit int Precision int Scale int Default interface {} Options string } Column definition.","title":"type Column"},{"location":"reference/rel/#type-columnoption","text":"type ColumnOption interface { // contains filtered or unexported methods } ColumnOption interface. Available options are: Nil, Unsigned, Limit, Precision, Scale, Default, Comment, Options.","title":"type ColumnOption"},{"location":"reference/rel/#func-default","text":"func Default ( def interface {}) ColumnOption Default allows to set a default value on the column.).","title":"func Default"},{"location":"reference/rel/#type-columntype","text":"type ColumnType string ColumnType definition. const ( // ID ColumnType. ID ColumnType = \"ID\" // BigID ColumnType. BigID ColumnType = \"BigID\" // Bool ColumnType. Bool ColumnType = \"BOOL\" // SmallInt ColumnType. SmallInt ColumnType = \"SMALLINT\" // Int ColumnType. Int ColumnType = \"INT\" // BigInt ColumnType. BigInt ColumnType = \"BIGINT\" // Float ColumnType. Float ColumnType = \"FLOAT\" // Decimal ColumnType. Decimal ColumnType = \"DECIMAL\" // String ColumnType. String ColumnType = \"STRING\" // Text ColumnType. Text ColumnType = \"TEXT\" // JSON ColumnType that will fallback to Text ColumnType if adapter does not support it. JSON ColumnType = \"JSON\" // Date ColumnType. Date ColumnType = \"DATE\" // DateTime ColumnType. DateTime ColumnType = \"DATETIME\" // Time ColumnType. Time ColumnType = \"TIME\" )","title":"type ColumnType"},{"location":"reference/rel/#type-constrainterror","text":"type ConstraintError struct { Key string Type ConstraintType Err error } ConstraintError returned whenever constraint error encountered.","title":"type ConstraintError"},{"location":"reference/rel/#func-constrainterror-error","text":"func ( ce ConstraintError ) Error () string Error message.","title":"func (ConstraintError) Error"},{"location":"reference/rel/#func-constrainterror-is","text":"func ( ce ConstraintError ) Is ( target error ) bool Is returns true when target error have the same type and key if defined.","title":"func (ConstraintError) Is"},{"location":"reference/rel/#func-constrainterror-unwrap","text":"func ( ce ConstraintError ) Unwrap () error Unwrap internal error returned by database driver.","title":"func (ConstraintError) Unwrap"},{"location":"reference/rel/#type-constrainttype","text":"type ConstraintType int8 ConstraintType defines the type of constraint error. const ( // CheckConstraint error type. CheckConstraint ConstraintType = iota // NotNullConstraint error type.1 NotNullConstraint // UniqueConstraint error type.1 UniqueConstraint // PrimaryKeyConstraint error type.1 PrimaryKeyConstraint // ForeignKeyConstraint error type.1 ForeignKeyConstraint )","title":"type ConstraintType"},{"location":"reference/rel/#func-constrainttype-string","text":"func ( ct ConstraintType ) String () string String representation of the constraint type.","title":"func (ConstraintType) String"},{"location":"reference/rel/#type-cursor","text":"type Cursor interface { Close () error Fields () ([] string , error ) Next () bool Scan ( ... interface {}) error NopScanner () interface {} // TODO: conflict with manual scanners interface } Cursor is interface to work with database result (used by adapter).","title":"type Cursor"},{"location":"reference/rel/#type-do","text":"type Do func ( Repository ) error Do used internally for schema migration.","title":"type Do"},{"location":"reference/rel/#type-document","text":"type Document struct { // contains filtered or unexported fields } Document provides an abstraction over reflect to easily works with struct for database purpose.","title":"type Document"},{"location":"reference/rel/#func-newdocument","text":"func NewDocument ( record interface {}, readonly ... bool ) * Document NewDocument used to create abstraction to work with struct. Document can be created using interface or reflect.Value.","title":"func NewDocument"},{"location":"reference/rel/#func-document-add","text":"func ( d * Document ) Add () * Document Add returns this document.","title":"func (*Document) Add"},{"location":"reference/rel/#func-document-association","text":"func ( d Document ) Association ( name string ) Association Association of this document with given name.","title":"func (Document) Association"},{"location":"reference/rel/#func-document-belongsto","text":"func ( d Document ) BelongsTo () [] string BelongsTo fields of this document.","title":"func (Document) BelongsTo"},{"location":"reference/rel/#func-document-fields","text":"func ( d Document ) Fields () [] string Fields returns list of fields available on this document.","title":"func (Document) Fields"},{"location":"reference/rel/#func-document-flag","text":"func ( d Document ) Flag ( flag DocumentFlag ) bool Flag returns true if struct contains specified flag.","title":"func (Document) Flag"},{"location":"reference/rel/#func-document-get","text":"func ( d * Document ) Get ( index int ) * Document Get always returns this document, this is a noop for compatibility with collection.","title":"func (*Document) Get"},{"location":"reference/rel/#func-document-hasmany","text":"func ( d Document ) HasMany () [] string HasMany fields of this document.","title":"func (Document) HasMany"},{"location":"reference/rel/#func-document-hasone","text":"func ( d Document ) HasOne () [] string HasOne fields of this document.","title":"func (Document) HasOne"},{"location":"reference/rel/#func-document-index","text":"func ( d Document ) Index () map [ string ][] int Index returns map of column name and it's struct index.","title":"func (Document) Index"},{"location":"reference/rel/#func-document-len","text":"func ( d * Document ) Len () int Len always returns 1 for document, this is a noop for compatibility with collection.","title":"func (*Document) Len"},{"location":"reference/rel/#func-document-persisted","text":"func ( d Document ) Persisted () bool Persisted returns true if document primary key is not zero.","title":"func (Document) Persisted"},{"location":"reference/rel/#func-document-preload","text":"func ( d Document ) Preload () [] string Preload fields of this document.","title":"func (Document) Preload"},{"location":"reference/rel/#func-document-primaryfield","text":"func ( d Document ) PrimaryField () string PrimaryField column name of this document. panic if document uses composite key.","title":"func (Document) PrimaryField"},{"location":"reference/rel/#func-document-primaryfields","text":"func ( d Document ) PrimaryFields () [] string PrimaryFields column name of this document.","title":"func (Document) PrimaryFields"},{"location":"reference/rel/#func-document-primaryvalue","text":"func ( d Document ) PrimaryValue () interface {} PrimaryValue of this document. panic if document uses composite key.","title":"func (Document) PrimaryValue"},{"location":"reference/rel/#func-document-primaryvalues","text":"func ( d Document ) PrimaryValues () [] interface {} PrimaryValues of this document.","title":"func (Document) PrimaryValues"},{"location":"reference/rel/#func-document-reflectvalue","text":"func ( d Document ) ReflectValue () reflect . Value ReflectValue of referenced document.","title":"func (Document) ReflectValue"},{"location":"reference/rel/#func-document-reset","text":"func ( d Document ) Reset () Reset this document, this is a noop for compatibility with collection.","title":"func (Document) Reset"},{"location":"reference/rel/#func-document-scanners","text":"func ( d Document ) Scanners ( fields [] string ) [] interface {} Scanners returns slice of sql.Scanner for given fields.","title":"func (Document) Scanners"},{"location":"reference/rel/#func-document-setvalue","text":"func ( d Document ) SetValue ( field string , value interface {}) bool SetValue of the field, it returns false if field does not exist, or it's not assignable.","title":"func (Document) SetValue"},{"location":"reference/rel/#func-document-table","text":"func ( d Document ) Table () string Table returns name of the table.","title":"func (Document) Table"},{"location":"reference/rel/#func-document-type","text":"func ( d Document ) Type ( field string ) ( reflect . Type , bool ) Type returns reflect.Type of given field. if field does not exist, second returns value will be false.","title":"func (Document) Type"},{"location":"reference/rel/#func-document-value","text":"func ( d Document ) Value ( field string ) ( interface {}, bool ) Value returns value of given field. if field does not exist, second returns value will be false.","title":"func (Document) Value"},{"location":"reference/rel/#type-documentflag","text":"type DocumentFlag int8 DocumentFlag stores information about document as a flag. const ( // Invalid flag. Invalid DocumentFlag = 1 << iota // HasCreatedAt flag. HasCreatedAt // HasUpdatedAt flag. HasUpdatedAt // HasDeletedAt flag. HasDeletedAt // HasDeleted flag. HasDeleted // Versioning HasVersioning )","title":"type DocumentFlag"},{"location":"reference/rel/#func-documentflag-is","text":"func ( df DocumentFlag ) Is ( flag DocumentFlag ) bool Is returns true if it's defined.","title":"func (DocumentFlag) Is"},{"location":"reference/rel/#type-errorfunc","text":"type ErrorFunc func ( error ) error ErrorFunc allows conversion REL's error to Application custom errors.","title":"type ErrorFunc"},{"location":"reference/rel/#func-errorfunc-apply","text":"func ( ef ErrorFunc ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (ErrorFunc) Apply"},{"location":"reference/rel/#type-filterop","text":"type FilterOp int FilterOp defines enumeration of all supported filter types. const ( // FilterAndOp is filter type for and operator. FilterAndOp FilterOp = iota // FilterOrOp is filter type for or operator. FilterOrOp // FilterNotOp is filter type for not operator. FilterNotOp // FilterEqOp is filter type for equal comparison. FilterEqOp // FilterNeOp is filter type for not equal comparison. FilterNeOp // FilterLtOp is filter type for less than comparison. FilterLtOp // FilterLteOp is filter type for less than or equal comparison. FilterLteOp // FilterGtOp is filter type for greater than comparison. FilterGtOp // FilterGteOp is filter type for greter than or equal comparison. FilterGteOp // FilterNilOp is filter type for nil check. FilterNilOp // FilterNotNilOp is filter type for not nil check. FilterNotNilOp // FilterInOp is filter type for inclusion comparison. FilterInOp // FilterNinOp is filter type for not inclusion comparison. FilterNinOp // FilterLikeOp is filter type for like comparison. FilterLikeOp // FilterNotLikeOp is filter type for not like comparison. FilterNotLikeOp // FilterFragmentOp is filter type for custom filter. FilterFragmentOp )","title":"type FilterOp"},{"location":"reference/rel/#func-filterop-string","text":"func ( fo FilterOp ) String () string","title":"func (FilterOp) String"},{"location":"reference/rel/#type-filterquery","text":"type FilterQuery struct { Type FilterOp Field string Value interface {} Inner [] FilterQuery } FilterQuery defines details of a condition type.","title":"type FilterQuery"},{"location":"reference/rel/#func-and","text":"func And ( inner ... FilterQuery ) FilterQuery And compares other filters using and.","title":"func And"},{"location":"reference/rel/#func-eq","text":"func Eq ( field string , value interface {}) FilterQuery Eq expression field equal to value.","title":"func Eq"},{"location":"reference/rel/#func-filterfragment","text":"func FilterFragment ( expr string , values ... interface {}) FilterQuery FilterFragment add custom filter.","title":"func FilterFragment"},{"location":"reference/rel/#func-gt","text":"func Gt ( field string , value interface {}) FilterQuery Gt compares that left value is greater than to right value.","title":"func Gt"},{"location":"reference/rel/#func-gte","text":"func Gte ( field string , value interface {}) FilterQuery Gte compares that left value is greater than or equal to right value.","title":"func Gte"},{"location":"reference/rel/#func-in","text":"func In ( field string , values ... interface {}) FilterQuery In check whethers value of the field is included in values.","title":"func In"},{"location":"reference/rel/#func-inint","text":"func InInt ( field string , values [] int ) FilterQuery InInt check whethers integer values of the field is included.","title":"func InInt"},{"location":"reference/rel/#func-instring","text":"func InString ( field string , values [] string ) FilterQuery InString check whethers string values of the field is included.","title":"func InString"},{"location":"reference/rel/#func-inuint","text":"func InUint ( field string , values [] uint ) FilterQuery InUint check whethers unsigned integer values of the field is included.","title":"func InUint"},{"location":"reference/rel/#func-like","text":"func Like ( field string , pattern string ) FilterQuery Like compares value of field to match string pattern.","title":"func Like"},{"location":"reference/rel/#func-lt","text":"func Lt ( field string , value interface {}) FilterQuery Lt compares that left value is less than to right value.","title":"func Lt"},{"location":"reference/rel/#func-lte","text":"func Lte ( field string , value interface {}) FilterQuery Lte compares that left value is less than or equal to right value.","title":"func Lte"},{"location":"reference/rel/#func-ne","text":"func Ne ( field string , value interface {}) FilterQuery Ne compares that left value is not equal to right value.","title":"func Ne"},{"location":"reference/rel/#func-nil","text":"func Nil ( field string ) FilterQuery Nil check whether field is nil.","title":"func Nil"},{"location":"reference/rel/#func-nin","text":"func Nin ( field string , values ... interface {}) FilterQuery Nin check whethers value of the field is not included in values.","title":"func Nin"},{"location":"reference/rel/#func-ninint","text":"func NinInt ( field string , values [] int ) FilterQuery NinInt check whethers integer values of the is not included.","title":"func NinInt"},{"location":"reference/rel/#func-ninstring","text":"func NinString ( field string , values [] string ) FilterQuery NinString check whethers string values of the is not included.","title":"func NinString"},{"location":"reference/rel/#func-ninuint","text":"func NinUint ( field string , values [] uint ) FilterQuery NinUint check whethers unsigned integer values of the is not included.","title":"func NinUint"},{"location":"reference/rel/#func-not","text":"func Not ( inner ... FilterQuery ) FilterQuery Not wraps filters using not. It'll negate the filter type if possible.","title":"func Not"},{"location":"reference/rel/#func-notlike","text":"func NotLike ( field string , pattern string ) FilterQuery NotLike compares value of field to not match string pattern.","title":"func NotLike"},{"location":"reference/rel/#func-notnil","text":"func NotNil ( field string ) FilterQuery NotNil check whether field is not nil.","title":"func NotNil"},{"location":"reference/rel/#func-or","text":"func Or ( inner ... FilterQuery ) FilterQuery Or compares other filters using or.","title":"func Or"},{"location":"reference/rel/#func-filterquery-and","text":"func ( fq FilterQuery ) And ( filters ... FilterQuery ) FilterQuery And wraps filters using and.","title":"func (FilterQuery) And"},{"location":"reference/rel/#func-filterquery-andeq","text":"func ( fq FilterQuery ) AndEq ( field string , value interface {}) FilterQuery AndEq append equal expression using and.","title":"func (FilterQuery) AndEq"},{"location":"reference/rel/#func-filterquery-andfragment","text":"func ( fq FilterQuery ) AndFragment ( expr string , values ... interface {}) FilterQuery AndFragment append fragment using and.","title":"func (FilterQuery) AndFragment"},{"location":"reference/rel/#func-filterquery-andgt","text":"func ( fq FilterQuery ) AndGt ( field string , value interface {}) FilterQuery AndGt append greater than expression using and.","title":"func (FilterQuery) AndGt"},{"location":"reference/rel/#func-filterquery-andgte","text":"func ( fq FilterQuery ) AndGte ( field string , value interface {}) FilterQuery AndGte append greater than or equal expression using and.","title":"func (FilterQuery) AndGte"},{"location":"reference/rel/#func-filterquery-andin","text":"func ( fq FilterQuery ) AndIn ( field string , values ... interface {}) FilterQuery AndIn append is in expression using and.","title":"func (FilterQuery) AndIn"},{"location":"reference/rel/#func-filterquery-andlike","text":"func ( fq FilterQuery ) AndLike ( field string , pattern string ) FilterQuery AndLike append like expression using and.","title":"func (FilterQuery) AndLike"},{"location":"reference/rel/#func-filterquery-andlt","text":"func ( fq FilterQuery ) AndLt ( field string , value interface {}) FilterQuery AndLt append lesser than expression using and.","title":"func (FilterQuery) AndLt"},{"location":"reference/rel/#func-filterquery-andlte","text":"func ( fq FilterQuery ) AndLte ( field string , value interface {}) FilterQuery AndLte append lesser than or equal expression using and.","title":"func (FilterQuery) AndLte"},{"location":"reference/rel/#func-filterquery-andne","text":"func ( fq FilterQuery ) AndNe ( field string , value interface {}) FilterQuery AndNe append not equal expression using and.","title":"func (FilterQuery) AndNe"},{"location":"reference/rel/#func-filterquery-andnil","text":"func ( fq FilterQuery ) AndNil ( field string ) FilterQuery AndNil append is nil expression using and.","title":"func (FilterQuery) AndNil"},{"location":"reference/rel/#func-filterquery-andnin","text":"func ( fq FilterQuery ) AndNin ( field string , values ... interface {}) FilterQuery AndNin append is not in expression using and.","title":"func (FilterQuery) AndNin"},{"location":"reference/rel/#func-filterquery-andnotlike","text":"func ( fq FilterQuery ) AndNotLike ( field string , pattern string ) FilterQuery AndNotLike append not like expression using and.","title":"func (FilterQuery) AndNotLike"},{"location":"reference/rel/#func-filterquery-andnotnil","text":"func ( fq FilterQuery ) AndNotNil ( field string ) FilterQuery AndNotNil append is not nil expression using and.","title":"func (FilterQuery) AndNotNil"},{"location":"reference/rel/#func-filterquery-build","text":"func ( fq FilterQuery ) Build ( query * Query ) Build Filter query.","title":"func (FilterQuery) Build"},{"location":"reference/rel/#func-filterquery-none","text":"func ( fq FilterQuery ) None () bool None returns true if no filter is specified.","title":"func (FilterQuery) None"},{"location":"reference/rel/#func-filterquery-or","text":"func ( fq FilterQuery ) Or ( filter ... FilterQuery ) FilterQuery Or wraps filters using or.","title":"func (FilterQuery) Or"},{"location":"reference/rel/#func-filterquery-oreq","text":"func ( fq FilterQuery ) OrEq ( field string , value interface {}) FilterQuery OrEq append equal expression using or.","title":"func (FilterQuery) OrEq"},{"location":"reference/rel/#func-filterquery-orfragment","text":"func ( fq FilterQuery ) OrFragment ( expr string , values ... interface {}) FilterQuery OrFragment append fragment using or.","title":"func (FilterQuery) OrFragment"},{"location":"reference/rel/#func-filterquery-orgt","text":"func ( fq FilterQuery ) OrGt ( field string , value interface {}) FilterQuery OrGt append greater than expression using or.","title":"func (FilterQuery) OrGt"},{"location":"reference/rel/#func-filterquery-orgte","text":"func ( fq FilterQuery ) OrGte ( field string , value interface {}) FilterQuery OrGte append greater than or equal expression using or.","title":"func (FilterQuery) OrGte"},{"location":"reference/rel/#func-filterquery-orin","text":"func ( fq FilterQuery ) OrIn ( field string , values ... interface {}) FilterQuery OrIn append is in expression using or.","title":"func (FilterQuery) OrIn"},{"location":"reference/rel/#func-filterquery-orlike","text":"func ( fq FilterQuery ) OrLike ( field string , pattern string ) FilterQuery OrLike append like expression using or.","title":"func (FilterQuery) OrLike"},{"location":"reference/rel/#func-filterquery-orlt","text":"func ( fq FilterQuery ) OrLt ( field string , value interface {}) FilterQuery OrLt append lesser than expression using or.","title":"func (FilterQuery) OrLt"},{"location":"reference/rel/#func-filterquery-orlte","text":"func ( fq FilterQuery ) OrLte ( field string , value interface {}) FilterQuery OrLte append lesser than or equal expression using or.","title":"func (FilterQuery) OrLte"},{"location":"reference/rel/#func-filterquery-orne","text":"func ( fq FilterQuery ) OrNe ( field string , value interface {}) FilterQuery OrNe append not equal expression using or.","title":"func (FilterQuery) OrNe"},{"location":"reference/rel/#func-filterquery-ornil","text":"func ( fq FilterQuery ) OrNil ( field string ) FilterQuery OrNil append is nil expression using or.","title":"func (FilterQuery) OrNil"},{"location":"reference/rel/#func-filterquery-ornin","text":"func ( fq FilterQuery ) OrNin ( field string , values ... interface {}) FilterQuery OrNin append is not in expression using or.","title":"func (FilterQuery) OrNin"},{"location":"reference/rel/#func-filterquery-ornotlike","text":"func ( fq FilterQuery ) OrNotLike ( field string , pattern string ) FilterQuery OrNotLike append not like expression using or.","title":"func (FilterQuery) OrNotLike"},{"location":"reference/rel/#func-filterquery-ornotnil","text":"func ( fq FilterQuery ) OrNotNil ( field string ) FilterQuery OrNotNil append is not nil expression using or.","title":"func (FilterQuery) OrNotNil"},{"location":"reference/rel/#func-filterquery-string","text":"func ( fq FilterQuery ) String () string","title":"func (FilterQuery) String"},{"location":"reference/rel/#type-foreignkeyreference","text":"type ForeignKeyReference struct { Table string Columns [] string OnDelete string OnUpdate string } ForeignKeyReference definition.","title":"type ForeignKeyReference"},{"location":"reference/rel/#type-groupquery","text":"type GroupQuery struct { Fields [] string Filter FilterQuery } GroupQuery defines group clause of the query.","title":"type GroupQuery"},{"location":"reference/rel/#func-newgroup","text":"func NewGroup ( fields ... string ) GroupQuery NewGroup query.","title":"func NewGroup"},{"location":"reference/rel/#func-groupquery-build","text":"func ( gq GroupQuery ) Build ( query * Query ) Build query.","title":"func (GroupQuery) Build"},{"location":"reference/rel/#func-groupquery-having","text":"func ( gq GroupQuery ) Having ( filters ... FilterQuery ) GroupQuery Having appends filter for group query with and operand.","title":"func (GroupQuery) Having"},{"location":"reference/rel/#func-groupquery-orhaving","text":"func ( gq GroupQuery ) OrHaving ( filters ... FilterQuery ) GroupQuery OrHaving appends filter for group query with or operand.","title":"func (GroupQuery) OrHaving"},{"location":"reference/rel/#func-groupquery-orwhere","text":"func ( gq GroupQuery ) OrWhere ( filters ... FilterQuery ) GroupQuery OrWhere is alias for OrHaving.","title":"func (GroupQuery) OrWhere"},{"location":"reference/rel/#func-groupquery-where","text":"func ( gq GroupQuery ) Where ( filters ... FilterQuery ) GroupQuery Where is alias for having.","title":"func (GroupQuery) Where"},{"location":"reference/rel/#type-index","text":"type Index struct { Op SchemaOp Table string Name string Unique bool Columns [] string Optional bool Filter FilterQuery Options string } Index definition.","title":"type Index"},{"location":"reference/rel/#type-indexoption","text":"type IndexOption interface { // contains filtered or unexported methods } IndexOption interface. Available options are: Comment, Options.","title":"type IndexOption"},{"location":"reference/rel/#type-instrumenter","text":"type Instrumenter func ( ctx context . Context , op string , message string ) func ( err error ) Instrumenter defines function type that can be used for instrumetation. This function should return a function with no argument as a callback for finished execution.","title":"type Instrumenter"},{"location":"reference/rel/#func-instrumenter-observe","text":"func ( i Instrumenter ) Observe ( ctx context . Context , op string , message string ) func ( err error ) Observe operation.","title":"func (Instrumenter) Observe"},{"location":"reference/rel/#type-iterator","text":"type Iterator interface { io . Closer Next ( record interface {}) error } Iterator allows iterating through all record in database in batch.","title":"type Iterator"},{"location":"reference/rel/#type-iteratoroption","text":"type IteratorOption interface { // contains filtered or unexported methods } IteratorOption is used to configure iteration behaviour, such as batch size, start id and finish id.","title":"type IteratorOption"},{"location":"reference/rel/#func-batchsize","text":"func BatchSize ( size int ) IteratorOption BatchSize specifies the size of iterator batch. Defaults to 1000.","title":"func BatchSize"},{"location":"reference/rel/#func-finish","text":"func Finish ( id ... interface {}) IteratorOption Finish specifies the primary value to finish at (inclusive).","title":"func Finish"},{"location":"reference/rel/#func-start","text":"func Start ( id ... interface {}) IteratorOption Start specifies the primary value to start from (inclusive).","title":"func Start"},{"location":"reference/rel/#type-joinquery","text":"type JoinQuery struct { Mode string Table string From string To string Filter FilterQuery Arguments [] interface {} } JoinQuery defines join clause in query.","title":"type JoinQuery"},{"location":"reference/rel/#func-newfulljoin","text":"func NewFullJoin ( table string , filter ... FilterQuery ) JoinQuery NewFullJoin with given table and optional filter.","title":"func NewFullJoin"},{"location":"reference/rel/#func-newfulljoinon","text":"func NewFullJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewFullJoinOn table with given field and optional additional filter.","title":"func NewFullJoinOn"},{"location":"reference/rel/#func-newinnerjoin","text":"func NewInnerJoin ( table string , filter ... FilterQuery ) JoinQuery NewInnerJoin with given table and optional filter.","title":"func NewInnerJoin"},{"location":"reference/rel/#func-newinnerjoinon","text":"func NewInnerJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewInnerJoinOn table with given field and optional additional filter.","title":"func NewInnerJoinOn"},{"location":"reference/rel/#func-newjoin","text":"func NewJoin ( table string , filter ... FilterQuery ) JoinQuery NewJoin with given table.","title":"func NewJoin"},{"location":"reference/rel/#func-newjoinfragment","text":"func NewJoinFragment ( expr string , args ... interface {}) JoinQuery NewJoinFragment defines a join clause using raw query.","title":"func NewJoinFragment"},{"location":"reference/rel/#func-newjoinon","text":"func NewJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewJoinOn table with given field and optional additional filter.","title":"func NewJoinOn"},{"location":"reference/rel/#func-newjoinwith","text":"func NewJoinWith ( mode string , table string , from string , to string , filter ... FilterQuery ) JoinQuery NewJoinWith query with custom join mode, table, field and additional filters with AND condition.","title":"func NewJoinWith"},{"location":"reference/rel/#func-newleftjoin","text":"func NewLeftJoin ( table string , filter ... FilterQuery ) JoinQuery NewLeftJoin with given table and optional filter.","title":"func NewLeftJoin"},{"location":"reference/rel/#func-newleftjoinon","text":"func NewLeftJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewLeftJoinOn table with given field and optional additional filter.","title":"func NewLeftJoinOn"},{"location":"reference/rel/#func-newrightjoin","text":"func NewRightJoin ( table string , filter ... FilterQuery ) JoinQuery NewRightJoin with given table and optional filter.","title":"func NewRightJoin"},{"location":"reference/rel/#func-newrightjoinon","text":"func NewRightJoinOn ( table string , from string , to string , filter ... FilterQuery ) JoinQuery NewRightJoinOn table with given field and optional additional filter.","title":"func NewRightJoinOn"},{"location":"reference/rel/#func-joinquery-build","text":"func ( jq JoinQuery ) Build ( query * Query ) Build query.","title":"func (JoinQuery) Build"},{"location":"reference/rel/#type-key","text":"type Key struct { Op SchemaOp Name string Type KeyType Columns [] string Rename string Reference ForeignKeyReference Options string } Key definition.","title":"type Key"},{"location":"reference/rel/#type-keyoption","text":"type KeyOption interface { // contains filtered or unexported methods } KeyOption interface. Available options are: Comment, Options.","title":"type KeyOption"},{"location":"reference/rel/#type-keytype","text":"type KeyType string KeyType definition. const ( // PrimaryKey KeyType. PrimaryKey KeyType = \"PRIMARY KEY\" // ForeignKey KeyType. ForeignKey KeyType = \"FOREIGN KEY\" // UniqueKey KeyType. UniqueKey = \"UNIQUE\" )","title":"type KeyType"},{"location":"reference/rel/#type-limit","text":"type Limit int Limit options. When passed as query, it limits returned result from database. When passed as column option, it sets the maximum size of the string/text/binary/integer columns.","title":"type Limit"},{"location":"reference/rel/#func-limit-build","text":"func ( l Limit ) Build ( query * Query ) Build query.","title":"func (Limit) Build"},{"location":"reference/rel/#type-lock","text":"type Lock string Lock query. This query will be ignored if used outside of transaction.","title":"type Lock"},{"location":"reference/rel/#func-forupdate","text":"func ForUpdate () Lock ForUpdate lock query.","title":"func ForUpdate"},{"location":"reference/rel/#func-lock-build","text":"func ( l Lock ) Build ( query * Query ) Build query.","title":"func (Lock) Build"},{"location":"reference/rel/#type-map","text":"type Map map [ string ] interface {} Map can be used as mutation for repository insert or update operation. This allows inserting or updating only on specified field. Insert/Update of has one or belongs to can be done using other Map as a value. Insert/Update of has many can be done using slice of Map as a value. Map is intended to be used internally within application, and not to be exposed directly as an APIs.","title":"type Map"},{"location":"reference/rel/#func-map-apply","text":"func ( m Map ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Map) Apply"},{"location":"reference/rel/#func-map-string","text":"func ( m Map ) String () string","title":"func (Map) String"},{"location":"reference/rel/#type-migration","text":"type Migration interface { // contains filtered or unexported methods } Migration definition.","title":"type Migration"},{"location":"reference/rel/#type-mutate","text":"type Mutate struct { Type ChangeOp Field string Value interface {} } Mutate stores mutation instruction.","title":"type Mutate"},{"location":"reference/rel/#func-dec","text":"func Dec ( field string ) Mutate Dec create a mutate using deccrement operation.","title":"func Dec"},{"location":"reference/rel/#func-decby","text":"func DecBy ( field string , n int ) Mutate DecBy create a mutate using decrement operation with custom decrement value.","title":"func DecBy"},{"location":"reference/rel/#func-inc","text":"func Inc ( field string ) Mutate Inc create a mutate using increment operation.","title":"func Inc"},{"location":"reference/rel/#func-incby","text":"func IncBy ( field string , n int ) Mutate IncBy create a mutate using increment operation with custom increment value.","title":"func IncBy"},{"location":"reference/rel/#func-set","text":"func Set ( field string , value interface {}) Mutate Set create a mutate using set operation.","title":"func Set"},{"location":"reference/rel/#func-setfragment","text":"func SetFragment ( raw string , args ... interface {}) Mutate SetFragment create a mutate operation using fragment operation. Only available for Update.","title":"func SetFragment"},{"location":"reference/rel/#func-mutate-apply","text":"func ( m Mutate ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Mutate) Apply"},{"location":"reference/rel/#func-mutate-string","text":"func ( m Mutate ) String () string String representation","title":"func (Mutate) String"},{"location":"reference/rel/#type-mutation","text":"type Mutation struct { Mutates map [ string ] Mutate Assoc map [ string ] AssocMutation OnConflict OnConflict Unscoped Unscoped Reload Reload Cascade Cascade ErrorFunc ErrorFunc } Mutation represents value to be inserted or updated to database. It's not safe to be used multiple time. some operation my alter mutation data.","title":"type Mutation"},{"location":"reference/rel/#func-apply","text":"func Apply ( doc * Document , mutators ... Mutator ) Mutation Apply using given mutators.","title":"func Apply"},{"location":"reference/rel/#func-mutation-add","text":"func ( m * Mutation ) Add ( mut Mutate ) Add a mutate.","title":"func (*Mutation) Add"},{"location":"reference/rel/#func-mutation-isassocempty","text":"func ( m * Mutation ) IsAssocEmpty () bool IsAssocEmpty returns true if no assoc's mutation is defined.","title":"func (*Mutation) IsAssocEmpty"},{"location":"reference/rel/#func-mutation-isempty","text":"func ( m * Mutation ) IsEmpty () bool IsEmpty returns true if no mutates operation and assoc's mutation is defined.","title":"func (*Mutation) IsEmpty"},{"location":"reference/rel/#func-mutation-ismutatesempty","text":"func ( m * Mutation ) IsMutatesEmpty () bool IsMutatesEmpty returns true if no mutates operation is defined.","title":"func (*Mutation) IsMutatesEmpty"},{"location":"reference/rel/#func-mutation-setassoc","text":"func ( m * Mutation ) SetAssoc ( field string , muts ... Mutation ) SetAssoc mutation.","title":"func (*Mutation) SetAssoc"},{"location":"reference/rel/#func-mutation-setdeletedids","text":"func ( m * Mutation ) SetDeletedIDs ( field string , ids [] interface {}) SetDeletedIDs mutation. nil slice will clear association.","title":"func (*Mutation) SetDeletedIDs"},{"location":"reference/rel/#type-mutator","text":"type Mutator interface { Apply ( doc * Document , mutation * Mutation ) } Mutator is interface for a record mutator.","title":"type Mutator"},{"location":"reference/rel/#type-name","text":"type Name string Name option for defining custom index name.","title":"type Name"},{"location":"reference/rel/#type-notfounderror","text":"type NotFoundError struct {} NotFoundError returned whenever Find returns no result.","title":"type NotFoundError"},{"location":"reference/rel/#func-notfounderror-error","text":"func ( nfe NotFoundError ) Error () string Error message.","title":"func (NotFoundError) Error"},{"location":"reference/rel/#func-notfounderror-is","text":"func ( nfe NotFoundError ) Is ( target error ) bool Is returns true when target error is sql.ErrNoRows.","title":"func (NotFoundError) Is"},{"location":"reference/rel/#type-nowfunc","text":"type NowFunc func () time . Time NowFunc is the type of function that returns the current time. var ( Now NowFunc = func () time . Time { return time . Now (). Truncate ( time . Second ) } )","title":"type NowFunc"},{"location":"reference/rel/#type-offset","text":"type Offset int Offset Query.","title":"type Offset"},{"location":"reference/rel/#func-offset-build","text":"func ( o Offset ) Build ( query * Query ) Build query.","title":"func (Offset) Build"},{"location":"reference/rel/#type-onconflict","text":"type OnConflict struct { Keys [] string Ignore bool Replace bool Fragment string FragmentArgs [] interface {} } OnConflict mutation.","title":"type OnConflict"},{"location":"reference/rel/#func-onconflictfragment","text":"func OnConflictFragment ( sql string , args ... interface {}) OnConflict OnConflictFragment allows to write custom sql for on conflict. This will add custom sql after ON CONFLICT, example: ON CONFLICT [FRAGMENT]","title":"func OnConflictFragment"},{"location":"reference/rel/#func-onconflictignore","text":"func OnConflictIgnore () OnConflict OnConflictIgnore insertion when conflict happens.","title":"func OnConflictIgnore"},{"location":"reference/rel/#func-onconflictkeyignore","text":"func OnConflictKeyIgnore ( key string ) OnConflict OnConflictKeyIgnore insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored.","title":"func OnConflictKeyIgnore"},{"location":"reference/rel/#func-onconflictkeyreplace","text":"func OnConflictKeyReplace ( key string ) OnConflict OnConflictKeyReplace insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored.","title":"func OnConflictKeyReplace"},{"location":"reference/rel/#func-onconflictkeysignore","text":"func OnConflictKeysIgnore ( keys [] string ) OnConflict OnConflictKeysIgnore insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored.","title":"func OnConflictKeysIgnore"},{"location":"reference/rel/#func-onconflictkeysreplace","text":"func OnConflictKeysReplace ( keys [] string ) OnConflict OnConflictKeysReplace insertion when conflict happens on specific keys. Specifying key is not supported by all database and may be ignored.","title":"func OnConflictKeysReplace"},{"location":"reference/rel/#func-onconflictreplace","text":"func OnConflictReplace () OnConflict OnConflictReplace insertion when conflict happens.","title":"func OnConflictReplace"},{"location":"reference/rel/#func-onconflict-apply","text":"func ( ocm OnConflict ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (OnConflict) Apply"},{"location":"reference/rel/#type-ondelete","text":"type OnDelete string OnDelete option for foreign key.","title":"type OnDelete"},{"location":"reference/rel/#type-onupdate","text":"type OnUpdate string OnUpdate option for foreign key.","title":"type OnUpdate"},{"location":"reference/rel/#type-optional","text":"type Optional bool Optional option. when used with create table, will create table only if it's not exists. when used with drop table, will drop table only if it's exists.","title":"type Optional"},{"location":"reference/rel/#type-options","text":"type Options string Options options for table, column and index.","title":"type Options"},{"location":"reference/rel/#type-precision","text":"type Precision int Precision defines the precision for the decimal fields, representing the total number of digits in the number.","title":"type Precision"},{"location":"reference/rel/#type-preload","text":"type Preload string Preload query.","title":"type Preload"},{"location":"reference/rel/#func-preload-build","text":"func ( p Preload ) Build ( query * Query ) Build query.","title":"func (Preload) Build"},{"location":"reference/rel/#type-primary","text":"type Primary bool Primary set column as primary.","title":"type Primary"},{"location":"reference/rel/#type-querier","text":"type Querier interface { Build ( * Query ) } Querier interface defines contract to be used for query builder.","title":"type Querier"},{"location":"reference/rel/#type-query","text":"type Query struct { Table string SelectQuery SelectQuery JoinQuery [] JoinQuery WhereQuery FilterQuery GroupQuery GroupQuery SortQuery [] SortQuery OffsetQuery Offset LimitQuery Limit LockQuery Lock SQLQuery SQLQuery UnscopedQuery Unscoped ReloadQuery Reload CascadeQuery Cascade PreloadQuery [] string UsePrimaryDb bool // contains filtered or unexported fields } Query defines information about query generated by query builder.","title":"type Query"},{"location":"reference/rel/#func-build","text":"func Build ( table string , queriers ... Querier ) Query Build for given table using given queriers.","title":"func Build"},{"location":"reference/rel/#func-from","text":"func From ( table string ) Query From create a query with chainable syntax, using from as the starting point.","title":"func From"},{"location":"reference/rel/#func-join","text":"func Join ( table string , filter ... FilterQuery ) Query Join create a query with chainable syntax, using join as the starting point.","title":"func Join"},{"location":"reference/rel/#func-joinon","text":"func JoinOn ( table string , from string , to string , filter ... FilterQuery ) Query JoinOn create a query with chainable syntax, using join as the starting point.","title":"func JoinOn"},{"location":"reference/rel/#func-joinwith","text":"func JoinWith ( mode string , table string , from string , to string , filter ... FilterQuery ) Query JoinWith create a query with chainable syntax, using join as the starting point.","title":"func JoinWith"},{"location":"reference/rel/#func-joinf","text":"func Joinf ( expr string , args ... interface {}) Query Joinf create a query with chainable syntax, using join as the starting point.","title":"func Joinf"},{"location":"reference/rel/#func-select","text":"func Select ( fields ... string ) Query Select query create a query with chainable syntax, using select as the starting point.","title":"func Select"},{"location":"reference/rel/#func-useprimary","text":"func UsePrimary () Query","title":"func UsePrimary"},{"location":"reference/rel/#func-where","text":"func Where ( filters ... FilterQuery ) Query Where create a query with chainable syntax, using where as the starting point.","title":"func Where"},{"location":"reference/rel/#func-query-build","text":"func ( q Query ) Build ( query * Query ) Build query.","title":"func (Query) Build"},{"location":"reference/rel/#func-query-cascade","text":"func ( q Query ) Cascade ( c bool ) Query Cascade enable/disable autoload association on Find and FindAll query.","title":"func (Query) Cascade"},{"location":"reference/rel/#func-query-distinct","text":"func ( q Query ) Distinct () Query Distinct sets select query to be distinct.","title":"func (Query) Distinct"},{"location":"reference/rel/#func-query-from","text":"func ( q Query ) From ( table string ) Query From set the table to be used for query.","title":"func (Query) From"},{"location":"reference/rel/#func-query-group","text":"func ( q Query ) Group ( fields ... string ) Query Group query.","title":"func (Query) Group"},{"location":"reference/rel/#func-query-having","text":"func ( q Query ) Having ( filters ... FilterQuery ) Query Having query.","title":"func (Query) Having"},{"location":"reference/rel/#func-query-havingf","text":"func ( q Query ) Havingf ( expr string , args ... interface {}) Query Havingf create having query using a raw query.","title":"func (Query) Havingf"},{"location":"reference/rel/#func-query-join","text":"func ( q Query ) Join ( table string , filter ... FilterQuery ) Query Join current table with other table.","title":"func (Query) Join"},{"location":"reference/rel/#func-query-joinon","text":"func ( q Query ) JoinOn ( table string , from string , to string , filter ... FilterQuery ) Query JoinOn current table with other table.","title":"func (Query) JoinOn"},{"location":"reference/rel/#func-query-joinwith","text":"func ( q Query ) JoinWith ( mode string , table string , from string , to string , filter ... FilterQuery ) Query JoinWith current table with other table with custom join mode.","title":"func (Query) JoinWith"},{"location":"reference/rel/#func-query-joinf","text":"func ( q Query ) Joinf ( expr string , args ... interface {}) Query Joinf create join query using a raw query.","title":"func (Query) Joinf"},{"location":"reference/rel/#func-query-limit","text":"func ( q Query ) Limit ( limit int ) Query Limit result returned by database.","title":"func (Query) Limit"},{"location":"reference/rel/#func-query-lock","text":"func ( q Query ) Lock ( lock string ) Query Lock query expression.","title":"func (Query) Lock"},{"location":"reference/rel/#func-query-offset","text":"func ( q Query ) Offset ( offset int ) Query Offset the result returned by database.","title":"func (Query) Offset"},{"location":"reference/rel/#func-query-orhaving","text":"func ( q Query ) OrHaving ( filters ... FilterQuery ) Query OrHaving query.","title":"func (Query) OrHaving"},{"location":"reference/rel/#func-query-orhavingf","text":"func ( q Query ) OrHavingf ( expr string , args ... interface {}) Query OrHavingf create having query using a raw query.","title":"func (Query) OrHavingf"},{"location":"reference/rel/#func-query-orwhere","text":"func ( q Query ) OrWhere ( filters ... FilterQuery ) Query OrWhere query.","title":"func (Query) OrWhere"},{"location":"reference/rel/#func-query-orwheref","text":"func ( q Query ) OrWheref ( expr string , args ... interface {}) Query OrWheref create where query using a raw query.","title":"func (Query) OrWheref"},{"location":"reference/rel/#func-query-preload","text":"func ( q Query ) Preload ( field string ) Query Preload field association.","title":"func (Query) Preload"},{"location":"reference/rel/#func-query-reload","text":"func ( q Query ) Reload () Query Reload force reloading association on preload.","title":"func (Query) Reload"},{"location":"reference/rel/#func-query-select","text":"func ( q Query ) Select ( fields ... string ) Query Select filter fields to be selected from database.","title":"func (Query) Select"},{"location":"reference/rel/#func-query-sort","text":"func ( q Query ) Sort ( fields ... string ) Query Sort query.","title":"func (Query) Sort"},{"location":"reference/rel/#func-query-sortasc","text":"func ( q Query ) SortAsc ( fields ... string ) Query SortAsc query.","title":"func (Query) SortAsc"},{"location":"reference/rel/#func-query-sortdesc","text":"func ( q Query ) SortDesc ( fields ... string ) Query SortDesc query.","title":"func (Query) SortDesc"},{"location":"reference/rel/#func-query-string","text":"func ( q Query ) String () string String describe query as string.","title":"func (Query) String"},{"location":"reference/rel/#func-query-unscoped","text":"func ( q Query ) Unscoped () Query Unscoped allows soft-delete to be ignored.","title":"func (Query) Unscoped"},{"location":"reference/rel/#func-query-useprimary","text":"func ( q Query ) UsePrimary () Query UsePrimary database.","title":"func (Query) UsePrimary"},{"location":"reference/rel/#func-query-where","text":"func ( q Query ) Where ( filters ... FilterQuery ) Query Where query.","title":"func (Query) Where"},{"location":"reference/rel/#func-query-wheref","text":"func ( q Query ) Wheref ( expr string , args ... interface {}) Query Wheref create where query using a raw query.","title":"func (Query) Wheref"},{"location":"reference/rel/#type-raw","text":"type Raw string Raw string","title":"type Raw"},{"location":"reference/rel/#type-reload","text":"type Reload bool Reload force reload after insert/update. Default to false.","title":"type Reload"},{"location":"reference/rel/#func-reload-apply","text":"func ( r Reload ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Reload) Apply"},{"location":"reference/rel/#func-reload-build","text":"func ( r Reload ) Build ( query * Query ) Build query.","title":"func (Reload) Build"},{"location":"reference/rel/#type-repository","text":"type Repository interface { // Adapter used in this repository. Adapter ( ctx context . Context ) Adapter // Instrumentation defines callback to be used as instrumenter. Instrumentation ( instrumenter Instrumenter ) // Ping database. Ping ( ctx context . Context ) error // Iterate through a collection of records from database in batches. // This function returns iterator that can be used to loop all records. // Limit, Offset and Sort query is automatically ignored. Iterate ( ctx context . Context , query Query , option ... IteratorOption ) Iterator // Aggregate over the given field. // Supported aggregate: count, sum, avg, max, min. // Any select, group, offset, limit and sort query will be ignored automatically. // If complex aggregation is needed, consider using All instead. Aggregate ( ctx context . Context , query Query , aggregate string , field string ) ( int , error ) // MustAggregate over the given field. // Supported aggregate: count, sum, avg, max, min. // Any select, group, offset, limit and sort query will be ignored automatically. // If complex aggregation is needed, consider using All instead. // It'll panic if any error eccured. MustAggregate ( ctx context . Context , query Query , aggregate string , field string ) int // Count records that match the query. Count ( ctx context . Context , collection string , queriers ... Querier ) ( int , error ) // MustCount records that match the query. // It'll panic if any error eccured. MustCount ( ctx context . Context , collection string , queriers ... Querier ) int // Find a record that match the query. // If no result found, it'll return not found error. Find ( ctx context . Context , record interface {}, queriers ... Querier ) error // MustFind a record that match the query. // If no result found, it'll panic. MustFind ( ctx context . Context , record interface {}, queriers ... Querier ) // FindAll records that match the query. FindAll ( ctx context . Context , records interface {}, queriers ... Querier ) error // MustFindAll records that match the query. // It'll panic if any error eccured. MustFindAll ( ctx context . Context , records interface {}, queriers ... Querier ) // FindAndCountAll records that match the query. // This is a convenient method that combines FindAll and Count. It's useful when dealing with queries related to pagination. // Limit and Offset property will be ignored when performing count query. FindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) ( int , error ) // MustFindAndCountAll records that match the query. // This is a convenient method that combines FindAll and Count. It's useful when dealing with queries related to pagination. // Limit and Offset property will be ignored when performing count query. // It'll panic if any error eccured. MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... Querier ) int // Insert a record to database. Insert ( ctx context . Context , record interface {}, mutators ... Mutator ) error // MustInsert an record to database. // It'll panic if any error occurred. MustInsert ( ctx context . Context , record interface {}, mutators ... Mutator ) // InsertAll records. // Does not supports application cascade insert. InsertAll ( ctx context . Context , records interface {}, mutators ... Mutator ) error // MustInsertAll records. // It'll panic if any error occurred. // Does not supports application cascade insert. MustInsertAll ( ctx context . Context , records interface {}, mutators ... Mutator ) // Update a record in database. // It'll panic if any error occurred. Update ( ctx context . Context , record interface {}, mutators ... Mutator ) error // MustUpdate a record in database. // It'll panic if any error occurred. MustUpdate ( ctx context . Context , record interface {}, mutators ... Mutator ) // UpdateAny records tha match the query. // Returns number of updated records and error. UpdateAny ( ctx context . Context , query Query , mutates ... Mutate ) ( int , error ) // MustUpdateAny records that match the query. // It'll panic if any error occurred. // Returns number of updated records. MustUpdateAny ( ctx context . Context , query Query , mutates ... Mutate ) int // Delete a record. Delete ( ctx context . Context , record interface {}, mutators ... Mutator ) error // MustDelete a record. // It'll panic if any error eccured. MustDelete ( ctx context . Context , record interface {}, mutators ... Mutator ) // DeleteAll records. // Does not supports application cascade delete. DeleteAll ( ctx context . Context , records interface {}) error // MustDeleteAll records. // It'll panic if any error occurred. // Does not supports application cascade delete. MustDeleteAll ( ctx context . Context , records interface {}) // DeleteAny records that match the query. // Returns number of deleted records and error. DeleteAny ( ctx context . Context , query Query ) ( int , error ) // MustDeleteAny records that match the query. // It'll panic if any error eccured. // Returns number of updated records. MustDeleteAny ( ctx context . Context , query Query ) int // Preload association with given query. // This function can accepts either a struct or a slice of structs. // If association is already loaded, this will do nothing. // To force preloading even though association is already loaeded, add `Reload(true)` as query. Preload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) error // MustPreload association with given query. // This function can accepts either a struct or a slice of structs. // It'll panic if any error occurred. MustPreload ( ctx context . Context , records interface {}, field string , queriers ... Querier ) // Exec raw statement. // Returns last inserted id, rows affected and error. Exec ( ctx context . Context , statement string , args ... interface {}) ( int , int , error ) // MustExec raw statement. // Returns last inserted id, rows affected and error. MustExec ( ctx context . Context , statement string , args ... interface {}) ( int , int ) // Transaction performs transaction with given function argument. // Transaction scope/connection is automatically passed using context. Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error } Repository for interacting with database.","title":"type Repository"},{"location":"reference/rel/#func-new","text":"func New ( adapter Adapter ) Repository New create new repo using adapter.","title":"func New"},{"location":"reference/rel/#type-required","text":"type Required bool Required disallows nil values in the column.","title":"type Required"},{"location":"reference/rel/#type-sqlquery","text":"type SQLQuery struct { Statement string Values [] interface {} } SQLQuery allows querying using native query supported by database.","title":"type SQLQuery"},{"location":"reference/rel/#func-sql","text":"func SQL ( statement string , values ... interface {}) SQLQuery SQL Query.","title":"func SQL"},{"location":"reference/rel/#func-sqlquery-build","text":"func ( sq SQLQuery ) Build ( query * Query ) Build Raw Query.","title":"func (SQLQuery) Build"},{"location":"reference/rel/#func-sqlquery-string","text":"func ( sq SQLQuery ) String () string","title":"func (SQLQuery) String"},{"location":"reference/rel/#type-scale","text":"type Scale int Scale Defines the scale for the decimal fields, representing the number of digits after the decimal point.","title":"type Scale"},{"location":"reference/rel/#type-schema","text":"type Schema struct { Migrations [] Migration } Schema builder.","title":"type Schema"},{"location":"reference/rel/#func-schema-addcolumn","text":"func ( s * Schema ) AddColumn ( table string , name string , typ ColumnType , options ... ColumnOption ) AddColumn with name and type.","title":"func (*Schema) AddColumn"},{"location":"reference/rel/#func-schema-altertable","text":"func ( s * Schema ) AlterTable ( name string , fn func ( t * AlterTable ), options ... TableOption ) AlterTable with name and its definition.","title":"func (*Schema) AlterTable"},{"location":"reference/rel/#func-schema-createindex","text":"func ( s * Schema ) CreateIndex ( table string , name string , column [] string , options ... IndexOption ) CreateIndex for columns on a table.","title":"func (*Schema) CreateIndex"},{"location":"reference/rel/#func-schema-createtable","text":"func ( s * Schema ) CreateTable ( name string , fn func ( t * Table ), options ... TableOption ) CreateTable with name and its definition.","title":"func (*Schema) CreateTable"},{"location":"reference/rel/#func-schema-createtableifnotexists","text":"func ( s * Schema ) CreateTableIfNotExists ( name string , fn func ( t * Table ), options ... TableOption ) CreateTableIfNotExists with name and its definition.","title":"func (*Schema) CreateTableIfNotExists"},{"location":"reference/rel/#func-schema-createuniqueindex","text":"func ( s * Schema ) CreateUniqueIndex ( table string , name string , column [] string , options ... IndexOption ) CreateUniqueIndex for columns on a table.","title":"func (*Schema) CreateUniqueIndex"},{"location":"reference/rel/#func-schema-do","text":"func ( s * Schema ) Do ( fn Do ) Do migration using golang codes.","title":"func (*Schema) Do"},{"location":"reference/rel/#func-schema-dropcolumn","text":"func ( s * Schema ) DropColumn ( table string , name string , options ... ColumnOption ) DropColumn by name.","title":"func (*Schema) DropColumn"},{"location":"reference/rel/#func-schema-dropindex","text":"func ( s * Schema ) DropIndex ( table string , name string , options ... IndexOption ) DropIndex by name.","title":"func (*Schema) DropIndex"},{"location":"reference/rel/#func-schema-droptable","text":"func ( s * Schema ) DropTable ( name string , options ... TableOption ) DropTable by name.","title":"func (*Schema) DropTable"},{"location":"reference/rel/#func-schema-droptableifexists","text":"func ( s * Schema ) DropTableIfExists ( name string , options ... TableOption ) DropTableIfExists by name.","title":"func (*Schema) DropTableIfExists"},{"location":"reference/rel/#func-schema-exec","text":"func ( s * Schema ) Exec ( raw Raw ) Exec queries.","title":"func (*Schema) Exec"},{"location":"reference/rel/#func-schema-renamecolumn","text":"func ( s * Schema ) RenameColumn ( table string , name string , newName string , options ... ColumnOption ) RenameColumn by name.","title":"func (*Schema) RenameColumn"},{"location":"reference/rel/#func-schema-renametable","text":"func ( s * Schema ) RenameTable ( name string , newName string , options ... TableOption ) RenameTable by name.","title":"func (*Schema) RenameTable"},{"location":"reference/rel/#func-schema-string","text":"func ( s Schema ) String () string String returns schema operation.","title":"func (Schema) String"},{"location":"reference/rel/#type-schemaop","text":"type SchemaOp uint8 SchemaOp type. const ( // SchemaCreate operation. SchemaCreate SchemaOp = iota // SchemaAlter operation. SchemaAlter // SchemaRename operation. SchemaRename // SchemaDrop operation. SchemaDrop )","title":"type SchemaOp"},{"location":"reference/rel/#func-schemaop-string","text":"func ( s SchemaOp ) String () string","title":"func (SchemaOp) String"},{"location":"reference/rel/#type-selectquery","text":"type SelectQuery struct { OnlyDistinct bool Fields [] string } SelectQuery defines select clause of the query.","title":"type SelectQuery"},{"location":"reference/rel/#func-newselect","text":"func NewSelect ( fields ... string ) SelectQuery NewSelect query. Deprecated: use Select instead","title":"func NewSelect"},{"location":"reference/rel/#func-selectquery-distinct","text":"func ( sq SelectQuery ) Distinct () SelectQuery Distinct select query.","title":"func (SelectQuery) Distinct"},{"location":"reference/rel/#type-sortquery","text":"type SortQuery struct { Field string Sort int } SortQuery defines sort information of query.","title":"type SortQuery"},{"location":"reference/rel/#func-sortasc","text":"func SortAsc ( field string ) SortQuery SortAsc sorts field with ascending sort.","title":"func SortAsc"},{"location":"reference/rel/#func-sortdesc","text":"func SortDesc ( field string ) SortQuery NewSortDesc sorts field with descending sort.","title":"func SortDesc"},{"location":"reference/rel/#func-sortquery-asc","text":"func ( sq SortQuery ) Asc () bool Asc returns true if sort is ascending.","title":"func (SortQuery) Asc"},{"location":"reference/rel/#func-sortquery-build","text":"func ( sq SortQuery ) Build ( query * Query ) Build sort query.","title":"func (SortQuery) Build"},{"location":"reference/rel/#func-sortquery-desc","text":"func ( sq SortQuery ) Desc () bool Desc returns true if s is descending.","title":"func (SortQuery) Desc"},{"location":"reference/rel/#type-structset","text":"type Structset struct { // contains filtered or unexported fields } Structset can be used as mutation for repository insert or update operation. This will save every field in struct and it's association as long as it's loaded. This is the default mutator used by repository.","title":"type Structset"},{"location":"reference/rel/#func-newstructset","text":"func NewStructset ( record interface {}, skipZero bool ) Structset NewStructset from a struct.","title":"func NewStructset"},{"location":"reference/rel/#func-structset-apply","text":"func ( s Structset ) Apply ( doc * Document , mut * Mutation ) Apply mutation.","title":"func (Structset) Apply"},{"location":"reference/rel/#type-subquery","text":"type SubQuery struct { Prefix string Query Query } SubQuery warps a query into: Prefix (Query)","title":"type SubQuery"},{"location":"reference/rel/#func-all","text":"func All ( sub Query ) SubQuery All warp a query into ALL(sub-query) Some database may not support this keyword, please consult to your database documentation.","title":"func All"},{"location":"reference/rel/#func-any","text":"func Any ( sub Query ) SubQuery Any warp a query into ANY(sub-query) Some database may not support this keyword, please consult to your database documentation.","title":"func Any"},{"location":"reference/rel/#type-table","text":"type Table struct { Op SchemaOp Name string Rename string Definitions [] TableDefinition Optional bool Options string } Table definition.","title":"type Table"},{"location":"reference/rel/#func-table-bigid","text":"func ( t * Table ) BigID ( name string , options ... ColumnOption ) BigID defines a column with name and Big ID type. the resulting database type will depends on database.","title":"func (*Table) BigID"},{"location":"reference/rel/#func-table-bigint","text":"func ( t * Table ) BigInt ( name string , options ... ColumnOption ) BigInt defines a column with name and BigInt type.","title":"func (*Table) BigInt"},{"location":"reference/rel/#func-table-bool","text":"func ( t * Table ) Bool ( name string , options ... ColumnOption ) Bool defines a column with name and Bool type.","title":"func (*Table) Bool"},{"location":"reference/rel/#func-table-column","text":"func ( t * Table ) Column ( name string , typ ColumnType , options ... ColumnOption ) Column defines a column with name and type.","title":"func (*Table) Column"},{"location":"reference/rel/#func-table-date","text":"func ( t * Table ) Date ( name string , options ... ColumnOption ) Date defines a column with name and Date type.","title":"func (*Table) Date"},{"location":"reference/rel/#func-table-datetime","text":"func ( t * Table ) DateTime ( name string , options ... ColumnOption ) DateTime defines a column with name and DateTime type.","title":"func (*Table) DateTime"},{"location":"reference/rel/#func-table-decimal","text":"func ( t * Table ) Decimal ( name string , options ... ColumnOption ) Decimal defines a column with name and Decimal type.","title":"func (*Table) Decimal"},{"location":"reference/rel/#func-table-float","text":"func ( t * Table ) Float ( name string , options ... ColumnOption ) Float defines a column with name and Float type.","title":"func (*Table) Float"},{"location":"reference/rel/#func-table-foreignkey","text":"func ( t * Table ) ForeignKey ( column string , refTable string , refColumn string , options ... KeyOption ) ForeignKey defines foreign key index.","title":"func (*Table) ForeignKey"},{"location":"reference/rel/#func-table-fragment","text":"func ( t * Table ) Fragment ( fragment string ) Fragment defines anything using sql fragment.","title":"func (*Table) Fragment"},{"location":"reference/rel/#func-table-id","text":"func ( t * Table ) ID ( name string , options ... ColumnOption ) ID defines a column with name and ID type. the resulting database type will depends on database.","title":"func (*Table) ID"},{"location":"reference/rel/#func-table-int","text":"func ( t * Table ) Int ( name string , options ... ColumnOption ) Int defines a column with name and Int type.","title":"func (*Table) Int"},{"location":"reference/rel/#func-table-json","text":"func ( t * Table ) JSON ( name string , options ... ColumnOption ) JSON defines a column with name and JSON type.","title":"func (*Table) JSON"},{"location":"reference/rel/#func-table-primarykey","text":"func ( t * Table ) PrimaryKey ( column string , options ... KeyOption ) PrimaryKey defines a primary key for table.","title":"func (*Table) PrimaryKey"},{"location":"reference/rel/#func-table-primarykeys","text":"func ( t * Table ) PrimaryKeys ( columns [] string , options ... KeyOption ) PrimaryKeys defines composite primary keys for table.","title":"func (*Table) PrimaryKeys"},{"location":"reference/rel/#func-table-smallint","text":"func ( t * Table ) SmallInt ( name string , options ... ColumnOption ) SmallInt defines a column with name and Small type.","title":"func (*Table) SmallInt"},{"location":"reference/rel/#func-table-string","text":"func ( t * Table ) String ( name string , options ... ColumnOption ) String defines a column with name and String type.","title":"func (*Table) String"},{"location":"reference/rel/#func-table-text","text":"func ( t * Table ) Text ( name string , options ... ColumnOption ) Text defines a column with name and Text type.","title":"func (*Table) Text"},{"location":"reference/rel/#func-table-time","text":"func ( t * Table ) Time ( name string , options ... ColumnOption ) Time defines a column with name and Time type.","title":"func (*Table) Time"},{"location":"reference/rel/#func-table-unique","text":"func ( t * Table ) Unique ( columns [] string , options ... KeyOption ) Unique defines an unique key for columns.","title":"func (*Table) Unique"},{"location":"reference/rel/#type-tabledefinition","text":"type TableDefinition interface { // contains filtered or unexported methods } TableDefinition interface.","title":"type TableDefinition"},{"location":"reference/rel/#type-tableoption","text":"type TableOption interface { // contains filtered or unexported methods } TableOption interface. Available options are: Comment, Options.","title":"type TableOption"},{"location":"reference/rel/#type-unique","text":"type Unique bool Unique set column as unique.","title":"type Unique"},{"location":"reference/rel/#type-unscoped","text":"type Unscoped bool Unscoped query.","title":"type Unscoped"},{"location":"reference/rel/#func-unscoped-apply","text":"func ( u Unscoped ) Apply ( doc * Document , mutation * Mutation ) Apply mutation.","title":"func (Unscoped) Apply"},{"location":"reference/rel/#func-unscoped-build","text":"func ( u Unscoped ) Build ( query * Query ) Build query.","title":"func (Unscoped) Build"},{"location":"reference/rel/#type-unsigned","text":"type Unsigned bool Unsigned sets integer column to be unsigned.","title":"type Unsigned"},{"location":"reference/reltest/","text":"reltest \u00b6 import \"github.com/go-rel/reltest\" Overview \u00b6 Package reltest for unit testing database interaction. Variables \u00b6 var Any interface {} = any {} var ( // ErrConnectionClosed is alias for sql.ErrConnDone. ErrConnectionClosed = sql . ErrConnDone ) type Assert \u00b6 type Assert struct { // contains filtered or unexported fields } func (*Assert) Many \u00b6 func ( a * Assert ) Many () Many set max calls to unlimited times. func (*Assert) Maybe \u00b6 func ( a * Assert ) Maybe () Maybe allow calls to be skipped. func (*Assert) Once \u00b6 func ( a * Assert ) Once () Once set max calls to one time. func (*Assert) Times \u00b6 func ( a * Assert ) Times ( times int ) Times set number of allowed calls. func (*Assert) Twice \u00b6 func ( a * Assert ) Twice () Twice set max calls to two times. type MockAggregate \u00b6 type MockAggregate struct { // contains filtered or unexported fields } MockAggregate asserts and simulate UpdateAny function for test. func (*MockAggregate) ConnectionClosed \u00b6 func ( ma * MockAggregate ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockAggregate) Error \u00b6 func ( ma * MockAggregate ) Error ( err error ) * Assert Error sets error to be returned. func (MockAggregate) ExpectString \u00b6 func ( ma MockAggregate ) ExpectString () string ExpectString representation of mocked call. func (*MockAggregate) Result \u00b6 func ( ma * MockAggregate ) Result ( count int ) * Assert Result sets the result of this query. func (MockAggregate) String \u00b6 func ( ma MockAggregate ) String () string String representation of mocked call. type MockCount \u00b6 type MockCount struct { // contains filtered or unexported fields } MockCount asserts and simulate UpdateAny function for test. func (*MockCount) ConnectionClosed \u00b6 func ( mc * MockCount ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockCount) Error \u00b6 func ( mc * MockCount ) Error ( err error ) * Assert Error sets error to be returned. func (MockCount) ExpectString \u00b6 func ( mc MockCount ) ExpectString () string ExpectString representation of mocked call. func (*MockCount) Result \u00b6 func ( mc * MockCount ) Result ( count int ) * Assert Result sets the result of this query. func (MockCount) String \u00b6 func ( mc MockCount ) String () string String representation of mocked call. type MockDelete \u00b6 type MockDelete struct { // contains filtered or unexported fields } MockDelete asserts and simulate Delete function for test. func (*MockDelete) ConnectionClosed \u00b6 func ( md * MockDelete ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockDelete) Error \u00b6 func ( md * MockDelete ) Error ( err error ) * Assert Error sets error to be returned. func (MockDelete) ExpectString \u00b6 func ( md MockDelete ) ExpectString () string ExpectString representation of mocked call. func (*MockDelete) For \u00b6 func ( md * MockDelete ) For ( record interface {}) * MockDelete For assert calls for given record. func (*MockDelete) ForContains \u00b6 func ( md * MockDelete ) ForContains ( contains interface {}) * MockDelete ForContains assert calls to contains some value of given struct. func (*MockDelete) ForTable \u00b6 func ( md * MockDelete ) ForTable ( typ string ) * MockDelete ForTable assert calls for given table. func (*MockDelete) ForType \u00b6 func ( md * MockDelete ) ForType ( typ string ) * MockDelete ForType assert calls for given type. Type must include package name, example: model.User . func (MockDelete) String \u00b6 func ( md MockDelete ) String () string String representation of mocked call. func (*MockDelete) Success \u00b6 func ( md * MockDelete ) Success () * Assert Success sets no error to be returned. type MockDeleteAll \u00b6 type MockDeleteAll struct { // contains filtered or unexported fields } MockDeleteAll asserts and simulate Delete function for test. func (*MockDeleteAll) ConnectionClosed \u00b6 func ( mda * MockDeleteAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockDeleteAll) Error \u00b6 func ( mda * MockDeleteAll ) Error ( err error ) * Assert Error sets error to be returned. func (MockDeleteAll) ExpectString \u00b6 func ( mda MockDeleteAll ) ExpectString () string ExpectString representation of mocked call. func (*MockDeleteAll) For \u00b6 func ( mda * MockDeleteAll ) For ( record interface {}) * MockDeleteAll For assert calls for given record. func (*MockDeleteAll) ForTable \u00b6 func ( mda * MockDeleteAll ) ForTable ( typ string ) * MockDeleteAll ForTable assert calls for given table. func (*MockDeleteAll) ForType \u00b6 func ( mda * MockDeleteAll ) ForType ( typ string ) * MockDeleteAll ForType assert calls for given type. Type must include package name, example: model.User . func (MockDeleteAll) String \u00b6 func ( mda MockDeleteAll ) String () string String representation of mocked call. func (*MockDeleteAll) Success \u00b6 func ( mda * MockDeleteAll ) Success () * Assert Success sets no error to be returned. type MockDeleteAny \u00b6 type MockDeleteAny struct { // contains filtered or unexported fields } MockDeleteAny asserts and simulate DeleteAny function for test. func (*MockDeleteAny) ConnectionClosed \u00b6 func ( mda * MockDeleteAny ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockDeleteAny) DeletedCount \u00b6 func ( mda * MockDeleteAny ) DeletedCount ( deletedCount int ) * Assert DeletedCount set the returned deleted count of this function. func (*MockDeleteAny) Error \u00b6 func ( mda * MockDeleteAny ) Error ( err error ) * Assert Error sets error to be returned. func (MockDeleteAny) ExpectString \u00b6 func ( mda MockDeleteAny ) ExpectString () string ExpectString representation of mocked call. func (MockDeleteAny) String \u00b6 func ( mda MockDeleteAny ) String () string String representation of mocked call. func (*MockDeleteAny) Success \u00b6 func ( mda * MockDeleteAny ) Success () * Assert Success sets no error to be returned. func (*MockDeleteAny) Unsafe \u00b6 func ( mda * MockDeleteAny ) Unsafe () * MockDeleteAny Unsafe allows for unsafe operation to delete records without where condition. type MockExec \u00b6 type MockExec struct { // contains filtered or unexported fields } MockExec asserts and simulate UpdateAny function for test. func (*MockExec) ConnectionClosed \u00b6 func ( me * MockExec ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockExec) Error \u00b6 func ( me * MockExec ) Error ( err error ) * Assert Error sets error to be returned. func (MockExec) ExpectString \u00b6 func ( me MockExec ) ExpectString () string ExpectString representation of mocked call. func (*MockExec) Result \u00b6 func ( me * MockExec ) Result ( lastInsertedId int , rowsAffected int ) * Assert Result sets the result of this query. func (MockExec) String \u00b6 func ( me MockExec ) String () string String representation of mocked call. type MockFind \u00b6 type MockFind struct { // contains filtered or unexported fields } MockFind asserts and simulate find function for test. func (*MockFind) ConnectionClosed \u00b6 func ( mf * MockFind ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockFind) Error \u00b6 func ( mf * MockFind ) Error ( err error ) * Assert Error sets error to be returned. func (MockFind) ExpectString \u00b6 func ( mf MockFind ) ExpectString () string ExpectString representation of mocked call. func (*MockFind) NotFound \u00b6 func ( mf * MockFind ) NotFound () * Assert NotFound sets NotFoundError to be returned. func (*MockFind) Result \u00b6 func ( mf * MockFind ) Result ( result interface {}) * Assert Result sets the result of this query. func (MockFind) String \u00b6 func ( mf MockFind ) String () string String representation of mocked call. type MockFindAll \u00b6 type MockFindAll struct { // contains filtered or unexported fields } MockFindAll asserts and simulate find all function for test. func (*MockFindAll) ConnectionClosed \u00b6 func ( mfa * MockFindAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockFindAll) Error \u00b6 func ( mfa * MockFindAll ) Error ( err error ) * Assert Error sets error to be returned. func (MockFindAll) ExpectString \u00b6 func ( mfa MockFindAll ) ExpectString () string ExpectString representation of mocked call. func (*MockFindAll) Result \u00b6 func ( mfa * MockFindAll ) Result ( result interface {}) * Assert Result sets the result of this query. func (MockFindAll) String \u00b6 func ( mfa MockFindAll ) String () string String representation of mocked call. type MockFindAndCountAll \u00b6 type MockFindAndCountAll struct { // contains filtered or unexported fields } MockFindAndCountAll asserts and simulate find and count all function for test. func (*MockFindAndCountAll) ConnectionClosed \u00b6 func ( mfca * MockFindAndCountAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockFindAndCountAll) Error \u00b6 func ( mfca * MockFindAndCountAll ) Error ( err error ) * Assert Error sets error to be returned. func (MockFindAndCountAll) ExpectString \u00b6 func ( mfca MockFindAndCountAll ) ExpectString () string ExpectString representation of mocked call. func (*MockFindAndCountAll) Result \u00b6 func ( mfca * MockFindAndCountAll ) Result ( result interface {}, count int ) * Assert Result sets the result of this query. func (MockFindAndCountAll) String \u00b6 func ( mfca MockFindAndCountAll ) String () string String representation of mocked call. type MockInsertAll \u00b6 type MockInsertAll struct { // contains filtered or unexported fields } MockInsertAll asserts and simulate Insert function for test. func (*MockInsertAll) ConnectionClosed \u00b6 func ( mia * MockInsertAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockInsertAll) Error \u00b6 func ( mia * MockInsertAll ) Error ( err error ) * Assert Error sets error to be returned. func (MockInsertAll) ExpectString \u00b6 func ( mia MockInsertAll ) ExpectString () string ExpectString representation of mocked call. func (*MockInsertAll) For \u00b6 func ( mia * MockInsertAll ) For ( record interface {}) * MockInsertAll For assert calls for given record. func (*MockInsertAll) ForTable \u00b6 func ( mia * MockInsertAll ) ForTable ( typ string ) * MockInsertAll ForTable assert calls for given table. func (*MockInsertAll) ForType \u00b6 func ( mia * MockInsertAll ) ForType ( typ string ) * MockInsertAll ForType assert calls for given type. Type must include package name, example: model.User . func (*MockInsertAll) NotUnique \u00b6 func ( mia * MockInsertAll ) NotUnique ( key string ) * Assert NotUnique sets not unique error to be returned. func (MockInsertAll) String \u00b6 func ( mia MockInsertAll ) String () string String representation of mocked call. func (*MockInsertAll) Success \u00b6 func ( mia * MockInsertAll ) Success () * Assert Success sets no error to be returned. type MockIterate \u00b6 type MockIterate struct { // contains filtered or unexported fields } MockIterate asserts and simulate Delete function for test. func (MockIterate) Close \u00b6 func ( mi MockIterate ) Close () error func (*MockIterate) ConnectionClosed \u00b6 func ( mi * MockIterate ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockIterate) Error \u00b6 func ( mi * MockIterate ) Error ( err error ) * Assert Error sets error to be returned. func (MockIterate) ExpectString \u00b6 func ( mi MockIterate ) ExpectString () string ExpectString representation of mocked call. func (*MockIterate) Next \u00b6 func ( mi * MockIterate ) Next ( record interface {}) error func (*MockIterate) Result \u00b6 func ( mi * MockIterate ) Result ( result interface {}) * Assert Result sets the result of preload. func (MockIterate) String \u00b6 func ( mi MockIterate ) String () string String representation of mocked call. type MockMutate \u00b6 type MockMutate struct { // contains filtered or unexported fields } MockMutate asserts and simulate Insert function for test. func (*MockMutate) ConnectionClosed \u00b6 func ( mm * MockMutate ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockMutate) Error \u00b6 func ( mm * MockMutate ) Error ( err error ) * Assert Error sets error to be returned. func (MockMutate) ExpectString \u00b6 func ( mm MockMutate ) ExpectString () string ExpectString representation of mocked call. func (*MockMutate) For \u00b6 func ( mm * MockMutate ) For ( record interface {}) * MockMutate For assert calls for given record. func (*MockMutate) ForContains \u00b6 func ( mm * MockMutate ) ForContains ( contains interface {}) * MockMutate ForContains assert calls to contains some value of given struct. func (*MockMutate) ForTable \u00b6 func ( mm * MockMutate ) ForTable ( typ string ) * MockMutate ForTable assert calls for given table. func (*MockMutate) ForType \u00b6 func ( mm * MockMutate ) ForType ( typ string ) * MockMutate ForType assert calls for given type. Type must include package name, example: model.User . func (*MockMutate) NotUnique \u00b6 func ( mm * MockMutate ) NotUnique ( key string ) * Assert NotUnique sets not unique error to be returned. func (MockMutate) String \u00b6 func ( mm MockMutate ) String () string String representation of mocked call. func (*MockMutate) Success \u00b6 func ( mm * MockMutate ) Success () * Assert Success sets no error to be returned. type MockPreload \u00b6 type MockPreload struct { // contains filtered or unexported fields } MockPreload asserts and simulate Delete function for test. func (*MockPreload) ConnectionClosed \u00b6 func ( mp * MockPreload ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockPreload) Error \u00b6 func ( mp * MockPreload ) Error ( err error ) * Assert Error sets error to be returned. func (MockPreload) ExpectString \u00b6 func ( mp MockPreload ) ExpectString () string ExpectString representation of mocked call. func (*MockPreload) For \u00b6 func ( md * MockPreload ) For ( records interface {}) * MockPreload For assert calls for given record. func (*MockPreload) ForType \u00b6 func ( md * MockPreload ) ForType ( typ string ) * MockPreload ForType assert calls for given type. Type must include package name, example: model.User . func (*MockPreload) Result \u00b6 func ( mp * MockPreload ) Result ( result interface {}) * Assert Result sets the result of preload. func (MockPreload) String \u00b6 func ( mp MockPreload ) String () string String representation of mocked call. type MockUpdateAny \u00b6 type MockUpdateAny struct { // contains filtered or unexported fields } MockUpdateAny asserts and simulate UpdateAny function for test. func (*MockUpdateAny) ConnectionClosed \u00b6 func ( mua * MockUpdateAny ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned. func (*MockUpdateAny) Error \u00b6 func ( mua * MockUpdateAny ) Error ( err error ) * Assert Error sets error to be returned. func (MockUpdateAny) ExpectString \u00b6 func ( mua MockUpdateAny ) ExpectString () string ExpectString representation of mocked call. func (MockUpdateAny) String \u00b6 func ( mua MockUpdateAny ) String () string String representation of mocked call. func (*MockUpdateAny) Unsafe \u00b6 func ( mua * MockUpdateAny ) Unsafe () * MockUpdateAny Unsafe allows for unsafe operation to delete records without where condition. func (*MockUpdateAny) UpdatedCount \u00b6 func ( mua * MockUpdateAny ) UpdatedCount ( updatedCount int ) * Assert UpdatedCount set the returned deleted count of this function. type Repository \u00b6 type Repository struct { // contains filtered or unexported fields } Repository is an autogenerated mock type for the Repository type func New \u00b6 func New () * Repository New test repository. func (*Repository) Adapter \u00b6 func ( r * Repository ) Adapter ( ctx context . Context ) rel . Adapter Adapter provides a mock function with given fields: func (*Repository) Aggregate \u00b6 func ( r * Repository ) Aggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) ( int , error ) Aggregate provides a mock function with given fields: query, aggregate, field func (*Repository) AssertExpectations \u00b6 func ( r * Repository ) AssertExpectations ( t T ) bool AssertExpectations asserts that everything was in fact called as expected. Calls may have occurred in any order. func (*Repository) Count \u00b6 func ( r * Repository ) Count ( ctx context . Context , collection string , queriers ... rel . Querier ) ( int , error ) Count provides a mock function with given fields: collection, queriers func (*Repository) Delete \u00b6 func ( r * Repository ) Delete ( ctx context . Context , record interface {}, options ... rel . Mutator ) error Delete provides a mock function with given fields: record func (*Repository) DeleteAll \u00b6 func ( r * Repository ) DeleteAll ( ctx context . Context , records interface {}) error DeleteAll provides DeleteAll mock function with given fields: records func (*Repository) DeleteAny \u00b6 func ( r * Repository ) DeleteAny ( ctx context . Context , query rel . Query ) ( int , error ) DeleteAny provides a mock function with given fields: query func (*Repository) Exec \u00b6 func ( r * Repository ) Exec ( ctx context . Context , statement string , args ... interface {}) ( int , int , error ) Exec raw statement. Returns last inserted id, rows affected and error. func (*Repository) ExpectAggregate \u00b6 func ( r * Repository ) ExpectAggregate ( query rel . Query , aggregate string , field string ) * MockAggregate ExpectAggregate apply mocks and expectations for Aggregate func (*Repository) ExpectCount \u00b6 func ( r * Repository ) ExpectCount ( collection string , queriers ... rel . Querier ) * MockCount ExpectCount apply mocks and expectations for Count func (*Repository) ExpectDelete \u00b6 func ( r * Repository ) ExpectDelete ( options ... rel . Mutator ) * MockDelete ExpectDelete apply mocks and expectations for Delete func (*Repository) ExpectDeleteAll \u00b6 func ( r * Repository ) ExpectDeleteAll () * MockDeleteAll ExpectDeleteAll apply mocks and expectations for DeleteAll func (*Repository) ExpectDeleteAny \u00b6 func ( r * Repository ) ExpectDeleteAny ( query rel . Query ) * MockDeleteAny ExpectDeleteAny apply mocks and expectations for DeleteAny func (*Repository) ExpectExec \u00b6 func ( r * Repository ) ExpectExec ( statement string , args ... interface {}) * MockExec ExpectExec for mocking Exec func (*Repository) ExpectFind \u00b6 func ( r * Repository ) ExpectFind ( queriers ... rel . Querier ) * MockFind ExpectFind apply mocks and expectations for Find func (*Repository) ExpectFindAll \u00b6 func ( r * Repository ) ExpectFindAll ( queriers ... rel . Querier ) * MockFindAll ExpectFindAll apply mocks and expectations for FindAll func (*Repository) ExpectFindAndCountAll \u00b6 func ( r * Repository ) ExpectFindAndCountAll ( queriers ... rel . Querier ) * MockFindAndCountAll ExpectFindAndCountAll apply mocks and expectations for FindAndCountAll func (*Repository) ExpectInsert \u00b6 func ( r * Repository ) ExpectInsert ( mutators ... rel . Mutator ) * MockMutate ExpectInsert apply mocks and expectations for Insert func (*Repository) ExpectInsertAll \u00b6 func ( r * Repository ) ExpectInsertAll () * MockInsertAll ExpectInsertAll records. func (*Repository) ExpectIterate \u00b6 func ( r * Repository ) ExpectIterate ( query rel . Query , options ... rel . IteratorOption ) * MockIterate ExpectIterate apply mocks and expectations for Iterate func (*Repository) ExpectPreload \u00b6 func ( r * Repository ) ExpectPreload ( field string , queriers ... rel . Querier ) * MockPreload ExpectPreload apply mocks and expectations for Preload func (*Repository) ExpectTransaction \u00b6 func ( r * Repository ) ExpectTransaction ( fn func ( * Repository )) ExpectTransaction declare expectation inside transaction. func (*Repository) ExpectUpdate \u00b6 func ( r * Repository ) ExpectUpdate ( mutators ... rel . Mutator ) * MockMutate ExpectUpdate apply mocks and expectations for Update func (*Repository) ExpectUpdateAny \u00b6 func ( r * Repository ) ExpectUpdateAny ( query rel . Query , mutates ... rel . Mutate ) * MockUpdateAny ExpectUpdateAny apply mocks and expectations for UpdateAny func (*Repository) Find \u00b6 func ( r * Repository ) Find ( ctx context . Context , record interface {}, queriers ... rel . Querier ) error Find provides a mock function with given fields: record, queriers func (*Repository) FindAll \u00b6 func ( r * Repository ) FindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) error FindAll provides a mock function with given fields: records, queriers func (*Repository) FindAndCountAll \u00b6 func ( r * Repository ) FindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) ( int , error ) FindAndCountAll provides a mock function with given fields: records, queriers func (*Repository) Insert \u00b6 func ( r * Repository ) Insert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Insert provides a mock function with given fields: record, mutators func (*Repository) InsertAll \u00b6 func ( r * Repository ) InsertAll ( ctx context . Context , records interface {}, mutators ... rel . Mutator ) error InsertAll records. func (*Repository) Instrumentation \u00b6 func ( r * Repository ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation provides a mock function with given fields: instrumenter func (*Repository) Iterate \u00b6 func ( r * Repository ) Iterate ( ctx context . Context , query rel . Query , options ... rel . IteratorOption ) rel . Iterator Iterate through a collection of records from database in batches. This function returns iterator that can be used to loop all records. Limit, Offset and Sort query is automatically ignored. func (*Repository) MustAggregate \u00b6 func ( r * Repository ) MustAggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) int MustAggregate provides a mock function with given fields: query, aggregate, field func (*Repository) MustCount \u00b6 func ( r * Repository ) MustCount ( ctx context . Context , collection string , queriers ... rel . Querier ) int MustCount provides a mock function with given fields: collection, queriers func (*Repository) MustDelete \u00b6 func ( r * Repository ) MustDelete ( ctx context . Context , record interface {}, options ... rel . Mutator ) MustDelete provides a mock function with given fields: record func (*Repository) MustDeleteAll \u00b6 func ( r * Repository ) MustDeleteAll ( ctx context . Context , record interface {}) MustDeleteAll provides a mock function with given fields: record func (*Repository) MustDeleteAny \u00b6 func ( r * Repository ) MustDeleteAny ( ctx context . Context , query rel . Query ) int MustDeleteAny provides a mock function with given fields: query func (*Repository) MustExec \u00b6 func ( r * Repository ) MustExec ( ctx context . Context , statement string , args ... interface {}) ( int , int ) MustExec raw statement. Returns last inserted id, rows affected and error. func (*Repository) MustFind \u00b6 func ( r * Repository ) MustFind ( ctx context . Context , record interface {}, queriers ... rel . Querier ) MustFind provides a mock function with given fields: record, queriers func (*Repository) MustFindAll \u00b6 func ( r * Repository ) MustFindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) MustFindAll provides a mock function with given fields: records, queriers func (*Repository) MustFindAndCountAll \u00b6 func ( r * Repository ) MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) int MustFindAndCountAll provides a mock function with given fields: records, queriers func (*Repository) MustInsert \u00b6 func ( r * Repository ) MustInsert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustInsert provides a mock function with given fields: record, mutators func (*Repository) MustInsertAll \u00b6 func ( r * Repository ) MustInsertAll ( ctx context . Context , records interface {}, mutators ... rel . Mutator ) MustInsertAll records. func (*Repository) MustPreload \u00b6 func ( r * Repository ) MustPreload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) MustPreload provides a mock function with given fields: records, field, queriers func (*Repository) MustUpdate \u00b6 func ( r * Repository ) MustUpdate ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustUpdate provides a mock function with given fields: record, mutators func (*Repository) MustUpdateAny \u00b6 func ( r * Repository ) MustUpdateAny ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) int MustUpdateAny provides a mock function with given fields: query func (*Repository) Ping \u00b6 func ( r * Repository ) Ping ( ctx context . Context ) error Ping database. func (*Repository) Preload \u00b6 func ( r * Repository ) Preload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) error Preload provides a mock function with given fields: records, field, queriers func (*Repository) Transaction \u00b6 func ( r * Repository ) Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error Transaction provides a mock function with given fields: fn func (*Repository) Update \u00b6 func ( r * Repository ) Update ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Update provides a mock function with given fields: record, mutators func (*Repository) UpdateAny \u00b6 func ( r * Repository ) UpdateAny ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) ( int , error ) UpdateAny provides a mock function with given fields: query type T \u00b6 type T interface { Logf ( format string , args ... interface {}) Errorf ( format string , args ... interface {}) Helper () } T is an interface wrapper around *testing.T","title":"github.com/go-rel/reltest"},{"location":"reference/reltest/#reltest","text":"import \"github.com/go-rel/reltest\"","title":"reltest"},{"location":"reference/reltest/#overview","text":"Package reltest for unit testing database interaction.","title":"Overview"},{"location":"reference/reltest/#variables","text":"var Any interface {} = any {} var ( // ErrConnectionClosed is alias for sql.ErrConnDone. ErrConnectionClosed = sql . ErrConnDone )","title":"Variables"},{"location":"reference/reltest/#type-assert","text":"type Assert struct { // contains filtered or unexported fields }","title":"type Assert"},{"location":"reference/reltest/#func-assert-many","text":"func ( a * Assert ) Many () Many set max calls to unlimited times.","title":"func (*Assert) Many"},{"location":"reference/reltest/#func-assert-maybe","text":"func ( a * Assert ) Maybe () Maybe allow calls to be skipped.","title":"func (*Assert) Maybe"},{"location":"reference/reltest/#func-assert-once","text":"func ( a * Assert ) Once () Once set max calls to one time.","title":"func (*Assert) Once"},{"location":"reference/reltest/#func-assert-times","text":"func ( a * Assert ) Times ( times int ) Times set number of allowed calls.","title":"func (*Assert) Times"},{"location":"reference/reltest/#func-assert-twice","text":"func ( a * Assert ) Twice () Twice set max calls to two times.","title":"func (*Assert) Twice"},{"location":"reference/reltest/#type-mockaggregate","text":"type MockAggregate struct { // contains filtered or unexported fields } MockAggregate asserts and simulate UpdateAny function for test.","title":"type MockAggregate"},{"location":"reference/reltest/#func-mockaggregate-connectionclosed","text":"func ( ma * MockAggregate ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockAggregate) ConnectionClosed"},{"location":"reference/reltest/#func-mockaggregate-error","text":"func ( ma * MockAggregate ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockAggregate) Error"},{"location":"reference/reltest/#func-mockaggregate-expectstring","text":"func ( ma MockAggregate ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockAggregate) ExpectString"},{"location":"reference/reltest/#func-mockaggregate-result","text":"func ( ma * MockAggregate ) Result ( count int ) * Assert Result sets the result of this query.","title":"func (*MockAggregate) Result"},{"location":"reference/reltest/#func-mockaggregate-string","text":"func ( ma MockAggregate ) String () string String representation of mocked call.","title":"func (MockAggregate) String"},{"location":"reference/reltest/#type-mockcount","text":"type MockCount struct { // contains filtered or unexported fields } MockCount asserts and simulate UpdateAny function for test.","title":"type MockCount"},{"location":"reference/reltest/#func-mockcount-connectionclosed","text":"func ( mc * MockCount ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockCount) ConnectionClosed"},{"location":"reference/reltest/#func-mockcount-error","text":"func ( mc * MockCount ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockCount) Error"},{"location":"reference/reltest/#func-mockcount-expectstring","text":"func ( mc MockCount ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockCount) ExpectString"},{"location":"reference/reltest/#func-mockcount-result","text":"func ( mc * MockCount ) Result ( count int ) * Assert Result sets the result of this query.","title":"func (*MockCount) Result"},{"location":"reference/reltest/#func-mockcount-string","text":"func ( mc MockCount ) String () string String representation of mocked call.","title":"func (MockCount) String"},{"location":"reference/reltest/#type-mockdelete","text":"type MockDelete struct { // contains filtered or unexported fields } MockDelete asserts and simulate Delete function for test.","title":"type MockDelete"},{"location":"reference/reltest/#func-mockdelete-connectionclosed","text":"func ( md * MockDelete ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockDelete) ConnectionClosed"},{"location":"reference/reltest/#func-mockdelete-error","text":"func ( md * MockDelete ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockDelete) Error"},{"location":"reference/reltest/#func-mockdelete-expectstring","text":"func ( md MockDelete ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockDelete) ExpectString"},{"location":"reference/reltest/#func-mockdelete-for","text":"func ( md * MockDelete ) For ( record interface {}) * MockDelete For assert calls for given record.","title":"func (*MockDelete) For"},{"location":"reference/reltest/#func-mockdelete-forcontains","text":"func ( md * MockDelete ) ForContains ( contains interface {}) * MockDelete ForContains assert calls to contains some value of given struct.","title":"func (*MockDelete) ForContains"},{"location":"reference/reltest/#func-mockdelete-fortable","text":"func ( md * MockDelete ) ForTable ( typ string ) * MockDelete ForTable assert calls for given table.","title":"func (*MockDelete) ForTable"},{"location":"reference/reltest/#func-mockdelete-fortype","text":"func ( md * MockDelete ) ForType ( typ string ) * MockDelete ForType assert calls for given type. Type must include package name, example: model.User .","title":"func (*MockDelete) ForType"},{"location":"reference/reltest/#func-mockdelete-string","text":"func ( md MockDelete ) String () string String representation of mocked call.","title":"func (MockDelete) String"},{"location":"reference/reltest/#func-mockdelete-success","text":"func ( md * MockDelete ) Success () * Assert Success sets no error to be returned.","title":"func (*MockDelete) Success"},{"location":"reference/reltest/#type-mockdeleteall","text":"type MockDeleteAll struct { // contains filtered or unexported fields } MockDeleteAll asserts and simulate Delete function for test.","title":"type MockDeleteAll"},{"location":"reference/reltest/#func-mockdeleteall-connectionclosed","text":"func ( mda * MockDeleteAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockDeleteAll) ConnectionClosed"},{"location":"reference/reltest/#func-mockdeleteall-error","text":"func ( mda * MockDeleteAll ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockDeleteAll) Error"},{"location":"reference/reltest/#func-mockdeleteall-expectstring","text":"func ( mda MockDeleteAll ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockDeleteAll) ExpectString"},{"location":"reference/reltest/#func-mockdeleteall-for","text":"func ( mda * MockDeleteAll ) For ( record interface {}) * MockDeleteAll For assert calls for given record.","title":"func (*MockDeleteAll) For"},{"location":"reference/reltest/#func-mockdeleteall-fortable","text":"func ( mda * MockDeleteAll ) ForTable ( typ string ) * MockDeleteAll ForTable assert calls for given table.","title":"func (*MockDeleteAll) ForTable"},{"location":"reference/reltest/#func-mockdeleteall-fortype","text":"func ( mda * MockDeleteAll ) ForType ( typ string ) * MockDeleteAll ForType assert calls for given type. Type must include package name, example: model.User .","title":"func (*MockDeleteAll) ForType"},{"location":"reference/reltest/#func-mockdeleteall-string","text":"func ( mda MockDeleteAll ) String () string String representation of mocked call.","title":"func (MockDeleteAll) String"},{"location":"reference/reltest/#func-mockdeleteall-success","text":"func ( mda * MockDeleteAll ) Success () * Assert Success sets no error to be returned.","title":"func (*MockDeleteAll) Success"},{"location":"reference/reltest/#type-mockdeleteany","text":"type MockDeleteAny struct { // contains filtered or unexported fields } MockDeleteAny asserts and simulate DeleteAny function for test.","title":"type MockDeleteAny"},{"location":"reference/reltest/#func-mockdeleteany-connectionclosed","text":"func ( mda * MockDeleteAny ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockDeleteAny) ConnectionClosed"},{"location":"reference/reltest/#func-mockdeleteany-deletedcount","text":"func ( mda * MockDeleteAny ) DeletedCount ( deletedCount int ) * Assert DeletedCount set the returned deleted count of this function.","title":"func (*MockDeleteAny) DeletedCount"},{"location":"reference/reltest/#func-mockdeleteany-error","text":"func ( mda * MockDeleteAny ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockDeleteAny) Error"},{"location":"reference/reltest/#func-mockdeleteany-expectstring","text":"func ( mda MockDeleteAny ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockDeleteAny) ExpectString"},{"location":"reference/reltest/#func-mockdeleteany-string","text":"func ( mda MockDeleteAny ) String () string String representation of mocked call.","title":"func (MockDeleteAny) String"},{"location":"reference/reltest/#func-mockdeleteany-success","text":"func ( mda * MockDeleteAny ) Success () * Assert Success sets no error to be returned.","title":"func (*MockDeleteAny) Success"},{"location":"reference/reltest/#func-mockdeleteany-unsafe","text":"func ( mda * MockDeleteAny ) Unsafe () * MockDeleteAny Unsafe allows for unsafe operation to delete records without where condition.","title":"func (*MockDeleteAny) Unsafe"},{"location":"reference/reltest/#type-mockexec","text":"type MockExec struct { // contains filtered or unexported fields } MockExec asserts and simulate UpdateAny function for test.","title":"type MockExec"},{"location":"reference/reltest/#func-mockexec-connectionclosed","text":"func ( me * MockExec ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockExec) ConnectionClosed"},{"location":"reference/reltest/#func-mockexec-error","text":"func ( me * MockExec ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockExec) Error"},{"location":"reference/reltest/#func-mockexec-expectstring","text":"func ( me MockExec ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockExec) ExpectString"},{"location":"reference/reltest/#func-mockexec-result","text":"func ( me * MockExec ) Result ( lastInsertedId int , rowsAffected int ) * Assert Result sets the result of this query.","title":"func (*MockExec) Result"},{"location":"reference/reltest/#func-mockexec-string","text":"func ( me MockExec ) String () string String representation of mocked call.","title":"func (MockExec) String"},{"location":"reference/reltest/#type-mockfind","text":"type MockFind struct { // contains filtered or unexported fields } MockFind asserts and simulate find function for test.","title":"type MockFind"},{"location":"reference/reltest/#func-mockfind-connectionclosed","text":"func ( mf * MockFind ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockFind) ConnectionClosed"},{"location":"reference/reltest/#func-mockfind-error","text":"func ( mf * MockFind ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockFind) Error"},{"location":"reference/reltest/#func-mockfind-expectstring","text":"func ( mf MockFind ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockFind) ExpectString"},{"location":"reference/reltest/#func-mockfind-notfound","text":"func ( mf * MockFind ) NotFound () * Assert NotFound sets NotFoundError to be returned.","title":"func (*MockFind) NotFound"},{"location":"reference/reltest/#func-mockfind-result","text":"func ( mf * MockFind ) Result ( result interface {}) * Assert Result sets the result of this query.","title":"func (*MockFind) Result"},{"location":"reference/reltest/#func-mockfind-string","text":"func ( mf MockFind ) String () string String representation of mocked call.","title":"func (MockFind) String"},{"location":"reference/reltest/#type-mockfindall","text":"type MockFindAll struct { // contains filtered or unexported fields } MockFindAll asserts and simulate find all function for test.","title":"type MockFindAll"},{"location":"reference/reltest/#func-mockfindall-connectionclosed","text":"func ( mfa * MockFindAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockFindAll) ConnectionClosed"},{"location":"reference/reltest/#func-mockfindall-error","text":"func ( mfa * MockFindAll ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockFindAll) Error"},{"location":"reference/reltest/#func-mockfindall-expectstring","text":"func ( mfa MockFindAll ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockFindAll) ExpectString"},{"location":"reference/reltest/#func-mockfindall-result","text":"func ( mfa * MockFindAll ) Result ( result interface {}) * Assert Result sets the result of this query.","title":"func (*MockFindAll) Result"},{"location":"reference/reltest/#func-mockfindall-string","text":"func ( mfa MockFindAll ) String () string String representation of mocked call.","title":"func (MockFindAll) String"},{"location":"reference/reltest/#type-mockfindandcountall","text":"type MockFindAndCountAll struct { // contains filtered or unexported fields } MockFindAndCountAll asserts and simulate find and count all function for test.","title":"type MockFindAndCountAll"},{"location":"reference/reltest/#func-mockfindandcountall-connectionclosed","text":"func ( mfca * MockFindAndCountAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockFindAndCountAll) ConnectionClosed"},{"location":"reference/reltest/#func-mockfindandcountall-error","text":"func ( mfca * MockFindAndCountAll ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockFindAndCountAll) Error"},{"location":"reference/reltest/#func-mockfindandcountall-expectstring","text":"func ( mfca MockFindAndCountAll ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockFindAndCountAll) ExpectString"},{"location":"reference/reltest/#func-mockfindandcountall-result","text":"func ( mfca * MockFindAndCountAll ) Result ( result interface {}, count int ) * Assert Result sets the result of this query.","title":"func (*MockFindAndCountAll) Result"},{"location":"reference/reltest/#func-mockfindandcountall-string","text":"func ( mfca MockFindAndCountAll ) String () string String representation of mocked call.","title":"func (MockFindAndCountAll) String"},{"location":"reference/reltest/#type-mockinsertall","text":"type MockInsertAll struct { // contains filtered or unexported fields } MockInsertAll asserts and simulate Insert function for test.","title":"type MockInsertAll"},{"location":"reference/reltest/#func-mockinsertall-connectionclosed","text":"func ( mia * MockInsertAll ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockInsertAll) ConnectionClosed"},{"location":"reference/reltest/#func-mockinsertall-error","text":"func ( mia * MockInsertAll ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockInsertAll) Error"},{"location":"reference/reltest/#func-mockinsertall-expectstring","text":"func ( mia MockInsertAll ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockInsertAll) ExpectString"},{"location":"reference/reltest/#func-mockinsertall-for","text":"func ( mia * MockInsertAll ) For ( record interface {}) * MockInsertAll For assert calls for given record.","title":"func (*MockInsertAll) For"},{"location":"reference/reltest/#func-mockinsertall-fortable","text":"func ( mia * MockInsertAll ) ForTable ( typ string ) * MockInsertAll ForTable assert calls for given table.","title":"func (*MockInsertAll) ForTable"},{"location":"reference/reltest/#func-mockinsertall-fortype","text":"func ( mia * MockInsertAll ) ForType ( typ string ) * MockInsertAll ForType assert calls for given type. Type must include package name, example: model.User .","title":"func (*MockInsertAll) ForType"},{"location":"reference/reltest/#func-mockinsertall-notunique","text":"func ( mia * MockInsertAll ) NotUnique ( key string ) * Assert NotUnique sets not unique error to be returned.","title":"func (*MockInsertAll) NotUnique"},{"location":"reference/reltest/#func-mockinsertall-string","text":"func ( mia MockInsertAll ) String () string String representation of mocked call.","title":"func (MockInsertAll) String"},{"location":"reference/reltest/#func-mockinsertall-success","text":"func ( mia * MockInsertAll ) Success () * Assert Success sets no error to be returned.","title":"func (*MockInsertAll) Success"},{"location":"reference/reltest/#type-mockiterate","text":"type MockIterate struct { // contains filtered or unexported fields } MockIterate asserts and simulate Delete function for test.","title":"type MockIterate"},{"location":"reference/reltest/#func-mockiterate-close","text":"func ( mi MockIterate ) Close () error","title":"func (MockIterate) Close"},{"location":"reference/reltest/#func-mockiterate-connectionclosed","text":"func ( mi * MockIterate ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockIterate) ConnectionClosed"},{"location":"reference/reltest/#func-mockiterate-error","text":"func ( mi * MockIterate ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockIterate) Error"},{"location":"reference/reltest/#func-mockiterate-expectstring","text":"func ( mi MockIterate ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockIterate) ExpectString"},{"location":"reference/reltest/#func-mockiterate-next","text":"func ( mi * MockIterate ) Next ( record interface {}) error","title":"func (*MockIterate) Next"},{"location":"reference/reltest/#func-mockiterate-result","text":"func ( mi * MockIterate ) Result ( result interface {}) * Assert Result sets the result of preload.","title":"func (*MockIterate) Result"},{"location":"reference/reltest/#func-mockiterate-string","text":"func ( mi MockIterate ) String () string String representation of mocked call.","title":"func (MockIterate) String"},{"location":"reference/reltest/#type-mockmutate","text":"type MockMutate struct { // contains filtered or unexported fields } MockMutate asserts and simulate Insert function for test.","title":"type MockMutate"},{"location":"reference/reltest/#func-mockmutate-connectionclosed","text":"func ( mm * MockMutate ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockMutate) ConnectionClosed"},{"location":"reference/reltest/#func-mockmutate-error","text":"func ( mm * MockMutate ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockMutate) Error"},{"location":"reference/reltest/#func-mockmutate-expectstring","text":"func ( mm MockMutate ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockMutate) ExpectString"},{"location":"reference/reltest/#func-mockmutate-for","text":"func ( mm * MockMutate ) For ( record interface {}) * MockMutate For assert calls for given record.","title":"func (*MockMutate) For"},{"location":"reference/reltest/#func-mockmutate-forcontains","text":"func ( mm * MockMutate ) ForContains ( contains interface {}) * MockMutate ForContains assert calls to contains some value of given struct.","title":"func (*MockMutate) ForContains"},{"location":"reference/reltest/#func-mockmutate-fortable","text":"func ( mm * MockMutate ) ForTable ( typ string ) * MockMutate ForTable assert calls for given table.","title":"func (*MockMutate) ForTable"},{"location":"reference/reltest/#func-mockmutate-fortype","text":"func ( mm * MockMutate ) ForType ( typ string ) * MockMutate ForType assert calls for given type. Type must include package name, example: model.User .","title":"func (*MockMutate) ForType"},{"location":"reference/reltest/#func-mockmutate-notunique","text":"func ( mm * MockMutate ) NotUnique ( key string ) * Assert NotUnique sets not unique error to be returned.","title":"func (*MockMutate) NotUnique"},{"location":"reference/reltest/#func-mockmutate-string","text":"func ( mm MockMutate ) String () string String representation of mocked call.","title":"func (MockMutate) String"},{"location":"reference/reltest/#func-mockmutate-success","text":"func ( mm * MockMutate ) Success () * Assert Success sets no error to be returned.","title":"func (*MockMutate) Success"},{"location":"reference/reltest/#type-mockpreload","text":"type MockPreload struct { // contains filtered or unexported fields } MockPreload asserts and simulate Delete function for test.","title":"type MockPreload"},{"location":"reference/reltest/#func-mockpreload-connectionclosed","text":"func ( mp * MockPreload ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockPreload) ConnectionClosed"},{"location":"reference/reltest/#func-mockpreload-error","text":"func ( mp * MockPreload ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockPreload) Error"},{"location":"reference/reltest/#func-mockpreload-expectstring","text":"func ( mp MockPreload ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockPreload) ExpectString"},{"location":"reference/reltest/#func-mockpreload-for","text":"func ( md * MockPreload ) For ( records interface {}) * MockPreload For assert calls for given record.","title":"func (*MockPreload) For"},{"location":"reference/reltest/#func-mockpreload-fortype","text":"func ( md * MockPreload ) ForType ( typ string ) * MockPreload ForType assert calls for given type. Type must include package name, example: model.User .","title":"func (*MockPreload) ForType"},{"location":"reference/reltest/#func-mockpreload-result","text":"func ( mp * MockPreload ) Result ( result interface {}) * Assert Result sets the result of preload.","title":"func (*MockPreload) Result"},{"location":"reference/reltest/#func-mockpreload-string","text":"func ( mp MockPreload ) String () string String representation of mocked call.","title":"func (MockPreload) String"},{"location":"reference/reltest/#type-mockupdateany","text":"type MockUpdateAny struct { // contains filtered or unexported fields } MockUpdateAny asserts and simulate UpdateAny function for test.","title":"type MockUpdateAny"},{"location":"reference/reltest/#func-mockupdateany-connectionclosed","text":"func ( mua * MockUpdateAny ) ConnectionClosed () * Assert ConnectionClosed sets this error to be returned.","title":"func (*MockUpdateAny) ConnectionClosed"},{"location":"reference/reltest/#func-mockupdateany-error","text":"func ( mua * MockUpdateAny ) Error ( err error ) * Assert Error sets error to be returned.","title":"func (*MockUpdateAny) Error"},{"location":"reference/reltest/#func-mockupdateany-expectstring","text":"func ( mua MockUpdateAny ) ExpectString () string ExpectString representation of mocked call.","title":"func (MockUpdateAny) ExpectString"},{"location":"reference/reltest/#func-mockupdateany-string","text":"func ( mua MockUpdateAny ) String () string String representation of mocked call.","title":"func (MockUpdateAny) String"},{"location":"reference/reltest/#func-mockupdateany-unsafe","text":"func ( mua * MockUpdateAny ) Unsafe () * MockUpdateAny Unsafe allows for unsafe operation to delete records without where condition.","title":"func (*MockUpdateAny) Unsafe"},{"location":"reference/reltest/#func-mockupdateany-updatedcount","text":"func ( mua * MockUpdateAny ) UpdatedCount ( updatedCount int ) * Assert UpdatedCount set the returned deleted count of this function.","title":"func (*MockUpdateAny) UpdatedCount"},{"location":"reference/reltest/#type-repository","text":"type Repository struct { // contains filtered or unexported fields } Repository is an autogenerated mock type for the Repository type","title":"type Repository"},{"location":"reference/reltest/#func-new","text":"func New () * Repository New test repository.","title":"func New"},{"location":"reference/reltest/#func-repository-adapter","text":"func ( r * Repository ) Adapter ( ctx context . Context ) rel . Adapter Adapter provides a mock function with given fields:","title":"func (*Repository) Adapter"},{"location":"reference/reltest/#func-repository-aggregate","text":"func ( r * Repository ) Aggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) ( int , error ) Aggregate provides a mock function with given fields: query, aggregate, field","title":"func (*Repository) Aggregate"},{"location":"reference/reltest/#func-repository-assertexpectations","text":"func ( r * Repository ) AssertExpectations ( t T ) bool AssertExpectations asserts that everything was in fact called as expected. Calls may have occurred in any order.","title":"func (*Repository) AssertExpectations"},{"location":"reference/reltest/#func-repository-count","text":"func ( r * Repository ) Count ( ctx context . Context , collection string , queriers ... rel . Querier ) ( int , error ) Count provides a mock function with given fields: collection, queriers","title":"func (*Repository) Count"},{"location":"reference/reltest/#func-repository-delete","text":"func ( r * Repository ) Delete ( ctx context . Context , record interface {}, options ... rel . Mutator ) error Delete provides a mock function with given fields: record","title":"func (*Repository) Delete"},{"location":"reference/reltest/#func-repository-deleteall","text":"func ( r * Repository ) DeleteAll ( ctx context . Context , records interface {}) error DeleteAll provides DeleteAll mock function with given fields: records","title":"func (*Repository) DeleteAll"},{"location":"reference/reltest/#func-repository-deleteany","text":"func ( r * Repository ) DeleteAny ( ctx context . Context , query rel . Query ) ( int , error ) DeleteAny provides a mock function with given fields: query","title":"func (*Repository) DeleteAny"},{"location":"reference/reltest/#func-repository-exec","text":"func ( r * Repository ) Exec ( ctx context . Context , statement string , args ... interface {}) ( int , int , error ) Exec raw statement. Returns last inserted id, rows affected and error.","title":"func (*Repository) Exec"},{"location":"reference/reltest/#func-repository-expectaggregate","text":"func ( r * Repository ) ExpectAggregate ( query rel . Query , aggregate string , field string ) * MockAggregate ExpectAggregate apply mocks and expectations for Aggregate","title":"func (*Repository) ExpectAggregate"},{"location":"reference/reltest/#func-repository-expectcount","text":"func ( r * Repository ) ExpectCount ( collection string , queriers ... rel . Querier ) * MockCount ExpectCount apply mocks and expectations for Count","title":"func (*Repository) ExpectCount"},{"location":"reference/reltest/#func-repository-expectdelete","text":"func ( r * Repository ) ExpectDelete ( options ... rel . Mutator ) * MockDelete ExpectDelete apply mocks and expectations for Delete","title":"func (*Repository) ExpectDelete"},{"location":"reference/reltest/#func-repository-expectdeleteall","text":"func ( r * Repository ) ExpectDeleteAll () * MockDeleteAll ExpectDeleteAll apply mocks and expectations for DeleteAll","title":"func (*Repository) ExpectDeleteAll"},{"location":"reference/reltest/#func-repository-expectdeleteany","text":"func ( r * Repository ) ExpectDeleteAny ( query rel . Query ) * MockDeleteAny ExpectDeleteAny apply mocks and expectations for DeleteAny","title":"func (*Repository) ExpectDeleteAny"},{"location":"reference/reltest/#func-repository-expectexec","text":"func ( r * Repository ) ExpectExec ( statement string , args ... interface {}) * MockExec ExpectExec for mocking Exec","title":"func (*Repository) ExpectExec"},{"location":"reference/reltest/#func-repository-expectfind","text":"func ( r * Repository ) ExpectFind ( queriers ... rel . Querier ) * MockFind ExpectFind apply mocks and expectations for Find","title":"func (*Repository) ExpectFind"},{"location":"reference/reltest/#func-repository-expectfindall","text":"func ( r * Repository ) ExpectFindAll ( queriers ... rel . Querier ) * MockFindAll ExpectFindAll apply mocks and expectations for FindAll","title":"func (*Repository) ExpectFindAll"},{"location":"reference/reltest/#func-repository-expectfindandcountall","text":"func ( r * Repository ) ExpectFindAndCountAll ( queriers ... rel . Querier ) * MockFindAndCountAll ExpectFindAndCountAll apply mocks and expectations for FindAndCountAll","title":"func (*Repository) ExpectFindAndCountAll"},{"location":"reference/reltest/#func-repository-expectinsert","text":"func ( r * Repository ) ExpectInsert ( mutators ... rel . Mutator ) * MockMutate ExpectInsert apply mocks and expectations for Insert","title":"func (*Repository) ExpectInsert"},{"location":"reference/reltest/#func-repository-expectinsertall","text":"func ( r * Repository ) ExpectInsertAll () * MockInsertAll ExpectInsertAll records.","title":"func (*Repository) ExpectInsertAll"},{"location":"reference/reltest/#func-repository-expectiterate","text":"func ( r * Repository ) ExpectIterate ( query rel . Query , options ... rel . IteratorOption ) * MockIterate ExpectIterate apply mocks and expectations for Iterate","title":"func (*Repository) ExpectIterate"},{"location":"reference/reltest/#func-repository-expectpreload","text":"func ( r * Repository ) ExpectPreload ( field string , queriers ... rel . Querier ) * MockPreload ExpectPreload apply mocks and expectations for Preload","title":"func (*Repository) ExpectPreload"},{"location":"reference/reltest/#func-repository-expecttransaction","text":"func ( r * Repository ) ExpectTransaction ( fn func ( * Repository )) ExpectTransaction declare expectation inside transaction.","title":"func (*Repository) ExpectTransaction"},{"location":"reference/reltest/#func-repository-expectupdate","text":"func ( r * Repository ) ExpectUpdate ( mutators ... rel . Mutator ) * MockMutate ExpectUpdate apply mocks and expectations for Update","title":"func (*Repository) ExpectUpdate"},{"location":"reference/reltest/#func-repository-expectupdateany","text":"func ( r * Repository ) ExpectUpdateAny ( query rel . Query , mutates ... rel . Mutate ) * MockUpdateAny ExpectUpdateAny apply mocks and expectations for UpdateAny","title":"func (*Repository) ExpectUpdateAny"},{"location":"reference/reltest/#func-repository-find","text":"func ( r * Repository ) Find ( ctx context . Context , record interface {}, queriers ... rel . Querier ) error Find provides a mock function with given fields: record, queriers","title":"func (*Repository) Find"},{"location":"reference/reltest/#func-repository-findall","text":"func ( r * Repository ) FindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) error FindAll provides a mock function with given fields: records, queriers","title":"func (*Repository) FindAll"},{"location":"reference/reltest/#func-repository-findandcountall","text":"func ( r * Repository ) FindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) ( int , error ) FindAndCountAll provides a mock function with given fields: records, queriers","title":"func (*Repository) FindAndCountAll"},{"location":"reference/reltest/#func-repository-insert","text":"func ( r * Repository ) Insert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Insert provides a mock function with given fields: record, mutators","title":"func (*Repository) Insert"},{"location":"reference/reltest/#func-repository-insertall","text":"func ( r * Repository ) InsertAll ( ctx context . Context , records interface {}, mutators ... rel . Mutator ) error InsertAll records.","title":"func (*Repository) InsertAll"},{"location":"reference/reltest/#func-repository-instrumentation","text":"func ( r * Repository ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation provides a mock function with given fields: instrumenter","title":"func (*Repository) Instrumentation"},{"location":"reference/reltest/#func-repository-iterate","text":"func ( r * Repository ) Iterate ( ctx context . Context , query rel . Query , options ... rel . IteratorOption ) rel . Iterator Iterate through a collection of records from database in batches. This function returns iterator that can be used to loop all records. Limit, Offset and Sort query is automatically ignored.","title":"func (*Repository) Iterate"},{"location":"reference/reltest/#func-repository-mustaggregate","text":"func ( r * Repository ) MustAggregate ( ctx context . Context , query rel . Query , aggregate string , field string ) int MustAggregate provides a mock function with given fields: query, aggregate, field","title":"func (*Repository) MustAggregate"},{"location":"reference/reltest/#func-repository-mustcount","text":"func ( r * Repository ) MustCount ( ctx context . Context , collection string , queriers ... rel . Querier ) int MustCount provides a mock function with given fields: collection, queriers","title":"func (*Repository) MustCount"},{"location":"reference/reltest/#func-repository-mustdelete","text":"func ( r * Repository ) MustDelete ( ctx context . Context , record interface {}, options ... rel . Mutator ) MustDelete provides a mock function with given fields: record","title":"func (*Repository) MustDelete"},{"location":"reference/reltest/#func-repository-mustdeleteall","text":"func ( r * Repository ) MustDeleteAll ( ctx context . Context , record interface {}) MustDeleteAll provides a mock function with given fields: record","title":"func (*Repository) MustDeleteAll"},{"location":"reference/reltest/#func-repository-mustdeleteany","text":"func ( r * Repository ) MustDeleteAny ( ctx context . Context , query rel . Query ) int MustDeleteAny provides a mock function with given fields: query","title":"func (*Repository) MustDeleteAny"},{"location":"reference/reltest/#func-repository-mustexec","text":"func ( r * Repository ) MustExec ( ctx context . Context , statement string , args ... interface {}) ( int , int ) MustExec raw statement. Returns last inserted id, rows affected and error.","title":"func (*Repository) MustExec"},{"location":"reference/reltest/#func-repository-mustfind","text":"func ( r * Repository ) MustFind ( ctx context . Context , record interface {}, queriers ... rel . Querier ) MustFind provides a mock function with given fields: record, queriers","title":"func (*Repository) MustFind"},{"location":"reference/reltest/#func-repository-mustfindall","text":"func ( r * Repository ) MustFindAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) MustFindAll provides a mock function with given fields: records, queriers","title":"func (*Repository) MustFindAll"},{"location":"reference/reltest/#func-repository-mustfindandcountall","text":"func ( r * Repository ) MustFindAndCountAll ( ctx context . Context , records interface {}, queriers ... rel . Querier ) int MustFindAndCountAll provides a mock function with given fields: records, queriers","title":"func (*Repository) MustFindAndCountAll"},{"location":"reference/reltest/#func-repository-mustinsert","text":"func ( r * Repository ) MustInsert ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustInsert provides a mock function with given fields: record, mutators","title":"func (*Repository) MustInsert"},{"location":"reference/reltest/#func-repository-mustinsertall","text":"func ( r * Repository ) MustInsertAll ( ctx context . Context , records interface {}, mutators ... rel . Mutator ) MustInsertAll records.","title":"func (*Repository) MustInsertAll"},{"location":"reference/reltest/#func-repository-mustpreload","text":"func ( r * Repository ) MustPreload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) MustPreload provides a mock function with given fields: records, field, queriers","title":"func (*Repository) MustPreload"},{"location":"reference/reltest/#func-repository-mustupdate","text":"func ( r * Repository ) MustUpdate ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) MustUpdate provides a mock function with given fields: record, mutators","title":"func (*Repository) MustUpdate"},{"location":"reference/reltest/#func-repository-mustupdateany","text":"func ( r * Repository ) MustUpdateAny ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) int MustUpdateAny provides a mock function with given fields: query","title":"func (*Repository) MustUpdateAny"},{"location":"reference/reltest/#func-repository-ping","text":"func ( r * Repository ) Ping ( ctx context . Context ) error Ping database.","title":"func (*Repository) Ping"},{"location":"reference/reltest/#func-repository-preload","text":"func ( r * Repository ) Preload ( ctx context . Context , records interface {}, field string , queriers ... rel . Querier ) error Preload provides a mock function with given fields: records, field, queriers","title":"func (*Repository) Preload"},{"location":"reference/reltest/#func-repository-transaction","text":"func ( r * Repository ) Transaction ( ctx context . Context , fn func ( ctx context . Context ) error ) error Transaction provides a mock function with given fields: fn","title":"func (*Repository) Transaction"},{"location":"reference/reltest/#func-repository-update","text":"func ( r * Repository ) Update ( ctx context . Context , record interface {}, mutators ... rel . Mutator ) error Update provides a mock function with given fields: record, mutators","title":"func (*Repository) Update"},{"location":"reference/reltest/#func-repository-updateany","text":"func ( r * Repository ) UpdateAny ( ctx context . Context , query rel . Query , mutates ... rel . Mutate ) ( int , error ) UpdateAny provides a mock function with given fields: query","title":"func (*Repository) UpdateAny"},{"location":"reference/reltest/#type-t","text":"type T interface { Logf ( format string , args ... interface {}) Errorf ( format string , args ... interface {}) Helper () } T is an interface wrapper around *testing.T","title":"type T"},{"location":"reference/sort/","text":"sort \u00b6 import \"github.com/go-rel/rel/sort\" Overview \u00b6 Package sort is syntatic sugar for building sort query. Variables \u00b6 var ( // Asc creates a query that sort the result ascending by specified field. Asc = rel . NewSortAsc // Desc creates a query that sort the result descending by specified field. Desc = rel . NewSortDesc )","title":"github.com/go-rel/rel/sort"},{"location":"reference/sort/#sort","text":"import \"github.com/go-rel/rel/sort\"","title":"sort"},{"location":"reference/sort/#overview","text":"Package sort is syntatic sugar for building sort query.","title":"Overview"},{"location":"reference/sort/#variables","text":"var ( // Asc creates a query that sort the result ascending by specified field. Asc = rel . NewSortAsc // Desc creates a query that sort the result descending by specified field. Desc = rel . NewSortDesc )","title":"Variables"},{"location":"reference/where/","text":"where \u00b6 import \"github.com/go-rel/rel/where\" Overview \u00b6 Package where is syntatic sugar for building where query. Variables \u00b6 var ( // And compares other filters using and. And = rel . And // Or compares other filters using or. Or = rel . Or // Not wraps filters using not. // It'll negate the filter type if possible. Not = rel . Not // Eq expression field equal to value. Eq = rel . Eq // Ne compares that left value is not equal to right value. Ne = rel . Ne // Lt compares that left value is less than to right value. Lt = rel . Lt // Lte compares that left value is less than or equal to right value. Lte = rel . Lte // Gt compares that left value is greater than to right value. Gt = rel . Gt // Gte compares that left value is greater than or equal to right value. Gte = rel . Gte // Nil check whether field is nil. Nil = rel . Nil // NotNil check whether field is not nil. NotNil = rel . NotNil // In check whethers value of the field is included in values. In = rel . In // InInt check whethers integer value of the field is included in values. InInt = rel . InInt // InUint check whethers unsigned integer value of the field is included in values. InUint = rel . InUint // InString check whethers string value of the field is included in values. InString = rel . InString // Nin check whethers value of the field is not included in values. Nin = rel . Nin // NinInt check whethers integer value of the field is not included in values. NinInt = rel . NinInt // NinUint check whethers unsigned integer value of the field is not included in values. NinUint = rel . NinUint // NinString check whethers string value of the field is not included in values. NinString = rel . NinString // Like compares value of field to match string pattern. Like = rel . Like // NotLike compares value of field to not match string pattern. NotLike = rel . NotLike // Fragment add custom filter. Fragment = rel . FilterFragment )","title":"github.com/go-rel/rel/where"},{"location":"reference/where/#where","text":"import \"github.com/go-rel/rel/where\"","title":"where"},{"location":"reference/where/#overview","text":"Package where is syntatic sugar for building where query.","title":"Overview"},{"location":"reference/where/#variables","text":"var ( // And compares other filters using and. And = rel . And // Or compares other filters using or. Or = rel . Or // Not wraps filters using not. // It'll negate the filter type if possible. Not = rel . Not // Eq expression field equal to value. Eq = rel . Eq // Ne compares that left value is not equal to right value. Ne = rel . Ne // Lt compares that left value is less than to right value. Lt = rel . Lt // Lte compares that left value is less than or equal to right value. Lte = rel . Lte // Gt compares that left value is greater than to right value. Gt = rel . Gt // Gte compares that left value is greater than or equal to right value. Gte = rel . Gte // Nil check whether field is nil. Nil = rel . Nil // NotNil check whether field is not nil. NotNil = rel . NotNil // In check whethers value of the field is included in values. In = rel . In // InInt check whethers integer value of the field is included in values. InInt = rel . InInt // InUint check whethers unsigned integer value of the field is included in values. InUint = rel . InUint // InString check whethers string value of the field is included in values. InString = rel . InString // Nin check whethers value of the field is not included in values. Nin = rel . Nin // NinInt check whethers integer value of the field is not included in values. NinInt = rel . NinInt // NinUint check whethers unsigned integer value of the field is not included in values. NinUint = rel . NinUint // NinString check whethers string value of the field is not included in values. NinString = rel . NinString // Like compares value of field to match string pattern. Like = rel . Like // NotLike compares value of field to not match string pattern. NotLike = rel . NotLike // Fragment add custom filter. Fragment = rel . FilterFragment )","title":"Variables"}]}