{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"adapters/","text":"Adapters \u00b6 Rel uses adapter in order to generate and execute query to a database, below is the list of available adapters currently supported. Adapter Package Godoc MySQL github.com/go-rel/mysql PostgreSQL github.com/go-rel/postgres MSSQL github.com/go-rel/mssql SQLite3 github.com/go-rel/sqlite3 Using Primary Replica Connections \u00b6 REL Read Write separation for primary replica connections by using intermediary adapters. package main import ( \"context\" _ \"github.com/go-sql-driver/mysql\" \"github.com/go-rel/primaryreplica\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" ) func main () { // open mysql connections. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter := primaryreplica . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica1:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica2:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), ) defer adapter . Close () // initialize REL's repo. repo := rel . New ( adapter ) repo . Ping ( context . TODO ()) } Load Balancing of Replicas \u00b6 REL only implements a very primitive load balancing for multiple replicas. For large scale application we recommend you to use external load balancing solution.","title":"Adapters"},{"location":"adapters/#adapters","text":"Rel uses adapter in order to generate and execute query to a database, below is the list of available adapters currently supported. Adapter Package Godoc MySQL github.com/go-rel/mysql PostgreSQL github.com/go-rel/postgres MSSQL github.com/go-rel/mssql SQLite3 github.com/go-rel/sqlite3","title":"Adapters"},{"location":"adapters/#using-primary-replica-connections","text":"REL Read Write separation for primary replica connections by using intermediary adapters. package main import ( \"context\" _ \"github.com/go-sql-driver/mysql\" \"github.com/go-rel/primaryreplica\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" ) func main () { // open mysql connections. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter := primaryreplica . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica1:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), mysql . MustOpen ( \"root@(replica2:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" ), ) defer adapter . Close () // initialize REL's repo. repo := rel . New ( adapter ) repo . Ping ( context . TODO ()) }","title":"Using Primary Replica Connections"},{"location":"adapters/#load-balancing-of-replicas","text":"REL only implements a very primitive load balancing for multiple replicas. For large scale application we recommend you to use external load balancing solution.","title":"Load Balancing of Replicas"},{"location":"association/","text":"Association \u00b6 Defining Association \u00b6 Association in REL can be declared by ensuring that each association have an association field, reference id field and foreign id field. Association field is a field with the type of another struct. Reference id is an id field that can be mapped to the foreign id field in another struct. By following that convention, REL currently supports belongs to , has one and has many association. // User schema. type User struct { ID int Name string Age int CreatedAt time . Time UpdatedAt time . Time // has many transactions. // with custom reference and foreign field declaration. // ref: id refers to User.ID field. // fk: buyer_id refers to Transaction.BuyerID Transactions [] Transaction `ref:\"id\" fk:\"buyer_id\"` // has one address. // doesn't contains primary key of other struct. // REL can guess the reference and foreign field if it's not specified. // autosave tag tells rel to automatically save the association when the parent is inserted/updated/deleted. // autoload tag tells rel to automatically load the association when record is queried. // alternatively you can use auto to enable both autoload and autosave. Address Address `autosave:\"true\" autoload:\"true\"` } // Transaction schema. type Transaction struct { ID int Item string Status string // belongs to user. // contains primary key of other struct. Buyer User `ref:\"buyer_id\" fk:\"id\"` BuyerID int } // Address schema. type Address struct { ID int City string // belongs to user. User * User UserID * int } Preloading Association \u00b6 Preload will load association to structs. To preload association, use Preload . Preload Transaction's Buyer ( belongs to association): Example err := repo . Preload ( ctx , & transaction , \"buyer\" ) Mock user := User { ID : 1 , Name : \"Nabe\" } repo . ExpectPreload ( \"buyer\" ). Result ( user ) Preload User's Address ( has one association): Example err := repo . Preload ( ctx , & user , \"address\" ) Mock address := Address { ID : 1 , City : \"Nazarick\" } repo . ExpectPreload ( \"address\" ). Result ( address ) Preload User's Transactions ( has many association): Example err := repo . Preload ( ctx , & user , \"transactions\" ) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" ). Result ( transactions ) Preload only paid Transactions from users: Example err := repo . Preload ( ctx , & user , \"transactions\" , where . Eq ( \"status\" , \"paid\" )) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" , where . Eq ( \"status\" , \"paid\" )). Result ( transactions ) Preload every Buyer's Address in Transactions (Buyer needs to be preloaded before preloading Buyer's Address): Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Preload also support slice, preload multiple transactions at once: Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Joining Association \u00b6 Beside manually joining table using Join query, REL can also detect which field to join by using JoinAssoc method. It's also possible to load the result of joined table for has many and belongs to association by specifying it in the Select query. Query Transaction with Buyer ( belongs to association): Example // Select \"buyer.*\" field tell REL to load the joined table to result as well. err := repo . FindAll ( ctx , & transactions , rel . Select ( \"*\" , \"buyer.*\" ). JoinAssoc ( \"buyer\" )) Mock transactions := [] Transaction {{ ID : 1 , BuyerID : 2 , Buyer : User { ID : 2 , Name : \"Nabe\" }}} repo . ExpectFindAll ( rel . Select ( \"*\" , \"buyer.*\" ). JoinAssoc ( \"buyer\" )). Result ( transactions ) Inserting and Updating Association \u00b6 REL can automatically modifies association when it's parent is modified. If ID of association struct is not a zero value, REL will try to update the association, else it'll create a new association. Note Autosave feature needs to be explicitly enabled by adding ( autosave:\"true\" ) tag to the struct definition. Example: see User.Address struct. Example user := User { Name : \"rel\" , Address : Address { City : \"Bandung\" , }, } // Inserts a new record to users and address table. // Result: User{ID: 1, Name: \"rel\", Address: Address{ID: 1, City: \"Bandung\", UserID: 1}} err := repo . Insert ( ctx , & user ) Mock repo . ExpectInsert (). ForType ( \"main.User\" ) REL will try to update a new record for association if ID is a zero value. To update association, it first needs to be preloaded. Example userID := 1 user := User { ID : 1 , Name : \"rel\" , // association is loaded when the primary key (id) is not zero. Address : Address { ID : 1 , UserID : & userID , City : \"Bandung\" , }, } // Update user record with id 1. // Update address record with id 1. err := repo . Update ( ctx , & user ) Mock repo . ExpectUpdate (). ForType ( \"main.User\" ) To selectively update only specific fields or association, use rel.Map . Example mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record if it's loaded else it'll creates a new address. // only set city to bandung. err := repo . Update ( ctx , & user , mutation ) Mock mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record with id 1, only set city to bandung. repo . ExpectUpdate ( mutation ). ForType ( \"main.User\" ) Auto Saving and Loading Association \u00b6 REL supports automatic loading or saving of association in structs by specifying the following struct tags: autosave=\"true\" : Enables automatic saving of the association whenever parent is inserted/updated/deleted. autoload=\"true\" : Enables automatic preloading of the association whenever parent is queried. auto=\"true\" : Shorthand for enabling both autosave=\"true\" and autoload=\"true\" .","title":"Association"},{"location":"association/#association","text":"","title":"Association"},{"location":"association/#defining-association","text":"Association in REL can be declared by ensuring that each association have an association field, reference id field and foreign id field. Association field is a field with the type of another struct. Reference id is an id field that can be mapped to the foreign id field in another struct. By following that convention, REL currently supports belongs to , has one and has many association. // User schema. type User struct { ID int Name string Age int CreatedAt time . Time UpdatedAt time . Time // has many transactions. // with custom reference and foreign field declaration. // ref: id refers to User.ID field. // fk: buyer_id refers to Transaction.BuyerID Transactions [] Transaction `ref:\"id\" fk:\"buyer_id\"` // has one address. // doesn't contains primary key of other struct. // REL can guess the reference and foreign field if it's not specified. // autosave tag tells rel to automatically save the association when the parent is inserted/updated/deleted. // autoload tag tells rel to automatically load the association when record is queried. // alternatively you can use auto to enable both autoload and autosave. Address Address `autosave:\"true\" autoload:\"true\"` } // Transaction schema. type Transaction struct { ID int Item string Status string // belongs to user. // contains primary key of other struct. Buyer User `ref:\"buyer_id\" fk:\"id\"` BuyerID int } // Address schema. type Address struct { ID int City string // belongs to user. User * User UserID * int }","title":"Defining Association"},{"location":"association/#preloading-association","text":"Preload will load association to structs. To preload association, use Preload . Preload Transaction's Buyer ( belongs to association): Example err := repo . Preload ( ctx , & transaction , \"buyer\" ) Mock user := User { ID : 1 , Name : \"Nabe\" } repo . ExpectPreload ( \"buyer\" ). Result ( user ) Preload User's Address ( has one association): Example err := repo . Preload ( ctx , & user , \"address\" ) Mock address := Address { ID : 1 , City : \"Nazarick\" } repo . ExpectPreload ( \"address\" ). Result ( address ) Preload User's Transactions ( has many association): Example err := repo . Preload ( ctx , & user , \"transactions\" ) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" ). Result ( transactions ) Preload only paid Transactions from users: Example err := repo . Preload ( ctx , & user , \"transactions\" , where . Eq ( \"status\" , \"paid\" )) Mock transactions := [] Transaction { { ID : 1 , Item : \"Avarice and Generosity\" , Status : \"paid\" }, } repo . ExpectPreload ( \"transactions\" , where . Eq ( \"status\" , \"paid\" )). Result ( transactions ) Preload every Buyer's Address in Transactions (Buyer needs to be preloaded before preloading Buyer's Address): Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses ) Preload also support slice, preload multiple transactions at once: Example err := repo . Preload ( ctx , & transaction , \"buyer.address\" ) Mock userID := 1 addresses := [] Address {{ ID : 1 , City : \"Nazarick\" , UserID : & userID }} repo . ExpectPreload ( \"buyer.address\" ). Result ( addresses )","title":"Preloading Association"},{"location":"association/#joining-association","text":"Beside manually joining table using Join query, REL can also detect which field to join by using JoinAssoc method. It's also possible to load the result of joined table for has many and belongs to association by specifying it in the Select query. Query Transaction with Buyer ( belongs to association): Example // Select \"buyer.*\" field tell REL to load the joined table to result as well. err := repo . FindAll ( ctx , & transactions , rel . Select ( \"*\" , \"buyer.*\" ). JoinAssoc ( \"buyer\" )) Mock transactions := [] Transaction {{ ID : 1 , BuyerID : 2 , Buyer : User { ID : 2 , Name : \"Nabe\" }}} repo . ExpectFindAll ( rel . Select ( \"*\" , \"buyer.*\" ). JoinAssoc ( \"buyer\" )). Result ( transactions )","title":"Joining Association"},{"location":"association/#inserting-and-updating-association","text":"REL can automatically modifies association when it's parent is modified. If ID of association struct is not a zero value, REL will try to update the association, else it'll create a new association. Note Autosave feature needs to be explicitly enabled by adding ( autosave:\"true\" ) tag to the struct definition. Example: see User.Address struct. Example user := User { Name : \"rel\" , Address : Address { City : \"Bandung\" , }, } // Inserts a new record to users and address table. // Result: User{ID: 1, Name: \"rel\", Address: Address{ID: 1, City: \"Bandung\", UserID: 1}} err := repo . Insert ( ctx , & user ) Mock repo . ExpectInsert (). ForType ( \"main.User\" ) REL will try to update a new record for association if ID is a zero value. To update association, it first needs to be preloaded. Example userID := 1 user := User { ID : 1 , Name : \"rel\" , // association is loaded when the primary key (id) is not zero. Address : Address { ID : 1 , UserID : & userID , City : \"Bandung\" , }, } // Update user record with id 1. // Update address record with id 1. err := repo . Update ( ctx , & user ) Mock repo . ExpectUpdate (). ForType ( \"main.User\" ) To selectively update only specific fields or association, use rel.Map . Example mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record if it's loaded else it'll creates a new address. // only set city to bandung. err := repo . Update ( ctx , & user , mutation ) Mock mutation := rel . Map { \"address\" : rel . Map { \"city\" : \"bandung\" , }, } // Update address record with id 1, only set city to bandung. repo . ExpectUpdate ( mutation ). ForType ( \"main.User\" )","title":"Inserting and Updating Association"},{"location":"association/#auto-saving-and-loading-association","text":"REL supports automatic loading or saving of association in structs by specifying the following struct tags: autosave=\"true\" : Enables automatic saving of the association whenever parent is inserted/updated/deleted. autoload=\"true\" : Enables automatic preloading of the association whenever parent is queried. auto=\"true\" : Shorthand for enabling both autosave=\"true\" and autoload=\"true\" .","title":"Auto Saving and Loading Association"},{"location":"basics/","text":"Basics \u00b6 Full Example \u00b6 Below is a very basic example on how to utilize REL using mysql adapter. Testing database query using REL can be done using reltest package. main.go package main import ( \"context\" \"time\" \"github.com/go-rel/postgres\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" _ \"github.com/lib/pq\" ) // Author is a model that maps to authors table. type Author struct { ID int Name string } // Book is a model that maps to books table. type Book struct { ID int Title string Category string Price int Discount bool Stock int AuthorID int Author Author Publisher string CreatedAt time . Time UpdatedAt time . Time } var dsn = \"postgres://postgres@localhost/rel_test?sslmode=disable\" func main () { // initialize postgres adapter. adapter , _ := postgres . Open ( dsn ) defer adapter . Close () // initialize rel's repo. repo := rel . New ( adapter ) // run Example ( context . Background (), repo ) } // Example is an actual service function that run a complex business package. // beware: it's actually doing nonsense here. func Example ( ctx context . Context , repo rel . Repository ) error { var book Book // Quickly find a book with id 1 using short alias. if err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )); err != nil { return err } // Or use chainable query builder. query := rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 ) if err := repo . Find ( ctx , & book , query ); err != nil { return err } // Convenient method to preload Book's Author. if err := repo . Preload ( ctx , & book , \"author\" ); err != nil { return err } // Performs updates inside a transaction. return repo . Transaction ( ctx , func ( ctx context . Context ) error { // basic update using struct. book . Title = \"REL for dummies\" repo . MustUpdate ( ctx , & book ) // update only specific fields. repo . MustUpdate ( ctx , & book , rel . Set ( \"discount\" , false )) // it even supports atomic inc/dec mutation. return repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) }) } main_test.go package main import ( \"context\" \"testing\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" \"github.com/go-rel/reltest\" \"github.com/stretchr/testify/assert\" ) func TestExample ( t * testing . T ) { // create a mocked repository. var ( repo = reltest . New () book = Book { ID : 1 , Title : \"Go for dummies\" , Category : \"learning\" , AuthorID : 1 , } author = Author { ID : 1 , Name : \"CZ2I28 Delta\" } ) // mock find and return result repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) // mock find and return result using query builder. repo . ExpectFind ( rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 )). Result ( book ) // mock preload and return result repo . ExpectPreload ( \"author\" ). ForType ( \"main.Book\" ). Result ( author ) // mocks transaction repo . ExpectTransaction ( func ( repo * reltest . Repository ) { // mock updates repo . ExpectUpdate (). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"discount\" , false )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) }) // run and asserts assert . Nil ( t , Example ( context . Background (), repo )) repo . AssertExpectations ( t ) } Other Examples \u00b6 gin-example - Todo Backend using Gin and REL go-todo-backend - Todo Backend using Chi and REL iris-example - Todo Backend using Iris and REL Conventions \u00b6 Schema Definition \u00b6 REL uses a struct as the schema to infer table name , columns and primary field . // Table name: books type Book struct { ID int // id Title string // title Category string // category CreatedAt time . Time // created_at UpdatedAt time . Time // updated_at } Table Name \u00b6 Table name will be the pluralized struct name in snake case, you may create a Table() string method to override the default table name. // Default table name is `books` type Book struct {} // Override table name to be `ebooks` func ( b Book ) Table () string { return \"ebooks\" } Column Name \u00b6 Column name will be the struct field name in snake case, you may override the column name by using db tag. type Book struct { ID int // this field will be mapped to `id` column. Title string `db:\"name\"` // this field will be mapped to `name` column. Category string `db:\"-\"` // this field will be skipped } Primary Key \u00b6 REL requires every struct to have at least primary key. by default field named id will be used as primary key. To use other field as primary key, you may define it as primary using db tag. Defining multiple field as primary will forms composite primary key. type Book struct { UUID string `db:\"uuid,primary\"` // or just `db:\",primary\"` } Timestamp \u00b6 REL automatically track created and updated time of each struct if CreatedAt or UpdatedAt field exists. Embedded structs \u00b6 REL supports embedding structs and struct pointers. By default, fields of embedded structs have no column name prefix. A prefix can be set with the db tag type Model struct { ID int Owner int } type Book struct { Model `db:\"model_\"` // id and owner will mapped to model_id and model_owner Title string }","title":"Basics"},{"location":"basics/#basics","text":"","title":"Basics"},{"location":"basics/#full-example","text":"Below is a very basic example on how to utilize REL using mysql adapter. Testing database query using REL can be done using reltest package. main.go package main import ( \"context\" \"time\" \"github.com/go-rel/postgres\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" _ \"github.com/lib/pq\" ) // Author is a model that maps to authors table. type Author struct { ID int Name string } // Book is a model that maps to books table. type Book struct { ID int Title string Category string Price int Discount bool Stock int AuthorID int Author Author Publisher string CreatedAt time . Time UpdatedAt time . Time } var dsn = \"postgres://postgres@localhost/rel_test?sslmode=disable\" func main () { // initialize postgres adapter. adapter , _ := postgres . Open ( dsn ) defer adapter . Close () // initialize rel's repo. repo := rel . New ( adapter ) // run Example ( context . Background (), repo ) } // Example is an actual service function that run a complex business package. // beware: it's actually doing nonsense here. func Example ( ctx context . Context , repo rel . Repository ) error { var book Book // Quickly find a book with id 1 using short alias. if err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )); err != nil { return err } // Or use chainable query builder. query := rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 ) if err := repo . Find ( ctx , & book , query ); err != nil { return err } // Convenient method to preload Book's Author. if err := repo . Preload ( ctx , & book , \"author\" ); err != nil { return err } // Performs updates inside a transaction. return repo . Transaction ( ctx , func ( ctx context . Context ) error { // basic update using struct. book . Title = \"REL for dummies\" repo . MustUpdate ( ctx , & book ) // update only specific fields. repo . MustUpdate ( ctx , & book , rel . Set ( \"discount\" , false )) // it even supports atomic inc/dec mutation. return repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) }) } main_test.go package main import ( \"context\" \"testing\" \"github.com/go-rel/rel\" \"github.com/go-rel/rel/where\" \"github.com/go-rel/reltest\" \"github.com/stretchr/testify/assert\" ) func TestExample ( t * testing . T ) { // create a mocked repository. var ( repo = reltest . New () book = Book { ID : 1 , Title : \"Go for dummies\" , Category : \"learning\" , AuthorID : 1 , } author = Author { ID : 1 , Name : \"CZ2I28 Delta\" } ) // mock find and return result repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) // mock find and return result using query builder. repo . ExpectFind ( rel . Select (). Where ( where . Eq ( \"id\" , 1 )). Limit ( 1 )). Result ( book ) // mock preload and return result repo . ExpectPreload ( \"author\" ). ForType ( \"main.Book\" ). Result ( author ) // mocks transaction repo . ExpectTransaction ( func ( repo * reltest . Repository ) { // mock updates repo . ExpectUpdate (). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Set ( \"discount\" , false )). ForType ( \"main.Book\" ) repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) }) // run and asserts assert . Nil ( t , Example ( context . Background (), repo )) repo . AssertExpectations ( t ) }","title":"Full Example"},{"location":"basics/#other-examples","text":"gin-example - Todo Backend using Gin and REL go-todo-backend - Todo Backend using Chi and REL iris-example - Todo Backend using Iris and REL","title":"Other Examples"},{"location":"basics/#conventions","text":"","title":"Conventions"},{"location":"basics/#schema-definition","text":"REL uses a struct as the schema to infer table name , columns and primary field . // Table name: books type Book struct { ID int // id Title string // title Category string // category CreatedAt time . Time // created_at UpdatedAt time . Time // updated_at }","title":"Schema Definition"},{"location":"basics/#table-name","text":"Table name will be the pluralized struct name in snake case, you may create a Table() string method to override the default table name. // Default table name is `books` type Book struct {} // Override table name to be `ebooks` func ( b Book ) Table () string { return \"ebooks\" }","title":"Table Name"},{"location":"basics/#column-name","text":"Column name will be the struct field name in snake case, you may override the column name by using db tag. type Book struct { ID int // this field will be mapped to `id` column. Title string `db:\"name\"` // this field will be mapped to `name` column. Category string `db:\"-\"` // this field will be skipped }","title":"Column Name"},{"location":"basics/#primary-key","text":"REL requires every struct to have at least primary key. by default field named id will be used as primary key. To use other field as primary key, you may define it as primary using db tag. Defining multiple field as primary will forms composite primary key. type Book struct { UUID string `db:\"uuid,primary\"` // or just `db:\",primary\"` }","title":"Primary Key"},{"location":"basics/#timestamp","text":"REL automatically track created and updated time of each struct if CreatedAt or UpdatedAt field exists.","title":"Timestamp"},{"location":"basics/#embedded-structs","text":"REL supports embedding structs and struct pointers. By default, fields of embedded structs have no column name prefix. A prefix can be set with the db tag type Model struct { ID int Owner int } type Book struct { Model `db:\"model_\"` // id and owner will mapped to model_id and model_owner Title string }","title":"Embedded structs"},{"location":"crud/","text":"Reading and Writing Record \u00b6 Create \u00b6 A new record can be inserted to database using a struct, map or set function. To insert a new record using a struct, simply pass the pointer to the instance as the only argment. Insertion using struct will update created_at and updated_at field if any. Note reltest.Repository will automatically sets any primary key value to be 1. Inserting a record: Example book := Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, } // Insert directly using struct. err := repo . Insert ( ctx , & book ) Mock Any repo . ExpectInsert () Mock by Record repo . ExpectInsert (). For ( & Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, }) Mock by Type repo . ExpectInsert (). ForType ( \"main.Book\" ) Mock Error repo . ExpectInsert (). ForType ( \"main.Book\" ). Error ( errors . New ( \"oops\" )) To inserts multiple records at once, use InsertAll : Example books := [] Book { { Title : \"Golang for dummies\" , Category : \"education\" , }, { Title : \"Rel for dummies\" , Category : \"education\" , }, } err := repo . InsertAll ( ctx , & books ) Mock repo . ExpectInsertAll (). ForType ( \"[]main.Book\" ) Read \u00b6 REL provides a powerful API for querying record from database. To query a record, simply use the Find method, it accepts the returned result as the first argument, and the conditions for the rest arguments. Retrieve a book with id 1: Example var book Book err := repo . Find ( ctx , & book , rel . Eq ( \"id\" , 1 )) Mock book := Book { Title : \"Rel for dummies\" , Category : \"education\" , } repo . ExpectFind ( rel . Eq ( \"id\" , 1 )). Result ( book ) Retrieve a book with id 1 using syntactic sugar: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock repo . ExpectFind ( where . Eq ( \"id\" , 1 )). NotFound () Querying multiple records using FindAll method: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } repo . ExpectFindAll ( where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ). Result ( books ) Using chainable query api for a more complex query use case: Example var books [] Book query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) err := repo . FindAll ( ctx , & books , query ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) repo . ExpectFindAll ( query ). Result ( books ) Update \u00b6 Similar to create, updating a record in REL can also be done using struct, map or set function. Updating using struct will also update updated_at field if any. An update using struct will cause all fields and association to be saved to database, regardless of whether it's been updated or not. Use rel.Map , rel.Set or rel.Changeset to update only specific fields. Note When updating belongs to association, it's recommended to not expose reference key ( [other]_id ) for updates directly from user, since there's no way to validate belongs to association using query. Updating a record: Example book . Title = \"REL for dummies\" err := repo . Update ( ctx , & book ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Updating records is custom query: Example updatedCount , err := repo . UpdateAny ( ctx , rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Mock repo . ExpectUpdateAny ( rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Delete \u00b6 To delete a record in rel, simply pass the record to be deleted. Note REL will automatically apply soft-delete if DeletedAt *time.Time or Deleted bool field exists in a struct. DeletedAt needs to be pointer, otherwise it won't be able to save or store null value. To query soft-deleted records, use rel.Unscoped(true) when querying. Deleting a record: Example err := repo . Delete ( ctx , & book ) Mock repo . ExpectDelete (). For ( & book ) Deleting multiple record: Example err := repo . DeleteAll ( ctx , & books ) Mock repo . ExpectDeleteAll (). For ( & books ) Deleting records using custom query: Example deletedCount , err := repo . DeleteAny ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 ))) Mock repo . ExpectDeleteAny ( rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 )))","title":"Reading and Writing Record"},{"location":"crud/#reading-and-writing-record","text":"","title":"Reading and Writing Record"},{"location":"crud/#create","text":"A new record can be inserted to database using a struct, map or set function. To insert a new record using a struct, simply pass the pointer to the instance as the only argment. Insertion using struct will update created_at and updated_at field if any. Note reltest.Repository will automatically sets any primary key value to be 1. Inserting a record: Example book := Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, } // Insert directly using struct. err := repo . Insert ( ctx , & book ) Mock Any repo . ExpectInsert () Mock by Record repo . ExpectInsert (). For ( & Book { Title : \"Rel for dummies\" , Category : \"education\" , Author : Author { Name : \"CZ2I28 Delta\" , }, }) Mock by Type repo . ExpectInsert (). ForType ( \"main.Book\" ) Mock Error repo . ExpectInsert (). ForType ( \"main.Book\" ). Error ( errors . New ( \"oops\" )) To inserts multiple records at once, use InsertAll : Example books := [] Book { { Title : \"Golang for dummies\" , Category : \"education\" , }, { Title : \"Rel for dummies\" , Category : \"education\" , }, } err := repo . InsertAll ( ctx , & books ) Mock repo . ExpectInsertAll (). ForType ( \"[]main.Book\" )","title":"Create"},{"location":"crud/#read","text":"REL provides a powerful API for querying record from database. To query a record, simply use the Find method, it accepts the returned result as the first argument, and the conditions for the rest arguments. Retrieve a book with id 1: Example var book Book err := repo . Find ( ctx , & book , rel . Eq ( \"id\" , 1 )) Mock book := Book { Title : \"Rel for dummies\" , Category : \"education\" , } repo . ExpectFind ( rel . Eq ( \"id\" , 1 )). Result ( book ) Retrieve a book with id 1 using syntactic sugar: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock repo . ExpectFind ( where . Eq ( \"id\" , 1 )). NotFound () Querying multiple records using FindAll method: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } repo . ExpectFindAll ( where . Like ( \"title\" , \"%dummies%\" ). AndEq ( \"category\" , \"education\" ), rel . Limit ( 10 ), ). Result ( books ) Using chainable query api for a more complex query use case: Example var books [] Book query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) err := repo . FindAll ( ctx , & books , query ) Mock books := [] Book { { Title : \"Rel for dummies\" , Category : \"education\" , }, } query := rel . Select ( \"title\" , \"category\" ). Where ( where . Eq ( \"category\" , \"education\" )). SortAsc ( \"title\" ) repo . ExpectFindAll ( query ). Result ( books )","title":"Read"},{"location":"crud/#update","text":"Similar to create, updating a record in REL can also be done using struct, map or set function. Updating using struct will also update updated_at field if any. An update using struct will cause all fields and association to be saved to database, regardless of whether it's been updated or not. Use rel.Map , rel.Set or rel.Changeset to update only specific fields. Note When updating belongs to association, it's recommended to not expose reference key ( [other]_id ) for updates directly from user, since there's no way to validate belongs to association using query. Updating a record: Example book . Title = \"REL for dummies\" err := repo . Update ( ctx , & book ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Updating records is custom query: Example updatedCount , err := repo . UpdateAny ( ctx , rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true )) Mock repo . ExpectUpdateAny ( rel . From ( \"books\" ). Where ( where . Lt ( \"stock\" , 100 )), rel . Set ( \"discount\" , true ))","title":"Update"},{"location":"crud/#delete","text":"To delete a record in rel, simply pass the record to be deleted. Note REL will automatically apply soft-delete if DeletedAt *time.Time or Deleted bool field exists in a struct. DeletedAt needs to be pointer, otherwise it won't be able to save or store null value. To query soft-deleted records, use rel.Unscoped(true) when querying. Deleting a record: Example err := repo . Delete ( ctx , & book ) Mock repo . ExpectDelete (). For ( & book ) Deleting multiple record: Example err := repo . DeleteAll ( ctx , & books ) Mock repo . ExpectDeleteAll (). For ( & books ) Deleting records using custom query: Example deletedCount , err := repo . DeleteAny ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 ))) Mock repo . ExpectDeleteAny ( rel . From ( \"books\" ). Where ( where . Eq ( \"id\" , 1 )))","title":"Delete"},{"location":"instrumentation/","text":"Instrumentation \u00b6 REL provides hooks that can be used to log or instrument your queries. repo . Instrumentation ( func ( ctx context . Context , op string , message string , args ... any ) func ( err error ) { t := time . Now () return func ( err error ) { duration := time . Since ( t ) log . Print ( \"[duration: \" , duration , \" op: \" , op , \"] \" , message , \" - \" , err ) } }) This is the list for available operations: rel-aggregate rel-count rel-find rel-find-all rel-find-and-count-all rel-scan-one rel-scan-all rel-scan-multi rel-insert rel-insert-all rel-update rel-delete rel-delete-any rel-preload rel-transaction adapter-aggregate adapter-query adapter-exec adapter-begin adapter-commit adapter-rollback","title":"Instrumentation"},{"location":"instrumentation/#instrumentation","text":"REL provides hooks that can be used to log or instrument your queries. repo . Instrumentation ( func ( ctx context . Context , op string , message string , args ... any ) func ( err error ) { t := time . Now () return func ( err error ) { duration := time . Since ( t ) log . Print ( \"[duration: \" , duration , \" op: \" , op , \"] \" , message , \" - \" , err ) } }) This is the list for available operations: rel-aggregate rel-count rel-find rel-find-all rel-find-and-count-all rel-scan-one rel-scan-all rel-scan-multi rel-insert rel-insert-all rel-update rel-delete rel-delete-any rel-preload rel-transaction adapter-aggregate adapter-query adapter-exec adapter-begin adapter-commit adapter-rollback","title":"Instrumentation"},{"location":"introduction/","text":"Introduction \u00b6 REL is golang orm-ish database layer for layered architecture. It's testable and comes with it's own test library. REL also features extendable query builder that allows you to write query using builder or plain sql. Features \u00b6 Testable repository with builtin reltest package. Seamless nested transactions. Elegant, yet extendable query builder with mix of syntactic sugar. Supports Eager loading. Composite Primary Key. Multi adapter. Soft Deletion. Pagination. Schema Migration. Install \u00b6 go get github.com/go-rel/rel Why rel \u00b6 Easy to test \u00b6 Most (if not all) orm for golang is written as a chainable API, meaning all of the query need to be called before performing actual action as a chain of method invocations. example: db . Where ( \"id = ?\" , 1 ). First ( & user ) Chainable api is very hard to be unit tested without writing a wrapper. One way to make it testable is to make an interface that also acts as a wrapper, which is usually ends up as its own repository package resides somewhere in your project: // mockable interface. type UserRepository interface { Find ( user * User , id int ) error } // actual implementation type userRepository struct { db * DB } func ( ur userRepository ) Find ( user * User , id int ) error { return db . Where ( \"id = ?\" , 1 ). First ( & user ) } Compared to other orm, REL api is built with testability in mind. REL uses interface to define contract of every database query or execution, all while making a chainable query possible. The ultimate goal of REL is to be your database package without the needs of making your own wrapper. Seamless transactions \u00b6 When starting a transaction using builtin database/sql package or other orm, special transaction instance that's similar to non-transaction instance is returned, and all execution needs to be called using that instance to be in transaction: // start transaction tx := db . Begin () // do some database operations in the transaction (use 'tx' from this point, not 'db') tx . Create ( ... ) // Or commit the transaction tx . Commit () Now what happens if you want to introduce a shared function, that might execute it's operation on a transaction or on a regular connection depending on the caller? you may end up with a function that may not only accepts conventional context argument, but also a tx or connection argument. tx := db . Begin () tx . Create ( ... ) // UpdateOtherEntity(txOrDb TxOrDbInterface, ...) UpdateOtherEntity ( tx , ... ) tx . Commit () REL attempts to solve that problem by managing transaction state using context, the REL repository can decide whether to use transaction or not based on provided context, performs commit or rollback in case of exception, and even supports nested transaction (see: transactions ).","title":"Introduction"},{"location":"introduction/#introduction","text":"REL is golang orm-ish database layer for layered architecture. It's testable and comes with it's own test library. REL also features extendable query builder that allows you to write query using builder or plain sql.","title":"Introduction"},{"location":"introduction/#features","text":"Testable repository with builtin reltest package. Seamless nested transactions. Elegant, yet extendable query builder with mix of syntactic sugar. Supports Eager loading. Composite Primary Key. Multi adapter. Soft Deletion. Pagination. Schema Migration.","title":"Features"},{"location":"introduction/#install","text":"go get github.com/go-rel/rel","title":"Install"},{"location":"introduction/#why-rel","text":"","title":"Why rel"},{"location":"introduction/#easy-to-test","text":"Most (if not all) orm for golang is written as a chainable API, meaning all of the query need to be called before performing actual action as a chain of method invocations. example: db . Where ( \"id = ?\" , 1 ). First ( & user ) Chainable api is very hard to be unit tested without writing a wrapper. One way to make it testable is to make an interface that also acts as a wrapper, which is usually ends up as its own repository package resides somewhere in your project: // mockable interface. type UserRepository interface { Find ( user * User , id int ) error } // actual implementation type userRepository struct { db * DB } func ( ur userRepository ) Find ( user * User , id int ) error { return db . Where ( \"id = ?\" , 1 ). First ( & user ) } Compared to other orm, REL api is built with testability in mind. REL uses interface to define contract of every database query or execution, all while making a chainable query possible. The ultimate goal of REL is to be your database package without the needs of making your own wrapper.","title":"Easy to test"},{"location":"introduction/#seamless-transactions","text":"When starting a transaction using builtin database/sql package or other orm, special transaction instance that's similar to non-transaction instance is returned, and all execution needs to be called using that instance to be in transaction: // start transaction tx := db . Begin () // do some database operations in the transaction (use 'tx' from this point, not 'db') tx . Create ( ... ) // Or commit the transaction tx . Commit () Now what happens if you want to introduce a shared function, that might execute it's operation on a transaction or on a regular connection depending on the caller? you may end up with a function that may not only accepts conventional context argument, but also a tx or connection argument. tx := db . Begin () tx . Create ( ... ) // UpdateOtherEntity(txOrDb TxOrDbInterface, ...) UpdateOtherEntity ( tx , ... ) tx . Commit () REL attempts to solve that problem by managing transaction state using context, the REL repository can decide whether to use transaction or not based on provided context, performs commit or rollback in case of exception, and even supports nested transaction (see: transactions ).","title":"Seamless transactions"},{"location":"migration/","text":"Migration \u00b6 Overview \u00b6 Migration is a feature that allows you to evolve your database schema over time, REL provides DSL that allows you to write migration in Golang. Defining Migration \u00b6 Migration package usually located inside your-repo/db/migrations package. It's a standalone package that should not be imported by the rest of your application. Each migration file is named as number_name.go , and each migration file must define a pair of migration and rollback functions: MigrateName and RollbackName . Migrate and rollback function name is the camel cased file name without version. Note Sample project that demonstrate this setup can be found at go-rel/gin-example // 20202806225100_create_todos.go package migrations import ( \"context\" \"github.com/go-rel/rel\" ) // MigrateCreateTodos definition func MigrateCreateTodos ( schema * rel . Schema ) { schema . CreateTable ( \"todos\" , func ( t * rel . Table ) { t . ID ( \"id\" ) t . DateTime ( \"created_at\" ) t . DateTime ( \"updated_at\" ) t . String ( \"title\" ) t . Bool ( \"completed\" ) t . Int ( \"order\" ) }) schema . CreateIndex ( \"todos\" , \"order\" , [] string { \"order\" }) schema . Do ( func ( ctx context . Context , repo rel . Repository ) error { // add seeds return repo . Insert ( ctx , & Todo { Title : \"Do homework\" }) }) } // RollbackCreateTodos definition func RollbackCreateTodos ( schema * rel . Schema ) { schema . DropTable ( \"todos\" ) } Running Migration \u00b6 REL provides CLI that can be used to run your migration, it can be installed using homebrew , go get or downloaded from release page . Install using homebrew: brew tap go-rel/tap brew install rel Or, Install using go get: go get github.com/go-rel/cmd/rel Since Go 1.18 use go install: go install github.com/go-rel/cmd/rel@latest Verify installation: rel -version Migrate to the latest version: rel migrate Rollback one migration step: rel rollback Configuring Database Connection \u00b6 By default, REL will try to use database connection info that available as environment variable. Variable Description DATABASE_URL Database connection string (Optional) DATABASE_ADAPTER Adapter package (Required if DATABASE_URL specified) DATABASE_DRIVER Driver package (Required if DATABASE_URL specified) MYSQL_HOST MySQL host (Optional) MYSQL_PORT MySQL port (Optional) MYSQL_DATABASE MySQL database (Required, if MYSQL_HOST specified) MYSQL_USERNAME MySQL host (Required, if MYSQL_HOST specified) MYSQL_PASSWORD MySQL host (Optional) POSTGRES_HOST PostgreSQL host (Optional) POSTGRES_PORT PostgreSQL port (Optional) POSTGRES_DATABASE PostgreSQL database (Required, if POSTGRES_HOST specified) POSTGRES_USERNAME PostgreSQL username (Required, if POSTGRES_HOST specified) POSTGRES_PASSWORD PostgreSQL password (Optional) SQLITE3_DATABASE SQLite3 database (Optional) Database connection info can also be specified using command line options: dsn , adapter and driver : rel migrate -adapter = github.com/go-rel/rel/adapter/sqlite3 -driver = github.com/mattn/go-sqlite3 -dsn = :memory: Migration API \u00b6 If you need more flexibility, migration API can be used to manually execute migrations. package main import ( \"context\" \"github.com/go-rel/doc/examples/db/migrations\" \"github.com/go-rel/migration\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" _ \"github.com/go-sql-driver/mysql\" ) func main () { var ( ctx = context . TODO () repo = rel . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" )) m = migration . New ( repo ) ) // Register migrations m . Register ( 20202806225100 , migrations . MigrateCreateTodos , migrations . RollbackCreateTodos ) // Run migrations m . Migrate ( ctx ) // OR: // m.Rollback(ctx) }","title":"Migration"},{"location":"migration/#migration","text":"","title":"Migration"},{"location":"migration/#overview","text":"Migration is a feature that allows you to evolve your database schema over time, REL provides DSL that allows you to write migration in Golang.","title":"Overview"},{"location":"migration/#defining-migration","text":"Migration package usually located inside your-repo/db/migrations package. It's a standalone package that should not be imported by the rest of your application. Each migration file is named as number_name.go , and each migration file must define a pair of migration and rollback functions: MigrateName and RollbackName . Migrate and rollback function name is the camel cased file name without version. Note Sample project that demonstrate this setup can be found at go-rel/gin-example // 20202806225100_create_todos.go package migrations import ( \"context\" \"github.com/go-rel/rel\" ) // MigrateCreateTodos definition func MigrateCreateTodos ( schema * rel . Schema ) { schema . CreateTable ( \"todos\" , func ( t * rel . Table ) { t . ID ( \"id\" ) t . DateTime ( \"created_at\" ) t . DateTime ( \"updated_at\" ) t . String ( \"title\" ) t . Bool ( \"completed\" ) t . Int ( \"order\" ) }) schema . CreateIndex ( \"todos\" , \"order\" , [] string { \"order\" }) schema . Do ( func ( ctx context . Context , repo rel . Repository ) error { // add seeds return repo . Insert ( ctx , & Todo { Title : \"Do homework\" }) }) } // RollbackCreateTodos definition func RollbackCreateTodos ( schema * rel . Schema ) { schema . DropTable ( \"todos\" ) }","title":"Defining Migration"},{"location":"migration/#running-migration","text":"REL provides CLI that can be used to run your migration, it can be installed using homebrew , go get or downloaded from release page . Install using homebrew: brew tap go-rel/tap brew install rel Or, Install using go get: go get github.com/go-rel/cmd/rel Since Go 1.18 use go install: go install github.com/go-rel/cmd/rel@latest Verify installation: rel -version Migrate to the latest version: rel migrate Rollback one migration step: rel rollback","title":"Running Migration"},{"location":"migration/#configuring-database-connection","text":"By default, REL will try to use database connection info that available as environment variable. Variable Description DATABASE_URL Database connection string (Optional) DATABASE_ADAPTER Adapter package (Required if DATABASE_URL specified) DATABASE_DRIVER Driver package (Required if DATABASE_URL specified) MYSQL_HOST MySQL host (Optional) MYSQL_PORT MySQL port (Optional) MYSQL_DATABASE MySQL database (Required, if MYSQL_HOST specified) MYSQL_USERNAME MySQL host (Required, if MYSQL_HOST specified) MYSQL_PASSWORD MySQL host (Optional) POSTGRES_HOST PostgreSQL host (Optional) POSTGRES_PORT PostgreSQL port (Optional) POSTGRES_DATABASE PostgreSQL database (Required, if POSTGRES_HOST specified) POSTGRES_USERNAME PostgreSQL username (Required, if POSTGRES_HOST specified) POSTGRES_PASSWORD PostgreSQL password (Optional) SQLITE3_DATABASE SQLite3 database (Optional) Database connection info can also be specified using command line options: dsn , adapter and driver : rel migrate -adapter = github.com/go-rel/rel/adapter/sqlite3 -driver = github.com/mattn/go-sqlite3 -dsn = :memory:","title":"Configuring Database Connection"},{"location":"migration/#migration-api","text":"If you need more flexibility, migration API can be used to manually execute migrations. package main import ( \"context\" \"github.com/go-rel/doc/examples/db/migrations\" \"github.com/go-rel/migration\" \"github.com/go-rel/mysql\" \"github.com/go-rel/rel\" _ \"github.com/go-sql-driver/mysql\" ) func main () { var ( ctx = context . TODO () repo = rel . New ( mysql . MustOpen ( \"root@(source:3306)/rel_test?charset=utf8&parseTime=True&loc=Local\" )) m = migration . New ( repo ) ) // Register migrations m . Register ( 20202806225100 , migrations . MigrateCreateTodos , migrations . RollbackCreateTodos ) // Run migrations m . Migrate ( ctx ) // OR: // m.Rollback(ctx) }","title":"Migration API"},{"location":"mutations/","text":"Mutations \u00b6 Basic Mutator \u00b6 REL uses mutator to define inserts and updates operation. Using basic mutator won't update created_at and updated_at fields. Mutator Description Dec(field string) Decrement a field value by 1 DecBy(field string, n int) Decrement a field value by n Inc(field string) Increase a field value by 1 IncBy(field string, n int) Increase a field value by n Set(field string, value interface{}) Set a value to a field SetFragment(raw string, args ...interface{}) Set a value of a field using SQL fragment Set title and category values: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ). For ( & book ) Decrement stock: Example err := repo . Update ( ctx , & book , rel . DecBy ( \"stock\" , 2 )) Mock repo . ExpectUpdate ( rel . DecBy ( \"stock\" , 2 )). For ( & book ) Update title using SQL fragment: Example err := repo . Update ( ctx , & book , rel . SetFragment ( \"title=?\" , \"REL for dummies\" )) Mock repo . ExpectUpdate ( rel . SetFragment ( \"title=?\" , \"REL for dummies\" )). For ( & book ) Structset \u00b6 Structset is a mutator that generates list of Set mutators based on a struct value. Using Structset will result in replacing the intire record in the database using provided struct, It'll always clear a has many association and re-insert it on updates if it's loaded. Changeset can be used to avoid clearing has many association on updates. Note Structset is the default mutator used when none is provided explicitly. Inserting a struct using structset mutator: Example structset := rel . NewStructset ( & book , false ) err := repo . Insert ( ctx , & book , structset ) Mock repo . ExpectInsert (). For ( & book ) Changeset \u00b6 Changeset allows you to track and update only updated values and asssociation to database. This is very efficient when dealing with a complex struct that contains a lot of fields and associations. Update only price and discount field using changeset: Example changeset := rel . NewChangeset ( & book ) book . Price = 10 if changeset . FieldChanged ( \"price\" ) { book . Discount = false } err := repo . Update ( ctx , & book , changeset ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" ) Map \u00b6 Map allows to define group of Set mutator, this is intended to be use internally and not to be exposed directly to user. Mutation defined in the map will be applied to the struct passed as the first argument. Insert/Update using map wont update created_at or updated_at field. Insert books and its author using Map : Example data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } // Insert using map. err := repo . Insert ( ctx , & book , data ) Mock data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } repo . ExpectInsert ( data ). ForType ( \"main.Book\" ) Reloading Updated Struct \u00b6 By default, only Inc , IncBy , Dec , DecBy and SetFragment will reload struct from database, Reload mutator can be used to manually trigger reload after inserts/update operations. Update title and force reload: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ). For ( & book ) Cascade Operations \u00b6 REL supports insert/update/delete record and it's associations. Disable cascade insert (default enabled): Example err := repo . Insert ( ctx , & book , rel . Cascade ( false )) Mock repo . ExpectInsert ( rel . Cascade ( false )). For ( & book ) Enable cascade delete (default disabled): Example err := repo . Delete ( ctx , & book , rel . Cascade ( true )) Mock repo . ExpectDelete ( rel . Cascade ( true )). For ( & book )","title":"Mutations"},{"location":"mutations/#mutations","text":"","title":"Mutations"},{"location":"mutations/#basic-mutator","text":"REL uses mutator to define inserts and updates operation. Using basic mutator won't update created_at and updated_at fields. Mutator Description Dec(field string) Decrement a field value by 1 DecBy(field string, n int) Decrement a field value by n Inc(field string) Increase a field value by 1 IncBy(field string, n int) Increase a field value by n Set(field string, value interface{}) Set a value to a field SetFragment(raw string, args ...interface{}) Set a value of a field using SQL fragment Set title and category values: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Set ( \"category\" , \"technology\" ), ). For ( & book ) Decrement stock: Example err := repo . Update ( ctx , & book , rel . DecBy ( \"stock\" , 2 )) Mock repo . ExpectUpdate ( rel . DecBy ( \"stock\" , 2 )). For ( & book ) Update title using SQL fragment: Example err := repo . Update ( ctx , & book , rel . SetFragment ( \"title=?\" , \"REL for dummies\" )) Mock repo . ExpectUpdate ( rel . SetFragment ( \"title=?\" , \"REL for dummies\" )). For ( & book )","title":"Basic Mutator"},{"location":"mutations/#structset","text":"Structset is a mutator that generates list of Set mutators based on a struct value. Using Structset will result in replacing the intire record in the database using provided struct, It'll always clear a has many association and re-insert it on updates if it's loaded. Changeset can be used to avoid clearing has many association on updates. Note Structset is the default mutator used when none is provided explicitly. Inserting a struct using structset mutator: Example structset := rel . NewStructset ( & book , false ) err := repo . Insert ( ctx , & book , structset ) Mock repo . ExpectInsert (). For ( & book )","title":"Structset"},{"location":"mutations/#changeset","text":"Changeset allows you to track and update only updated values and asssociation to database. This is very efficient when dealing with a complex struct that contains a lot of fields and associations. Update only price and discount field using changeset: Example changeset := rel . NewChangeset ( & book ) book . Price = 10 if changeset . FieldChanged ( \"price\" ) { book . Discount = false } err := repo . Update ( ctx , & book , changeset ) Mock repo . ExpectUpdate (). ForType ( \"main.Book\" )","title":"Changeset"},{"location":"mutations/#map","text":"Map allows to define group of Set mutator, this is intended to be use internally and not to be exposed directly to user. Mutation defined in the map will be applied to the struct passed as the first argument. Insert/Update using map wont update created_at or updated_at field. Insert books and its author using Map : Example data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } // Insert using map. err := repo . Insert ( ctx , & book , data ) Mock data := rel . Map { \"title\" : \"Rel for dummies\" , \"category\" : \"education\" , \"author\" : rel . Map { \"name\" : \"CZ2I28 Delta\" , }, } repo . ExpectInsert ( data ). ForType ( \"main.Book\" )","title":"Map"},{"location":"mutations/#reloading-updated-struct","text":"By default, only Inc , IncBy , Dec , DecBy and SetFragment will reload struct from database, Reload mutator can be used to manually trigger reload after inserts/update operations. Update title and force reload: Example err := repo . Update ( ctx , & book , rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ) Mock repo . ExpectUpdate ( rel . Set ( \"title\" , \"REL for Dummies\" ), rel . Reload ( true ), ). For ( & book )","title":"Reloading Updated Struct"},{"location":"mutations/#cascade-operations","text":"REL supports insert/update/delete record and it's associations. Disable cascade insert (default enabled): Example err := repo . Insert ( ctx , & book , rel . Cascade ( false )) Mock repo . ExpectInsert ( rel . Cascade ( false )). For ( & book ) Enable cascade delete (default disabled): Example err := repo . Delete ( ctx , & book , rel . Cascade ( true )) Mock repo . ExpectDelete ( rel . Cascade ( true )). For ( & book )","title":"Cascade Operations"},{"location":"queries/","text":"Queries \u00b6 Retrieving Data \u00b6 REL provides two basic finders method, Find for retrieving single record, and FindAll for retrieving multiple record. Note Find only accepts struct as the first argument, and always return the first result from the query. FindAll only accepts slice as the first argument, and always return all result from the query. Retrieve a book where id=1: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock book := Book { ID : 1 , Title : \"REL for dummies\" } repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) Retrieve all books: Example var books [] Book err := repo . FindAll ( ctx , & books ) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll (). Result ( books ) Conditions \u00b6 To retrieve filtered recods from database, you can use filter api to specify condition . For example, to filter all books that available, you can use rel.Eq in the query builder. Retrieve all available books using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true )). Result ( books ) Alias can be used to boost readability when dealing with short query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true )). Result ( books ) Use fragment to specify custom SQL query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Fragment ( \"available=?\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Fragment ( \"available=?\" , true )). Result ( books ) You can use rel.And or rel.Or to specify more conditions. Retrieve all available books where price is at least 100 or in discount using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using chained filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using alias ( github.com/go-rel/rel/where ): Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Subquery \u00b6 Subquery is supported in condition clause, you can pass any query to the where/having parameter. Retrieve all books that is cheaper than average book price: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))). Result ( books ) Sorting \u00b6 To retrieve records from database in a specific order, you can use the sort api. Sort books ascending by updated_at field: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . NewSortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . NewSortAsc ( \"updated_at\" )). Result ( books ) Using alias if you need more syntactic sugar: Example var books [] Book err := repo . FindAll ( ctx , & books , sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( sort . Asc ( \"updated_at\" )). Result ( books ) Combining with other query is fairly easy. Chain where and sort using query builder: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )). Result ( books ) It's also possible to use variadic arguments to combine multiple queries: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )). Result ( books ) Selecting Specific Fields \u00b6 To select specific fields, you can use Select method, this way only specificied field will be mapped to books. Note Specifying select without argument ( rel.Select() ) will automatically load all fields. This is helpful when used as query builder entry point (compared to using rel.From ), because you can let REL to infer the table name. Load only id and title: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" )). Result ( books ) Using Specific Table \u00b6 By default, REL will use pluralized-snakecase struct name as the table name. To select from specific table, you can use From method. Load from ebooks table: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . From ( \"ebooks\" )). Result ( books ) Chain the query with select: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )). Result ( books ) Limit and Offset \u00b6 To set the limit and offset of query, use Limit and Offset api. Offset will be ignored if Limit is not specified. Specify limit and offset: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Limit ( 10 ), rel . Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Limit ( 10 ), rel . Offset ( 20 )). Result ( books ) As a chainable api: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select (). Limit ( 10 ). Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select (). Limit ( 10 ). Offset ( 20 )). Result ( books ) Group \u00b6 To use group by query, you can use Group method. Retrieve count of books for every category: Example // custom struct to store the result. var results [] struct { Category string Total int } // we need to explicitly specify table name since we are using an anonymous struct. err := repo . FindAll ( ctx , & results , rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )) Mock results := [] struct { Category string Total int }{ { Category : \"education\" , Total : 100 }, } repo . ExpectFindAll ( rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )). Result ( results ) Joining Tables \u00b6 To join tables, you can use join api. Note Joining table won't automatically load the association to struct. If you want to load association on a struct, try JoinAssoc or better use preload instead. Join transaction and book table, then filter only transaction that have specified book name. This methods assumes belongs to relation, which means it'll try to join using transactions.book_id=books.id : Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))). Result ( transactions ) Specifying which column to join using JoinOn: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Syntactic sugar also available for join: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Joining table with custom join mode: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Use fragment for more complex join query: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )). Result ( transactions ) Pessimistic Locking \u00b6 REL supports pessimistic locking by using mechanism provided by the underlying database. Lock can be only used only inside transaction. Retrieve and lock a row for update: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )). Result ( book ) Retrieve and lock a row using predefined lock alias: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . ForUpdate ()) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . ForUpdate ()). Result ( book ) Retrieve and lock a row using chained query: Example var book Book err := repo . Find ( ctx , & book , rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )). Result ( book ) Aggregation \u00b6 REL provides a very basic Aggregate method which can be used to count, sum, max etc. Count all available books using aggregate: Example count , err := repo . Aggregate ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ) Mock repo . ExpectAggregate ( rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ). Result ( 5 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" ) Mock repo . ExpectCount ( \"books\" ). Result ( 7 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" , where . Eq ( \"available\" , true )) Mock repo . ExpectCount ( \"books\" , where . Eq ( \"available\" , true )). Result ( 5 ) Pagination \u00b6 REL provides a convenient FindAndCountAll methods that is useful for pagination, It's a combination of FindAll and Count method. FindAndCountAll returns count of records (ignoring limit and offset query) and an error. Retrieve all books within limit and offset and also count of all books: Example var books [] Book count , err := repo . FindAndCountAll ( ctx , & books , rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAndCountAll ( rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )). Result ( books , 12 ) Batch Iteration \u00b6 REL provides records iterator that can be use for perform batch processing of large amounts of records. Options: BatchSize - The size of batches (default 1000). Start - The primary value (ID) to start from (inclusive). Finish - The primary value (ID) to finish at (inclusive). Example var ( user User iter = repo . Iterate ( ctx , rel . From ( \"users\" ), rel . BatchSize ( 500 )) ) // make sure iterator is closed after process is finish. defer iter . Close () for { // retrieve next user. if err := iter . Next ( & user ); err != nil { if err == io . EOF { break } // handle error return err } // process user SendPromotionEmail ( & user ) } Mock users := make ([] User , 5 ) repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). Result ( users ) Mock Error repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). ConnectionClosed () Native SQL Query \u00b6 REL allows querying using native SQL query, this is especially useful when using complex query that cannot be covered with the query builder. Retrieve a book using native sql query: Example var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) err := repo . Find ( ctx , & book , sql ) Mock var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) repo . ExpectFind ( sql ). Result ( book )","title":"Queries"},{"location":"queries/#queries","text":"","title":"Queries"},{"location":"queries/#retrieving-data","text":"REL provides two basic finders method, Find for retrieving single record, and FindAll for retrieving multiple record. Note Find only accepts struct as the first argument, and always return the first result from the query. FindAll only accepts slice as the first argument, and always return all result from the query. Retrieve a book where id=1: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 )) Mock book := Book { ID : 1 , Title : \"REL for dummies\" } repo . ExpectFind ( where . Eq ( \"id\" , 1 )). Result ( book ) Retrieve all books: Example var books [] Book err := repo . FindAll ( ctx , & books ) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll (). Result ( books )","title":"Retrieving Data"},{"location":"queries/#conditions","text":"To retrieve filtered recods from database, you can use filter api to specify condition . For example, to filter all books that available, you can use rel.Eq in the query builder. Retrieve all available books using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true )). Result ( books ) Alias can be used to boost readability when dealing with short query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true )). Result ( books ) Use fragment to specify custom SQL query: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Fragment ( \"available=?\" , true )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( where . Fragment ( \"available=?\" , true )). Result ( books ) You can use rel.And or rel.Or to specify more conditions. Retrieve all available books where price is at least 100 or in discount using filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . And ( rel . Eq ( \"available\" , true ), rel . Or ( rel . Gte ( \"price\" , 100 ), rel . Eq ( \"discount\" , true )))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using chained filter query: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( rel . Eq ( \"available\" , true ). And ( rel . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books ) Retrieve all available books where price is at least 100 or in discount using alias ( github.com/go-rel/rel/where ): Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ). And ( where . Gte ( \"price\" , 100 ). OrEq ( \"discount\" , true ))). Result ( books )","title":"Conditions"},{"location":"queries/#subquery","text":"Subquery is supported in condition clause, you can pass any query to the where/having parameter. Retrieve all books that is cheaper than average book price: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , Price : 100 }, { ID : 2 , Title : \"REL for dummies\" , Price : 50 , Discount : true }, } repo . ExpectFindAll ( where . Lt ( \"price\" , rel . Select ( \"AVG(price)\" ). From ( \"books\" ))). Result ( books )","title":"Subquery"},{"location":"queries/#sorting","text":"To retrieve records from database in a specific order, you can use the sort api. Sort books ascending by updated_at field: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . NewSortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . NewSortAsc ( \"updated_at\" )). Result ( books ) Using alias if you need more syntactic sugar: Example var books [] Book err := repo . FindAll ( ctx , & books , sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( sort . Asc ( \"updated_at\" )). Result ( books ) Combining with other query is fairly easy. Chain where and sort using query builder: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( rel . Where ( where . Eq ( \"available\" , true )). SortAsc ( \"updated_at\" )). Result ( books ) It's also possible to use variadic arguments to combine multiple queries: Example var books [] Book err := repo . FindAll ( ctx , & books , where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" , UpdatedAt : time . Now ()}, } repo . ExpectFindAll ( where . Eq ( \"available\" , true ), sort . Asc ( \"updated_at\" )). Result ( books )","title":"Sorting"},{"location":"queries/#selecting-specific-fields","text":"To select specific fields, you can use Select method, this way only specificied field will be mapped to books. Note Specifying select without argument ( rel.Select() ) will automatically load all fields. This is helpful when used as query builder entry point (compared to using rel.From ), because you can let REL to infer the table name. Load only id and title: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" )). Result ( books )","title":"Selecting Specific Fields"},{"location":"queries/#using-specific-table","text":"By default, REL will use pluralized-snakecase struct name as the table name. To select from specific table, you can use From method. Load from ebooks table: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . From ( \"ebooks\" )). Result ( books ) Chain the query with select: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select ( \"id\" , \"title\" ). From ( \"ebooks\" )). Result ( books )","title":"Using Specific Table"},{"location":"queries/#limit-and-offset","text":"To set the limit and offset of query, use Limit and Offset api. Offset will be ignored if Limit is not specified. Specify limit and offset: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Limit ( 10 ), rel . Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Limit ( 10 ), rel . Offset ( 20 )). Result ( books ) As a chainable api: Example var books [] Book err := repo . FindAll ( ctx , & books , rel . Select (). Limit ( 10 ). Offset ( 20 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAll ( rel . Select (). Limit ( 10 ). Offset ( 20 )). Result ( books )","title":"Limit and Offset"},{"location":"queries/#group","text":"To use group by query, you can use Group method. Retrieve count of books for every category: Example // custom struct to store the result. var results [] struct { Category string Total int } // we need to explicitly specify table name since we are using an anonymous struct. err := repo . FindAll ( ctx , & results , rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )) Mock results := [] struct { Category string Total int }{ { Category : \"education\" , Total : 100 }, } repo . ExpectFindAll ( rel . Select ( \"category\" , \"COUNT(id) as total\" ). From ( \"books\" ). Group ( \"category\" )). Result ( results )","title":"Group"},{"location":"queries/#joining-tables","text":"To join tables, you can use join api. Note Joining table won't automatically load the association to struct. If you want to load association on a struct, try JoinAssoc or better use preload instead. Join transaction and book table, then filter only transaction that have specified book name. This methods assumes belongs to relation, which means it'll try to join using transactions.book_id=books.id : Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Join ( \"books\" ). Where ( where . Eq ( \"books.name\" , \"REL for Dummies\" ))). Result ( transactions ) Specifying which column to join using JoinOn: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinOn ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Syntactic sugar also available for join: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( join . On ( \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Joining table with custom join mode: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . JoinWith ( \"LEFT JOIN\" , \"books\" , \"transactions.book_id\" , \"books.id\" )). Result ( transactions ) Use fragment for more complex join query: Example var transactions [] Transaction err := repo . FindAll ( ctx , & transactions , rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )) Mock transactions := [] Transaction { { ID : 1 , Status : \"paid\" }, } repo . ExpectFindAll ( rel . Joinf ( \"JOIN `books` ON `transactions`.`book_id`=`books`.`id`\" )). Result ( transactions )","title":"Joining Tables"},{"location":"queries/#pessimistic-locking","text":"REL supports pessimistic locking by using mechanism provided by the underlying database. Lock can be only used only inside transaction. Retrieve and lock a row for update: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . Lock ( \"FOR UPDATE\" )). Result ( book ) Retrieve and lock a row using predefined lock alias: Example var book Book err := repo . Find ( ctx , & book , where . Eq ( \"id\" , 1 ), rel . ForUpdate ()) Mock var book Book repo . ExpectFind ( where . Eq ( \"id\" , 1 ), rel . ForUpdate ()). Result ( book ) Retrieve and lock a row using chained query: Example var book Book err := repo . Find ( ctx , & book , rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )) Mock var book Book repo . ExpectFind ( rel . Where ( where . Eq ( \"id\" , 1 )). Lock ( \"FOR UPDATE\" )). Result ( book )","title":"Pessimistic Locking"},{"location":"queries/#aggregation","text":"REL provides a very basic Aggregate method which can be used to count, sum, max etc. Count all available books using aggregate: Example count , err := repo . Aggregate ( ctx , rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ) Mock repo . ExpectAggregate ( rel . From ( \"books\" ). Where ( where . Eq ( \"available\" , true )), \"count\" , \"id\" ). Result ( 5 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" ) Mock repo . ExpectCount ( \"books\" ). Result ( 7 ) Count all available books using count: Example count , err := repo . Count ( ctx , \"books\" , where . Eq ( \"available\" , true )) Mock repo . ExpectCount ( \"books\" , where . Eq ( \"available\" , true )). Result ( 5 )","title":"Aggregation"},{"location":"queries/#pagination","text":"REL provides a convenient FindAndCountAll methods that is useful for pagination, It's a combination of FindAll and Count method. FindAndCountAll returns count of records (ignoring limit and offset query) and an error. Retrieve all books within limit and offset and also count of all books: Example var books [] Book count , err := repo . FindAndCountAll ( ctx , & books , rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )) Mock books := [] Book { { ID : 1 , Title : \"REL for dummies\" }, } repo . ExpectFindAndCountAll ( rel . Where ( where . Like ( \"title\" , \"%dummies%\" )). Limit ( 10 ). Offset ( 10 )). Result ( books , 12 )","title":"Pagination"},{"location":"queries/#batch-iteration","text":"REL provides records iterator that can be use for perform batch processing of large amounts of records. Options: BatchSize - The size of batches (default 1000). Start - The primary value (ID) to start from (inclusive). Finish - The primary value (ID) to finish at (inclusive). Example var ( user User iter = repo . Iterate ( ctx , rel . From ( \"users\" ), rel . BatchSize ( 500 )) ) // make sure iterator is closed after process is finish. defer iter . Close () for { // retrieve next user. if err := iter . Next ( & user ); err != nil { if err == io . EOF { break } // handle error return err } // process user SendPromotionEmail ( & user ) } Mock users := make ([] User , 5 ) repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). Result ( users ) Mock Error repo . ExpectIterate ( rel . From ( \"users\" ), rel . BatchSize ( 500 )). ConnectionClosed ()","title":"Batch Iteration"},{"location":"queries/#native-sql-query","text":"REL allows querying using native SQL query, this is especially useful when using complex query that cannot be covered with the query builder. Retrieve a book using native sql query: Example var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) err := repo . Find ( ctx , & book , sql ) Mock var book Book sql := rel . SQL ( \"SELECT id, title, price, orders = (SELECT COUNT(t.id) FROM [transactions] t WHERE t.book_id = b.id) FROM books b where b.id=?\" , 1 ) repo . ExpectFind ( sql ). Result ( book )","title":"Native SQL Query"},{"location":"transactions/","text":"Transactions \u00b6 To declare a transaction, use the Transaction method which can be called recursively to define nested transactions. Rel accepts a function with context.Context argument that is used to determine the transaction scope. Context makes it easier to call any function that involves db operation inside a transaction, because the scope of transaction is automatically passed by context. If any error occured within transaction, the transaction will be rolled back, and returns the error. If the error is a runtime error or panic with string argument, it'll panic after rollback. Example err := repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) // Any database calls inside other function will be using the same transaction as long as it share the same context. Process ( ctx , transaction ) // Nested transaction repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . UpdateAny ( ctx , rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , book . AuthorID )), rel . Inc ( \"popularity\" )) repo . UpdateAny ( ctx , rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , book . Publisher )), rel . Inc ( \"popularity\" )) return nil }) return repo . Update ( ctx , & transaction , rel . Set ( \"status\" , \"paid\" )) }) Mock repo . ExpectTransaction ( func ( repo * reltest . Repository ) { repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) // mock process repo . ExpectTransaction ( func ( r * reltest . Repository ) { repo . ExpectUpdateAny ( rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , 0 )), rel . Inc ( \"popularity\" )) repo . ExpectUpdateAny ( rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , \"\" )), rel . Inc ( \"popularity\" )) }) repo . ExpectUpdate ( rel . Set ( \"status\" , \"paid\" )). ForType ( \"main.Transaction\" ) })","title":"Transactions"},{"location":"transactions/#transactions","text":"To declare a transaction, use the Transaction method which can be called recursively to define nested transactions. Rel accepts a function with context.Context argument that is used to determine the transaction scope. Context makes it easier to call any function that involves db operation inside a transaction, because the scope of transaction is automatically passed by context. If any error occured within transaction, the transaction will be rolled back, and returns the error. If the error is a runtime error or panic with string argument, it'll panic after rollback. Example err := repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . Update ( ctx , & book , rel . Dec ( \"stock\" )) // Any database calls inside other function will be using the same transaction as long as it share the same context. Process ( ctx , transaction ) // Nested transaction repo . Transaction ( ctx , func ( ctx context . Context ) error { repo . UpdateAny ( ctx , rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , book . AuthorID )), rel . Inc ( \"popularity\" )) repo . UpdateAny ( ctx , rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , book . Publisher )), rel . Inc ( \"popularity\" )) return nil }) return repo . Update ( ctx , & transaction , rel . Set ( \"status\" , \"paid\" )) }) Mock repo . ExpectTransaction ( func ( repo * reltest . Repository ) { repo . ExpectUpdate ( rel . Dec ( \"stock\" )). ForType ( \"main.Book\" ) // mock process repo . ExpectTransaction ( func ( r * reltest . Repository ) { repo . ExpectUpdateAny ( rel . From ( \"authors\" ). Where ( where . Eq ( \"id\" , 0 )), rel . Inc ( \"popularity\" )) repo . ExpectUpdateAny ( rel . From ( \"publishers\" ). Where ( where . Eq ( \"name\" , \"\" )), rel . Inc ( \"popularity\" )) }) repo . ExpectUpdate ( rel . Set ( \"status\" , \"paid\" )). ForType ( \"main.Transaction\" ) })","title":"Transactions"},{"location":"changelog/release-notes/","text":"Release Notes \u00b6 v0.42.0 - March 4, 2024 \u00b6 Bump actions/checkout from 2 to 4 ( #354 ) Bump actions/setup-go from 3 to 4 ( #356 ) Bump actions/setup-go from 4 to 5 ( #359 ) Bump codecov/codecov-action from 1 to 3 ( #352 ) Bump codecov/codecov-action from 3 to 4 ( #362 ) Bump github.com/stretchr/testify from 1.8.4 to 1.9.0 ( #366 ) Bump github/codeql-action from 1 to 2 ( #355 ) Bump github/codeql-action from 2 to 3 ( #358 ) Bump goreleaser/goreleaser-action from 2 to 5 ( #353 ) Fix nested preload with duplicate ptr belongs to ( #365 ) Update dependabot.yml ( #351 ) v0.41.0 - October 28, 2023 \u00b6 Extend adapter interface with Name function ( #346 ) Fix embedded primary field ( #349 ) v0.40.0 - August 26, 2023 \u00b6 Bump github.com/stretchr/testify from 1.8.0 to 1.8.1 ( #320 ) Bump github.com/stretchr/testify from 1.8.1 to 1.8.4 ( #335 ) Fix CI ( #334 ) Fix typo in comment ( #340 ) Refactor scanMulti to only call scan once ( #339 ) Rename CreateDocument to NewDocument ( #341 ) v0.39.0 - October 23, 2022 \u00b6 Add query args to instrumentation ( #314 ) Bump github.com/subosito/gotenv from 1.4.0 to 1.4.1 ( #309 ) Extract cmd package ( #319 ) Generic type Repository wrapper ( #318 ) Replace empty interface with any ( #315 ) Set min go version to 1.15 and fix build matrix ( #316 ) Update go.mod and workflows to use go 1.19 ( #313 ) v0.38.0 - July 8, 2022 \u00b6 Changelog \u00b6 36bf6b0 Allow named structs to be embedded ( #303 ) v0.37.0 - July 3, 2022 \u00b6 Add join assoc query builder ( #298 ) Auto populate join fields ( #292 ) Bump github.com/stretchr/testify from 1.7.4 to 1.7.5 ( #297 ) Bump github.com/stretchr/testify from 1.7.5 to 1.8.0 ( #299 ) Support loading association using Join query ( #302 ) v0.36.0 - June 22, 2022 \u00b6 Add support for scanning joined assoc ( #290 ) Bump github.com/stretchr/testify from 1.7.1 to 1.7.2 ( #291 ) Bump github.com/stretchr/testify from 1.7.2 to 1.7.4 ( #294 ) Bump github.com/subosito/gotenv from 1.3.0 to 1.4.0 ( #288 ) Migration's Do takes a context as its first argument ( #295 ) v0.35.0 - May 29, 2022 \u00b6 Split big preloading-IN query into multiple queries ( #283 ) ( #285 ) v0.34.1 - May 26, 2022 \u00b6 Add Iris Example ( #282 ) Bump github.com/subosito/gotenv from 1.2.0 to 1.3.0 ( #284 ) Fix Unhandled exception in gopkg.in/yaml.v3 ( #286 ) v0.34.0 - March 25, 2022 \u00b6 Bump github.com/stretchr/testify from 1.7.0 to 1.7.1 ( #273 ) Optimistic locking ( #265 ) Refactor optimistic lock api and test ( #276 ) v0.33.1 - March 12, 2022 \u00b6 Fix dependencies ( #270 ) v0.33.0 - March 12, 2022 \u00b6 Basic support for insert with on conflict ( #269 ) Deprecate migrator package ( #267 ) v0.32.0 - February 20, 2022 \u00b6 :boom: Remove deprecated reltest package ( #266 ) Bump github.com/go-rel/reltest from 0.5.0 to 0.6.0 ( #264 ) v0.31.0 - February 15, 2022 \u00b6 Bump github.com/go-rel/reltest from 0.4.0 to 0.5.0 ( #259 ) Setup codeql analysis ( #263 ) Support embeddable structs ( #262 ) v0.30.0 - November 14, 2021 \u00b6 :boom: Remove builtin base sql adapter ( #258 ) :boom: Remove builtin mysql adapter ( #256 ) :boom: Remove builtin postgres adapter ( #255 ) :boom: Remove builtin sqlite3 adapter ( #257 ) Bump github.com/lib/pq from 1.10.3 to 1.10.4 ( #254 ) v0.29.2 - November 8, 2021 \u00b6 Fix Structset to handle uuid ([16]byte) correctly ( #253 ) v0.29.1 - November 5, 2021 \u00b6 Correctly handle nil values in arrays ( #251 ) Fix panics when array ptr is used for InsertAll and DeleteAll ( #250 ) v0.29.0 - November 5, 2021 \u00b6 Fix to find records to collection of pointer type ( #246 ) Fix typo in comments ( #248 ) Implement option to specify any column as primary key ( #247 ) Test migrator using new reltest package ( #243 ) v0.28.0 - October 29, 2021 \u00b6 Add .deepsource.toml ( #237 ) Add filter conditions for Join helpers ( #239 ) Add support for primary-replica connections ( #238 ) Replace bytes.Compare with bytes.Equal ( #236 ) v0.27.0 - October 20, 2021 \u00b6 Add option to specify addtional filters for joins ( #234 ) v0.26.1 - October 19, 2021 \u00b6 Add workflow to bump patch version ( #232 ) Bump github.com/mattn/go-sqlite3 from 1.14.8 to 1.14.9 ( #230 ) Fix find and count all for soft deleteable records ( #231 ) v0.26.0 - October 13, 2021 \u00b6 Add alternative soft delete scheme ( #225 ) Add option to define JSON datatype column ( #223 ) Add partial unique index for specs ( #221 ) Allow FilterQuery to be specified for partial indexes and unique key constraints ( #219 ) Remove Filter for key as it is not directly supported by SQL ( #220 ) v0.25.0 - September 27, 2021 \u00b6 Add deprecation notices in constructors ( #214 ) Deprecate builtin mysql package ( #211 ) Deprecate builtin sqlite3 package ( #212 ) Fix preload ptr field with custom table ( #216 ) v0.24.0 - September 25, 2021 \u00b6 Add Close() error to Adapter interface ( #209 ) Deprecate reltest ( #208 ) Fix bump-minor workflow ( #210 ) v0.23.0 - September 13, 2021 \u00b6 Deprecate NewSelect for Select ( #205 ) Deprecate NewSortAsc/Desc for SortAsc/Desc ( #204 ) Implement Map.String() ( #206 ) v0.22.0 - September 7, 2021 \u00b6 Add doc to use clientFoundRows=true to mysql adapter ( #202 ) Allow the function that returns the time to be replaced ( #201 ) Bump github.com/lib/pq from 1.10.2 to 1.10.3 ( #203 ) v0.21.0 - August 25, 2021 \u00b6 Set pointer association fields to nil if preload fails ( #197 ) Fix merge sorts query ( #195 ) Fix string of empty query ( #196 ) If the preload fails, the intermediate association fields will also remain nil ( #198 ) v0.20.0 - August 19, 2021 \u00b6 Fix Merge sort query ( #189 ) Fix deleting empty has many ( #191 ) Support stringer interface on query and mutator ( #194 ) v0.19.0 - August 14, 2021 \u00b6 Support NotFoundError is sql.ErrNoRows ( #188 ) v0.18.0 - August 7, 2021 \u00b6 Bump github.com/go-sql-driver/mysql from 1.5.0 to 1.6.0 ( #177 ) Bump github.com/lib/pq from 1.9.0 to 1.10.2 ( #178 ) Bump github.com/mattn/go-sqlite3 from 1.14.6 to 1.14.8 ( #179 ) Fix setting tag auto: true panics in reltest ( #183 ) Improve preload doc ( #180 ) Setup homebrew tap ( #181 )","title":"Release Notes"},{"location":"changelog/release-notes/#release-notes","text":"","title":"Release Notes"},{"location":"changelog/release-notes/#v0420---march-4-2024","text":"Bump actions/checkout from 2 to 4 ( #354 ) Bump actions/setup-go from 3 to 4 ( #356 ) Bump actions/setup-go from 4 to 5 ( #359 ) Bump codecov/codecov-action from 1 to 3 ( #352 ) Bump codecov/codecov-action from 3 to 4 ( #362 ) Bump github.com/stretchr/testify from 1.8.4 to 1.9.0 ( #366 ) Bump github/codeql-action from 1 to 2 ( #355 ) Bump github/codeql-action from 2 to 3 ( #358 ) Bump goreleaser/goreleaser-action from 2 to 5 ( #353 ) Fix nested preload with duplicate ptr belongs to ( #365 ) Update dependabot.yml ( #351 )","title":"v0.42.0 - March 4, 2024"},{"location":"changelog/release-notes/#v0410---october-28-2023","text":"Extend adapter interface with Name function ( #346 ) Fix embedded primary field ( #349 )","title":"v0.41.0 - October 28, 2023"},{"location":"changelog/release-notes/#v0400---august-26-2023","text":"Bump github.com/stretchr/testify from 1.8.0 to 1.8.1 ( #320 ) Bump github.com/stretchr/testify from 1.8.1 to 1.8.4 ( #335 ) Fix CI ( #334 ) Fix typo in comment ( #340 ) Refactor scanMulti to only call scan once ( #339 ) Rename CreateDocument to NewDocument ( #341 )","title":"v0.40.0 - August 26, 2023"},{"location":"changelog/release-notes/#v0390---october-23-2022","text":"Add query args to instrumentation ( #314 ) Bump github.com/subosito/gotenv from 1.4.0 to 1.4.1 ( #309 ) Extract cmd package ( #319 ) Generic type Repository wrapper ( #318 ) Replace empty interface with any ( #315 ) Set min go version to 1.15 and fix build matrix ( #316 ) Update go.mod and workflows to use go 1.19 ( #313 )","title":"v0.39.0 - October 23, 2022"},{"location":"changelog/release-notes/#v0380---july-8-2022","text":"","title":"v0.38.0 - July 8, 2022"},{"location":"changelog/release-notes/#changelog","text":"36bf6b0 Allow named structs to be embedded ( #303 )","title":"Changelog"},{"location":"changelog/release-notes/#v0370---july-3-2022","text":"Add join assoc query builder ( #298 ) Auto populate join fields ( #292 ) Bump github.com/stretchr/testify from 1.7.4 to 1.7.5 ( #297 ) Bump github.com/stretchr/testify from 1.7.5 to 1.8.0 ( #299 ) Support loading association using Join query ( #302 )","title":"v0.37.0 - July 3, 2022"},{"location":"changelog/release-notes/#v0360---june-22-2022","text":"Add support for scanning joined assoc ( #290 ) Bump github.com/stretchr/testify from 1.7.1 to 1.7.2 ( #291 ) Bump github.com/stretchr/testify from 1.7.2 to 1.7.4 ( #294 ) Bump github.com/subosito/gotenv from 1.3.0 to 1.4.0 ( #288 ) Migration's Do takes a context as its first argument ( #295 )","title":"v0.36.0 - June 22, 2022"},{"location":"changelog/release-notes/#v0350---may-29-2022","text":"Split big preloading-IN query into multiple queries ( #283 ) ( #285 )","title":"v0.35.0 - May 29, 2022"},{"location":"changelog/release-notes/#v0341---may-26-2022","text":"Add Iris Example ( #282 ) Bump github.com/subosito/gotenv from 1.2.0 to 1.3.0 ( #284 ) Fix Unhandled exception in gopkg.in/yaml.v3 ( #286 )","title":"v0.34.1 - May 26, 2022"},{"location":"changelog/release-notes/#v0340---march-25-2022","text":"Bump github.com/stretchr/testify from 1.7.0 to 1.7.1 ( #273 ) Optimistic locking ( #265 ) Refactor optimistic lock api and test ( #276 )","title":"v0.34.0 - March 25, 2022"},{"location":"changelog/release-notes/#v0331---march-12-2022","text":"Fix dependencies ( #270 )","title":"v0.33.1 - March 12, 2022"},{"location":"changelog/release-notes/#v0330---march-12-2022","text":"Basic support for insert with on conflict ( #269 ) Deprecate migrator package ( #267 )","title":"v0.33.0 - March 12, 2022"},{"location":"changelog/release-notes/#v0320---february-20-2022","text":":boom: Remove deprecated reltest package ( #266 ) Bump github.com/go-rel/reltest from 0.5.0 to 0.6.0 ( #264 )","title":"v0.32.0 - February 20, 2022"},{"location":"changelog/release-notes/#v0310---february-15-2022","text":"Bump github.com/go-rel/reltest from 0.4.0 to 0.5.0 ( #259 ) Setup codeql analysis ( #263 ) Support embeddable structs ( #262 )","title":"v0.31.0 - February 15, 2022"},{"location":"changelog/release-notes/#v0300---november-14-2021","text":":boom: Remove builtin base sql adapter ( #258 ) :boom: Remove builtin mysql adapter ( #256 ) :boom: Remove builtin postgres adapter ( #255 ) :boom: Remove builtin sqlite3 adapter ( #257 ) Bump github.com/lib/pq from 1.10.3 to 1.10.4 ( #254 )","title":"v0.30.0 - November 14, 2021"},{"location":"changelog/release-notes/#v0292---november-8-2021","text":"Fix Structset to handle uuid ([16]byte) correctly ( #253 )","title":"v0.29.2 - November 8, 2021"},{"location":"changelog/release-notes/#v0291---november-5-2021","text":"Correctly handle nil values in arrays ( #251 ) Fix panics when array ptr is used for InsertAll and DeleteAll ( #250 )","title":"v0.29.1 - November 5, 2021"},{"location":"changelog/release-notes/#v0290---november-5-2021","text":"Fix to find records to collection of pointer type ( #246 ) Fix typo in comments ( #248 ) Implement option to specify any column as primary key ( #247 ) Test migrator using new reltest package ( #243 )","title":"v0.29.0 - November 5, 2021"},{"location":"changelog/release-notes/#v0280---october-29-2021","text":"Add .deepsource.toml ( #237 ) Add filter conditions for Join helpers ( #239 ) Add support for primary-replica connections ( #238 ) Replace bytes.Compare with bytes.Equal ( #236 )","title":"v0.28.0 - October 29, 2021"},{"location":"changelog/release-notes/#v0270---october-20-2021","text":"Add option to specify addtional filters for joins ( #234 )","title":"v0.27.0 - October 20, 2021"},{"location":"changelog/release-notes/#v0261---october-19-2021","text":"Add workflow to bump patch version ( #232 ) Bump github.com/mattn/go-sqlite3 from 1.14.8 to 1.14.9 ( #230 ) Fix find and count all for soft deleteable records ( #231 )","title":"v0.26.1 - October 19, 2021"},{"location":"changelog/release-notes/#v0260---october-13-2021","text":"Add alternative soft delete scheme ( #225 ) Add option to define JSON datatype column ( #223 ) Add partial unique index for specs ( #221 ) Allow FilterQuery to be specified for partial indexes and unique key constraints ( #219 ) Remove Filter for key as it is not directly supported by SQL ( #220 )","title":"v0.26.0 - October 13, 2021"},{"location":"changelog/release-notes/#v0250---september-27-2021","text":"Add deprecation notices in constructors ( #214 ) Deprecate builtin mysql package ( #211 ) Deprecate builtin sqlite3 package ( #212 ) Fix preload ptr field with custom table ( #216 )","title":"v0.25.0 - September 27, 2021"},{"location":"changelog/release-notes/#v0240---september-25-2021","text":"Add Close() error to Adapter interface ( #209 ) Deprecate reltest ( #208 ) Fix bump-minor workflow ( #210 )","title":"v0.24.0 - September 25, 2021"},{"location":"changelog/release-notes/#v0230---september-13-2021","text":"Deprecate NewSelect for Select ( #205 ) Deprecate NewSortAsc/Desc for SortAsc/Desc ( #204 ) Implement Map.String() ( #206 )","title":"v0.23.0 - September 13, 2021"},{"location":"changelog/release-notes/#v0220---september-7-2021","text":"Add doc to use clientFoundRows=true to mysql adapter ( #202 ) Allow the function that returns the time to be replaced ( #201 ) Bump github.com/lib/pq from 1.10.2 to 1.10.3 ( #203 )","title":"v0.22.0 - September 7, 2021"},{"location":"changelog/release-notes/#v0210---august-25-2021","text":"Set pointer association fields to nil if preload fails ( #197 ) Fix merge sorts query ( #195 ) Fix string of empty query ( #196 ) If the preload fails, the intermediate association fields will also remain nil ( #198 )","title":"v0.21.0 - August 25, 2021"},{"location":"changelog/release-notes/#v0200---august-19-2021","text":"Fix Merge sort query ( #189 ) Fix deleting empty has many ( #191 ) Support stringer interface on query and mutator ( #194 )","title":"v0.20.0 - August 19, 2021"},{"location":"changelog/release-notes/#v0190---august-14-2021","text":"Support NotFoundError is sql.ErrNoRows ( #188 )","title":"v0.19.0 - August 14, 2021"},{"location":"changelog/release-notes/#v0180---august-7-2021","text":"Bump github.com/go-sql-driver/mysql from 1.5.0 to 1.6.0 ( #177 ) Bump github.com/lib/pq from 1.9.0 to 1.10.2 ( #178 ) Bump github.com/mattn/go-sqlite3 from 1.14.6 to 1.14.8 ( #179 ) Fix setting tag auto: true panics in reltest ( #183 ) Improve preload doc ( #180 ) Setup homebrew tap ( #181 )","title":"v0.18.0 - August 7, 2021"},{"location":"changelog/upgrading/","text":"Upgrading \u00b6 Upgrading from 0.32.x to 0.33.x \u00b6 Rel v0.33.x adds rel.OnConflict mutator that requires adapter interface changes. because of that, when upgrading to this version, other Rel packages need to be upgraded at the same time as well . Upgrading from 0.31.x to 0.32.x \u00b6 Import Path \u00b6 Builtin github.com/go-rel/rel/reltest adapter has been refactored to github.com/go-rel/reltest . 0.31.x import \"github.com/go-rel/rel/reltest\" 0.32.x import \"github.com/go-rel/rel\" Upgrading from 0.29.x to 0.30.x \u00b6 SQLite3 Adapter \u00b6 Builtin github.com/go-rel/rel/adapter/sqlite3 adapter has been extracted to github.com/go-rel/sqlite3 . 0.29.x import \"github.com/go-rel/rel/adapter/sqlite3\" 0.30.x import \"github.com/go-rel/sqlite3\" MySQL Adapter \u00b6 Builtin github.com/go-rel/rel/adapter/mysql adapter has been extracted to github.com/go-rel/mysql . 0.29.x import \"github.com/go-rel/rel/adapter/mysql\" 0.30.x import \"github.com/go-rel/mysql\" Postgres Adapter \u00b6 Builtin github.com/go-rel/rel/adapter/postgres adapter has been extracted to github.com/go-rel/postgres . 0.29.x import \"github.com/go-rel/rel/adapter/postgres\" 0.30.x import \"github.com/go-rel/postgres\" Upgrading from 0.16.x to 0.17.x \u00b6 UpdateAll and DeleteAll \u00b6 UpdateAll and DeleteAll now renamed to UpdateAny and DeleteAny respectively. 0.16.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.17.x // UpdateAny updatedCount , err := repo . UpdateAny ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAny deletedCount , err := repo . DeleteAny ( ctx , query ) Upgrading from 0.13.x to 0.14.x \u00b6 UpdateAll and DeleteAll \u00b6 UpdateAll and DeleteAll function now returns affected rows instead of just error. 0.13.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.14.x // UpdateAll updatedCount , err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll deletedCount , err := repo . DeleteAll ( ctx , query ) Upgrading from 0.8.x to 0.9.x \u00b6 Association Definition \u00b6 Before 0.9.x all association is saved as is when its parent is modified, after this PR ( !127 ) this feature needs to be explicitly enabled. 0.8.x // User schema. type User struct { ID int Name string Address Address } 0.9.x // User schema. type User struct { ID int Name string Address Address `autosave:\"true\"` } Upgrading from 0.7.x to 0.8.x \u00b6 Import Path \u00b6 REL is migrated to a new github organization and all import path need to be moved from Fs02 to go-rel 0.7.x import github . com / Fs02 / rel 0.8.x import github . com / go - rel / rel","title":"Upgrading"},{"location":"changelog/upgrading/#upgrading","text":"","title":"Upgrading"},{"location":"changelog/upgrading/#upgrading-from-032x-to-033x","text":"Rel v0.33.x adds rel.OnConflict mutator that requires adapter interface changes. because of that, when upgrading to this version, other Rel packages need to be upgraded at the same time as well .","title":"Upgrading from 0.32.x to 0.33.x"},{"location":"changelog/upgrading/#upgrading-from-031x-to-032x","text":"","title":"Upgrading from 0.31.x to 0.32.x"},{"location":"changelog/upgrading/#import-path","text":"Builtin github.com/go-rel/rel/reltest adapter has been refactored to github.com/go-rel/reltest . 0.31.x import \"github.com/go-rel/rel/reltest\" 0.32.x import \"github.com/go-rel/rel\"","title":"Import Path"},{"location":"changelog/upgrading/#upgrading-from-029x-to-030x","text":"","title":"Upgrading from 0.29.x to 0.30.x"},{"location":"changelog/upgrading/#sqlite3-adapter","text":"Builtin github.com/go-rel/rel/adapter/sqlite3 adapter has been extracted to github.com/go-rel/sqlite3 . 0.29.x import \"github.com/go-rel/rel/adapter/sqlite3\" 0.30.x import \"github.com/go-rel/sqlite3\"","title":"SQLite3 Adapter"},{"location":"changelog/upgrading/#mysql-adapter","text":"Builtin github.com/go-rel/rel/adapter/mysql adapter has been extracted to github.com/go-rel/mysql . 0.29.x import \"github.com/go-rel/rel/adapter/mysql\" 0.30.x import \"github.com/go-rel/mysql\"","title":"MySQL Adapter"},{"location":"changelog/upgrading/#postgres-adapter","text":"Builtin github.com/go-rel/rel/adapter/postgres adapter has been extracted to github.com/go-rel/postgres . 0.29.x import \"github.com/go-rel/rel/adapter/postgres\" 0.30.x import \"github.com/go-rel/postgres\"","title":"Postgres Adapter"},{"location":"changelog/upgrading/#upgrading-from-016x-to-017x","text":"","title":"Upgrading from 0.16.x to 0.17.x"},{"location":"changelog/upgrading/#updateall-and-deleteall","text":"UpdateAll and DeleteAll now renamed to UpdateAny and DeleteAny respectively. 0.16.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.17.x // UpdateAny updatedCount , err := repo . UpdateAny ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAny deletedCount , err := repo . DeleteAny ( ctx , query )","title":"UpdateAll and DeleteAll"},{"location":"changelog/upgrading/#upgrading-from-013x-to-014x","text":"","title":"Upgrading from 0.13.x to 0.14.x"},{"location":"changelog/upgrading/#updateall-and-deleteall_1","text":"UpdateAll and DeleteAll function now returns affected rows instead of just error. 0.13.x // UpdateAll err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll err := repo . DeleteAll ( ctx , query ) 0.14.x // UpdateAll updatedCount , err := repo . UpdateAll ( ctx , query , Set ( \"notes\" , \"notes\" )) // DeleteAll deletedCount , err := repo . DeleteAll ( ctx , query )","title":"UpdateAll and DeleteAll"},{"location":"changelog/upgrading/#upgrading-from-08x-to-09x","text":"","title":"Upgrading from 0.8.x to 0.9.x"},{"location":"changelog/upgrading/#association-definition","text":"Before 0.9.x all association is saved as is when its parent is modified, after this PR ( !127 ) this feature needs to be explicitly enabled. 0.8.x // User schema. type User struct { ID int Name string Address Address } 0.9.x // User schema. type User struct { ID int Name string Address Address `autosave:\"true\"` }","title":"Association Definition"},{"location":"changelog/upgrading/#upgrading-from-07x-to-08x","text":"","title":"Upgrading from 0.7.x to 0.8.x"},{"location":"changelog/upgrading/#import-path_1","text":"REL is migrated to a new github organization and all import path need to be moved from Fs02 to go-rel 0.7.x import github . com / Fs02 / rel 0.8.x import github . com / go - rel / rel","title":"Import Path"},{"location":"reference/adapter-mssql/","text":"mssql \u00b6 import \"github.com/go-rel/mssql\" Overview \u00b6 Package mssql wraps mssql driver as an adapter for REL. Constants \u00b6 const Name string = \"mssql\" Name of database type this adapter implements. func MustOpen \u00b6 func MustOpen ( dsn string ) rel . Adapter MustOpen mssql connection using dsn. func New \u00b6 func New ( db * db . DB ) rel . Adapter New mssql adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open mssql connection using dsn. type MSSQL \u00b6 type MSSQL struct { sql . SQL } MSSQL Adapter. func (MSSQL) Begin \u00b6 func ( m MSSQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (MSSQL) Insert \u00b6 func ( m MSSQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (MSSQL) InsertAll \u00b6 func ( m MSSQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids. func (MSSQL) Name \u00b6 func ( MSSQL ) Name () string Name of database adapter.","title":"github.com/go-rel/mssql"},{"location":"reference/adapter-mssql/#mssql","text":"import \"github.com/go-rel/mssql\"","title":"mssql"},{"location":"reference/adapter-mssql/#overview","text":"Package mssql wraps mssql driver as an adapter for REL.","title":"Overview"},{"location":"reference/adapter-mssql/#constants","text":"const Name string = \"mssql\" Name of database type this adapter implements.","title":"Constants"},{"location":"reference/adapter-mssql/#func-mustopen","text":"func MustOpen ( dsn string ) rel . Adapter MustOpen mssql connection using dsn.","title":"func MustOpen"},{"location":"reference/adapter-mssql/#func-new","text":"func New ( db * db . DB ) rel . Adapter New mssql adapter using existing connection.","title":"func New"},{"location":"reference/adapter-mssql/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open mssql connection using dsn.","title":"func Open"},{"location":"reference/adapter-mssql/#type-mssql","text":"type MSSQL struct { sql . SQL } MSSQL Adapter.","title":"type MSSQL"},{"location":"reference/adapter-mssql/#func-mssql-begin","text":"func ( m MSSQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (MSSQL) Begin"},{"location":"reference/adapter-mssql/#func-mssql-insert","text":"func ( m MSSQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (MSSQL) Insert"},{"location":"reference/adapter-mssql/#func-mssql-insertall","text":"func ( m MSSQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (MSSQL) InsertAll"},{"location":"reference/adapter-mssql/#func-mssql-name","text":"func ( MSSQL ) Name () string Name of database adapter.","title":"func (MSSQL) Name"},{"location":"reference/adapter-mysql/","text":"mysql \u00b6 import \"github.com/go-rel/mysql\" Overview \u00b6 Package mysql wraps mysql driver as an adapter for REL. Usage: // open mysql connection. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter, err := mysql.Open(\"root@(127.0.0.1:3306)/rel_test?clientFoundRows=true&charset=utf8&parseTime=True&loc=Local\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter) Constants \u00b6 const Name string = \"mysql\" Name of database type this adapter implements. func MustOpen \u00b6 func MustOpen ( dsn string ) rel . Adapter MustOpen mysql connection using dsn. func New \u00b6 func New ( database * db . DB ) rel . Adapter New mysql adapter using existing connection. Existing connection needs to be created with clientFoundRows=true options for update and delete to works correctly. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open mysql connection using dsn. type MySQL \u00b6 type MySQL struct { sql . SQL } MySQL adapter. func (MySQL) Name \u00b6 func ( MySQL ) Name () string Name of database adapter. type Quote \u00b6 type Quote struct {} Quote MySQL identifiers and literals. func (Quote) ID \u00b6 func ( q Quote ) ID ( name string ) string func (Quote) Value \u00b6 func ( q Quote ) Value ( v interface {}) string type ValueConvert \u00b6 type ValueConvert struct {} ValueConvert converts values to MySQL literals. func (ValueConvert) ConvertValue \u00b6 func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"github.com/go-rel/mysql"},{"location":"reference/adapter-mysql/#mysql","text":"import \"github.com/go-rel/mysql\"","title":"mysql"},{"location":"reference/adapter-mysql/#overview","text":"Package mysql wraps mysql driver as an adapter for REL. Usage: // open mysql connection. // note: `clientFoundRows=true` is required for update and delete to works correctly. adapter, err := mysql.Open(\"root@(127.0.0.1:3306)/rel_test?clientFoundRows=true&charset=utf8&parseTime=True&loc=Local\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-mysql/#constants","text":"const Name string = \"mysql\" Name of database type this adapter implements.","title":"Constants"},{"location":"reference/adapter-mysql/#func-mustopen","text":"func MustOpen ( dsn string ) rel . Adapter MustOpen mysql connection using dsn.","title":"func MustOpen"},{"location":"reference/adapter-mysql/#func-new","text":"func New ( database * db . DB ) rel . Adapter New mysql adapter using existing connection. Existing connection needs to be created with clientFoundRows=true options for update and delete to works correctly.","title":"func New"},{"location":"reference/adapter-mysql/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open mysql connection using dsn.","title":"func Open"},{"location":"reference/adapter-mysql/#type-mysql","text":"type MySQL struct { sql . SQL } MySQL adapter.","title":"type MySQL"},{"location":"reference/adapter-mysql/#func-mysql-name","text":"func ( MySQL ) Name () string Name of database adapter.","title":"func (MySQL) Name"},{"location":"reference/adapter-mysql/#type-quote","text":"type Quote struct {} Quote MySQL identifiers and literals.","title":"type Quote"},{"location":"reference/adapter-mysql/#func-quote-id","text":"func ( q Quote ) ID ( name string ) string","title":"func (Quote) ID"},{"location":"reference/adapter-mysql/#func-quote-value","text":"func ( q Quote ) Value ( v interface {}) string","title":"func (Quote) Value"},{"location":"reference/adapter-mysql/#type-valueconvert","text":"type ValueConvert struct {} ValueConvert converts values to MySQL literals.","title":"type ValueConvert"},{"location":"reference/adapter-mysql/#func-valueconvert-convertvalue","text":"func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"func (ValueConvert) ConvertValue"},{"location":"reference/adapter-postgres/","text":"postgres \u00b6 import \"github.com/go-rel/postgres\" Overview \u00b6 Package postgres wraps postgres (pq) driver as an adapter for REL. Usage: // open postgres connection. adapter, err := postgres.Open(\"postgres://postgres@localhost/rel_test?sslmode=disable\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter) Constants \u00b6 const Name string = \"postgres\" Name of database type this adapter implements. const TimeLayout = \"2006-01-02 15:04:05.999999999Z07:00:00\" TimeLayout used by PostgreSQL adapter. func FormatTime \u00b6 func FormatTime ( t time . Time ) string FormatTime formats time to PostgreSQL format. func MustOpen \u00b6 func MustOpen ( dsn string ) rel . Adapter MustOpen postgres connection using dsn. func New \u00b6 func New ( database * db . DB ) rel . Adapter New postgres adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open postgres connection using dsn. type Postgres \u00b6 type Postgres struct { sql . SQL } Postgres adapter. func (Postgres) Begin \u00b6 func ( p Postgres ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (Postgres) Insert \u00b6 func ( p Postgres ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id. func (Postgres) InsertAll \u00b6 func ( p Postgres ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids. func (Postgres) Name \u00b6 func ( Postgres ) Name () string Name of database adapter. type Quote \u00b6 type Quote struct {} Quote PostgreSQL identifiers and literals. func (Quote) ID \u00b6 func ( q Quote ) ID ( name string ) string func (Quote) Value \u00b6 func ( q Quote ) Value ( v interface {}) string type ValueConvert \u00b6 type ValueConvert struct {} ValueConvert converts values to PostgreSQL literals. func (ValueConvert) ConvertValue \u00b6 func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"github.com/go-rel/postgres"},{"location":"reference/adapter-postgres/#postgres","text":"import \"github.com/go-rel/postgres\"","title":"postgres"},{"location":"reference/adapter-postgres/#overview","text":"Package postgres wraps postgres (pq) driver as an adapter for REL. Usage: // open postgres connection. adapter, err := postgres.Open(\"postgres://postgres@localhost/rel_test?sslmode=disable\") if err != nil { panic(err) } defer adapter.Close() // initialize REL's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-postgres/#constants","text":"const Name string = \"postgres\" Name of database type this adapter implements. const TimeLayout = \"2006-01-02 15:04:05.999999999Z07:00:00\" TimeLayout used by PostgreSQL adapter.","title":"Constants"},{"location":"reference/adapter-postgres/#func-formattime","text":"func FormatTime ( t time . Time ) string FormatTime formats time to PostgreSQL format.","title":"func FormatTime"},{"location":"reference/adapter-postgres/#func-mustopen","text":"func MustOpen ( dsn string ) rel . Adapter MustOpen postgres connection using dsn.","title":"func MustOpen"},{"location":"reference/adapter-postgres/#func-new","text":"func New ( database * db . DB ) rel . Adapter New postgres adapter using existing connection.","title":"func New"},{"location":"reference/adapter-postgres/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open postgres connection using dsn.","title":"func Open"},{"location":"reference/adapter-postgres/#type-postgres","text":"type Postgres struct { sql . SQL } Postgres adapter.","title":"type Postgres"},{"location":"reference/adapter-postgres/#func-postgres-begin","text":"func ( p Postgres ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (Postgres) Begin"},{"location":"reference/adapter-postgres/#func-postgres-insert","text":"func ( p Postgres ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( interface {}, error ) Insert inserts a record to database and returns its id.","title":"func (Postgres) Insert"},{"location":"reference/adapter-postgres/#func-postgres-insertall","text":"func ( p Postgres ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] interface {}, error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (Postgres) InsertAll"},{"location":"reference/adapter-postgres/#func-postgres-name","text":"func ( Postgres ) Name () string Name of database adapter.","title":"func (Postgres) Name"},{"location":"reference/adapter-postgres/#type-quote","text":"type Quote struct {} Quote PostgreSQL identifiers and literals.","title":"type Quote"},{"location":"reference/adapter-postgres/#func-quote-id","text":"func ( q Quote ) ID ( name string ) string","title":"func (Quote) ID"},{"location":"reference/adapter-postgres/#func-quote-value","text":"func ( q Quote ) Value ( v interface {}) string","title":"func (Quote) Value"},{"location":"reference/adapter-postgres/#type-valueconvert","text":"type ValueConvert struct {} ValueConvert converts values to PostgreSQL literals.","title":"type ValueConvert"},{"location":"reference/adapter-postgres/#func-valueconvert-convertvalue","text":"func ( c ValueConvert ) ConvertValue ( v interface {}) ( driver . Value , error )","title":"func (ValueConvert) ConvertValue"},{"location":"reference/adapter-primaryreplica/","text":"","title":"github.com/go-rel/primaryreplica"},{"location":"reference/adapter-sql/","text":"sql \u00b6 import \"github.com/go-rel/sql\" Overview \u00b6 Constants \u00b6 const DefaultTimeLayout = \"2006-01-02 15:04:05\" DefaultTimeLayout default time layout. func ColumnMapper \u00b6 func ColumnMapper ( column * rel . Column ) ( string , int , int ) ColumnMapper function. func ColumnOptionsMapper \u00b6 func ColumnOptionsMapper ( column * rel . Column ) string ColumnOptionsMapper function. func DropKeyMapper \u00b6 func DropKeyMapper ( keyType rel . KeyType ) string func ExtractString \u00b6 func ExtractString ( s , left , right string ) string ExtractString between two string. type Cursor \u00b6 type Cursor struct { * sql . Rows } Cursor used for retrieving result. func (*Cursor) Fields \u00b6 func ( c * Cursor ) Fields () ([] string , error ) Fields returned in the result. func (*Cursor) NopScanner \u00b6 func ( c * Cursor ) NopScanner () any NopScanner for this adapter. type DeleteBuilder \u00b6 type DeleteBuilder interface { Build ( table string , filter rel . FilterQuery ) ( string , [] any ) } type ErrorMapper \u00b6 type ErrorMapper func ( error ) error ErrorMapper function. type IncrementFunc \u00b6 type IncrementFunc func ( SQL ) int IncrementFunc function. type IndexBuilder \u00b6 type IndexBuilder interface { Build ( index rel . Index ) string } type InsertAllBuilder \u00b6 type InsertAllBuilder interface { Build ( table string , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] any ) } type InsertBuilder \u00b6 type InsertBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] any ) } type QueryBuilder \u00b6 type QueryBuilder interface { Build ( query rel . Query ) ( string , [] any ) } type SQL \u00b6 type SQL struct { QueryBuilder QueryBuilder InsertBuilder InsertBuilder InsertAllBuilder InsertAllBuilder UpdateBuilder UpdateBuilder DeleteBuilder DeleteBuilder TableBuilder TableBuilder IndexBuilder IndexBuilder Increment int IncrementFunc IncrementFunc ErrorMapper ErrorMapper DB * sql . DB Tx * sql . Tx Savepoint int Instrumenter rel . Instrumenter } SQL base adapter. func (SQL) Aggregate \u00b6 func ( s SQL ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) Aggregate record using given query. func (SQL) Apply \u00b6 func ( s SQL ) Apply ( ctx context . Context , migration rel . Migration ) error Apply performs migration to database. Deprecated: Use Schema Apply instead. func (SQL) Begin \u00b6 func ( s SQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction. func (SQL) Close \u00b6 func ( s SQL ) Close () error Close database connection. TODO: add closer to adapter interface func (SQL) Commit \u00b6 func ( s SQL ) Commit ( ctx context . Context ) error Commit commits current transaction. func (SQL) Delete \u00b6 func ( s SQL ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) Delete deletes all results that match the query. func (SQL) DoExec \u00b6 func ( s SQL ) DoExec ( ctx context . Context , statement string , args [] any ) ( sql . Result , error ) DoExec using active database connection. func (SQL) DoQuery \u00b6 func ( s SQL ) DoQuery ( ctx context . Context , statement string , args [] any ) ( * sql . Rows , error ) DoQuery using active database connection. func (SQL) Exec \u00b6 func ( s SQL ) Exec ( ctx context . Context , statement string , args [] any ) ( int64 , int64 , error ) Exec performs exec operation. func (SQL) Insert \u00b6 func ( s SQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( any , error ) Insert inserts a record to database and returns its id. func (SQL) InsertAll \u00b6 func ( s SQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] any , error ) InsertAll inserts multiple records to database and returns its ids. func (*SQL) Instrumentation \u00b6 func ( s * SQL ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation set instrumenter for this adapter. func (SQL) Name \u00b6 func ( s SQL ) Name () string Name returns database adapter name. func (SQL) Ping \u00b6 func ( s SQL ) Ping ( ctx context . Context ) error Ping database. func (SQL) Query \u00b6 func ( s SQL ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) Query performs query operation. func (SQL) Rollback \u00b6 func ( s SQL ) Rollback ( ctx context . Context ) error Rollback revert current transaction. func (SQL) SchemaApply \u00b6 func ( s SQL ) SchemaApply ( ctx context . Context , migration rel . Migration ) error SchemaApply performs migration to database. func (SQL) Update \u00b6 func ( s SQL ) Update ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( int , error ) Update updates a record in database. type TableBuilder \u00b6 type TableBuilder interface { Build ( table rel . Table ) string } type UpdateBuilder \u00b6 type UpdateBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , filter rel . FilterQuery ) ( string , [] any ) }","title":"github.com/go-rel/sql"},{"location":"reference/adapter-sql/#sql","text":"import \"github.com/go-rel/sql\"","title":"sql"},{"location":"reference/adapter-sql/#overview","text":"","title":"Overview"},{"location":"reference/adapter-sql/#constants","text":"const DefaultTimeLayout = \"2006-01-02 15:04:05\" DefaultTimeLayout default time layout.","title":"Constants"},{"location":"reference/adapter-sql/#func-columnmapper","text":"func ColumnMapper ( column * rel . Column ) ( string , int , int ) ColumnMapper function.","title":"func ColumnMapper"},{"location":"reference/adapter-sql/#func-columnoptionsmapper","text":"func ColumnOptionsMapper ( column * rel . Column ) string ColumnOptionsMapper function.","title":"func ColumnOptionsMapper"},{"location":"reference/adapter-sql/#func-dropkeymapper","text":"func DropKeyMapper ( keyType rel . KeyType ) string","title":"func DropKeyMapper"},{"location":"reference/adapter-sql/#func-extractstring","text":"func ExtractString ( s , left , right string ) string ExtractString between two string.","title":"func ExtractString"},{"location":"reference/adapter-sql/#type-cursor","text":"type Cursor struct { * sql . Rows } Cursor used for retrieving result.","title":"type Cursor"},{"location":"reference/adapter-sql/#func-cursor-fields","text":"func ( c * Cursor ) Fields () ([] string , error ) Fields returned in the result.","title":"func (*Cursor) Fields"},{"location":"reference/adapter-sql/#func-cursor-nopscanner","text":"func ( c * Cursor ) NopScanner () any NopScanner for this adapter.","title":"func (*Cursor) NopScanner"},{"location":"reference/adapter-sql/#type-deletebuilder","text":"type DeleteBuilder interface { Build ( table string , filter rel . FilterQuery ) ( string , [] any ) }","title":"type DeleteBuilder"},{"location":"reference/adapter-sql/#type-errormapper","text":"type ErrorMapper func ( error ) error ErrorMapper function.","title":"type ErrorMapper"},{"location":"reference/adapter-sql/#type-incrementfunc","text":"type IncrementFunc func ( SQL ) int IncrementFunc function.","title":"type IncrementFunc"},{"location":"reference/adapter-sql/#type-indexbuilder","text":"type IndexBuilder interface { Build ( index rel . Index ) string }","title":"type IndexBuilder"},{"location":"reference/adapter-sql/#type-insertallbuilder","text":"type InsertAllBuilder interface { Build ( table string , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] any ) }","title":"type InsertAllBuilder"},{"location":"reference/adapter-sql/#type-insertbuilder","text":"type InsertBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( string , [] any ) }","title":"type InsertBuilder"},{"location":"reference/adapter-sql/#type-querybuilder","text":"type QueryBuilder interface { Build ( query rel . Query ) ( string , [] any ) }","title":"type QueryBuilder"},{"location":"reference/adapter-sql/#type-sql","text":"type SQL struct { QueryBuilder QueryBuilder InsertBuilder InsertBuilder InsertAllBuilder InsertAllBuilder UpdateBuilder UpdateBuilder DeleteBuilder DeleteBuilder TableBuilder TableBuilder IndexBuilder IndexBuilder Increment int IncrementFunc IncrementFunc ErrorMapper ErrorMapper DB * sql . DB Tx * sql . Tx Savepoint int Instrumenter rel . Instrumenter } SQL base adapter.","title":"type SQL"},{"location":"reference/adapter-sql/#func-sql-aggregate","text":"func ( s SQL ) Aggregate ( ctx context . Context , query rel . Query , mode string , field string ) ( int , error ) Aggregate record using given query.","title":"func (SQL) Aggregate"},{"location":"reference/adapter-sql/#func-sql-apply","text":"func ( s SQL ) Apply ( ctx context . Context , migration rel . Migration ) error Apply performs migration to database. Deprecated: Use Schema Apply instead.","title":"func (SQL) Apply"},{"location":"reference/adapter-sql/#func-sql-begin","text":"func ( s SQL ) Begin ( ctx context . Context ) ( rel . Adapter , error ) Begin begins a new transaction.","title":"func (SQL) Begin"},{"location":"reference/adapter-sql/#func-sql-close","text":"func ( s SQL ) Close () error Close database connection. TODO: add closer to adapter interface","title":"func (SQL) Close"},{"location":"reference/adapter-sql/#func-sql-commit","text":"func ( s SQL ) Commit ( ctx context . Context ) error Commit commits current transaction.","title":"func (SQL) Commit"},{"location":"reference/adapter-sql/#func-sql-delete","text":"func ( s SQL ) Delete ( ctx context . Context , query rel . Query ) ( int , error ) Delete deletes all results that match the query.","title":"func (SQL) Delete"},{"location":"reference/adapter-sql/#func-sql-doexec","text":"func ( s SQL ) DoExec ( ctx context . Context , statement string , args [] any ) ( sql . Result , error ) DoExec using active database connection.","title":"func (SQL) DoExec"},{"location":"reference/adapter-sql/#func-sql-doquery","text":"func ( s SQL ) DoQuery ( ctx context . Context , statement string , args [] any ) ( * sql . Rows , error ) DoQuery using active database connection.","title":"func (SQL) DoQuery"},{"location":"reference/adapter-sql/#func-sql-exec","text":"func ( s SQL ) Exec ( ctx context . Context , statement string , args [] any ) ( int64 , int64 , error ) Exec performs exec operation.","title":"func (SQL) Exec"},{"location":"reference/adapter-sql/#func-sql-insert","text":"func ( s SQL ) Insert ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate , onConflict rel . OnConflict ) ( any , error ) Insert inserts a record to database and returns its id.","title":"func (SQL) Insert"},{"location":"reference/adapter-sql/#func-sql-insertall","text":"func ( s SQL ) InsertAll ( ctx context . Context , query rel . Query , primaryField string , fields [] string , bulkMutates [] map [ string ] rel . Mutate , onConflict rel . OnConflict ) ([] any , error ) InsertAll inserts multiple records to database and returns its ids.","title":"func (SQL) InsertAll"},{"location":"reference/adapter-sql/#func-sql-instrumentation","text":"func ( s * SQL ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation set instrumenter for this adapter.","title":"func (*SQL) Instrumentation"},{"location":"reference/adapter-sql/#func-sql-name","text":"func ( s SQL ) Name () string Name returns database adapter name.","title":"func (SQL) Name"},{"location":"reference/adapter-sql/#func-sql-ping","text":"func ( s SQL ) Ping ( ctx context . Context ) error Ping database.","title":"func (SQL) Ping"},{"location":"reference/adapter-sql/#func-sql-query","text":"func ( s SQL ) Query ( ctx context . Context , query rel . Query ) ( rel . Cursor , error ) Query performs query operation.","title":"func (SQL) Query"},{"location":"reference/adapter-sql/#func-sql-rollback","text":"func ( s SQL ) Rollback ( ctx context . Context ) error Rollback revert current transaction.","title":"func (SQL) Rollback"},{"location":"reference/adapter-sql/#func-sql-schemaapply","text":"func ( s SQL ) SchemaApply ( ctx context . Context , migration rel . Migration ) error SchemaApply performs migration to database.","title":"func (SQL) SchemaApply"},{"location":"reference/adapter-sql/#func-sql-update","text":"func ( s SQL ) Update ( ctx context . Context , query rel . Query , primaryField string , mutates map [ string ] rel . Mutate ) ( int , error ) Update updates a record in database.","title":"func (SQL) Update"},{"location":"reference/adapter-sql/#type-tablebuilder","text":"type TableBuilder interface { Build ( table rel . Table ) string }","title":"type TableBuilder"},{"location":"reference/adapter-sql/#type-updatebuilder","text":"type UpdateBuilder interface { Build ( table string , primaryField string , mutates map [ string ] rel . Mutate , filter rel . FilterQuery ) ( string , [] any ) }","title":"type UpdateBuilder"},{"location":"reference/adapter-sqlite3/","text":"sqlite3 \u00b6 import \"github.com/go-rel/sqlite3\" Overview \u00b6 Package sqlite3 wraps go-sqlite3 driver as an adapter for rel. Usage: // open sqlite3 connection. adapter, err := sqlite3.Open(\"dev.db\") if err != nil { panic(err) } defer adapter.Close() // initialize rel's repo. repo := rel.New(adapter) Constants \u00b6 const Name string = \"sqlite3\" Name of database type this adapter implements. func MustOpen \u00b6 func MustOpen ( dsn string ) rel . Adapter MustOpen sqlite3 connection using dsn. func New \u00b6 func New ( database * db . DB ) rel . Adapter New sqlite3 adapter using existing connection. func Open \u00b6 func Open ( dsn string ) ( rel . Adapter , error ) Open sqlite3 connection using dsn. type SQLite3 \u00b6 type SQLite3 struct { sql . SQL } SQLite3 adapter func (SQLite3) Name \u00b6 func ( SQLite3 ) Name () string Name of database adapter.","title":"github.com/go-rel/sqlite3"},{"location":"reference/adapter-sqlite3/#sqlite3","text":"import \"github.com/go-rel/sqlite3\"","title":"sqlite3"},{"location":"reference/adapter-sqlite3/#overview","text":"Package sqlite3 wraps go-sqlite3 driver as an adapter for rel. Usage: // open sqlite3 connection. adapter, err := sqlite3.Open(\"dev.db\") if err != nil { panic(err) } defer adapter.Close() // initialize rel's repo. repo := rel.New(adapter)","title":"Overview"},{"location":"reference/adapter-sqlite3/#constants","text":"const Name string = \"sqlite3\" Name of database type this adapter implements.","title":"Constants"},{"location":"reference/adapter-sqlite3/#func-mustopen","text":"func MustOpen ( dsn string ) rel . Adapter MustOpen sqlite3 connection using dsn.","title":"func MustOpen"},{"location":"reference/adapter-sqlite3/#func-new","text":"func New ( database * db . DB ) rel . Adapter New sqlite3 adapter using existing connection.","title":"func New"},{"location":"reference/adapter-sqlite3/#func-open","text":"func Open ( dsn string ) ( rel . Adapter , error ) Open sqlite3 connection using dsn.","title":"func Open"},{"location":"reference/adapter-sqlite3/#type-sqlite3","text":"type SQLite3 struct { sql . SQL } SQLite3 adapter","title":"type SQLite3"},{"location":"reference/adapter-sqlite3/#func-sqlite3-name","text":"func ( SQLite3 ) Name () string Name of database adapter.","title":"func (SQLite3) Name"},{"location":"reference/changeset/","text":"changeset \u00b6 import \"github.com/go-rel/changeset\" Overview \u00b6 Package changeset used to cast and validate data before saving it to the database. Package changeset used to cast and validate data before saving it to the database. Variables \u00b6 var CastAssocErrorMessage = \"{field} is invalid\" CastAssocErrorMessage is the default error message for CastAssoc when its invalid. var CastAssocRequiredMessage = \"{field} is required\" CastAssocRequiredMessage is the default error message for CastAssoc when its missing. var CastErrorMessage = \"{field} is invalid\" CastErrorMessage is the default error message for Cast. var CheckConstraintMessage = \"{field} is invalid\" CheckConstraintMessage is the default error message for CheckConstraint. var ForeignKeyConstraintMessage = \"does not exist\" ForeignKeyConstraintMessage is the default error message for ForeignKeyConstraint. var PutAssocErrorMessage = \"{field} is invalid\" PutAssocErrorMessage is the default error message for PutAssoc. var PutChangeErrorMessage = \"{field} is invalid\" PutChangeErrorMessage is the default error message for PutChange. var PutDefaultErrorMessage = \"{field} is invalid\" PutDefaultErrorMessage is the default error message for PutDefault. var UniqueConstraintMessage = \"{field} has already been taken\" UniqueConstraintMessage is the default error message for UniqueConstraint. var ValidateExclusionErrorMessage = \"{field} must not be any of {values}\" ValidateExclusionErrorMessage is the default error message for ValidateExclusion. var ValidateInclusionErrorMessage = \"{field} must be one of {values}\" ValidateInclusionErrorMessage is the default error message for ValidateInclusion. var ValidateMaxErrorMessage = \"{field} must be less than {max}\" ValidateMaxErrorMessage is the default error message for ValidateMax. var ValidateMinErrorMessage = \"{field} must be more than {min}\" ValidateMinErrorMessage is the default error message for ValidateMin. var ValidatePatternErrorMessage = \"{field}'s format is invalid\" ValidatePatternErrorMessage is the default error message for ValidatePattern. var ValidateRangeErrorMessage = \"{field} must be between {min} and {max}\" ValidateRangeErrorMessage is the default error message for ValidateRange. var ValidateRegexpErrorMessage = \"{field}'s format is invalid\" ValidateRegexpErrorMessage is the default error message for ValidateRegexp. var ValidateRequiredErrorMessage = \"{field} is required\" ValidateRequiredErrorMessage is the default error message for ValidateRequired. func AddError \u00b6 func AddError ( ch * Changeset , field string , message string ) AddError adds an error to changeset. ch := changeset.Cast(user, params, fields) changeset.AddError(ch, \"field\", \"error\") ch.Errors() // []errors.Error{{Field: \"field\", Message: \"error\"}} func ApplyString \u00b6 func ApplyString ( ch * Changeset , field string , fn func ( string ) string ) ApplyString apply a function for string value. func CastAssoc \u00b6 func CastAssoc ( ch * Changeset , field string , fn ChangeFunc , opts ... Option ) CastAssoc casts association changes using changeset function. Repo insert or update won't persist any changes generated by CastAssoc. func CheckConstraint \u00b6 func CheckConstraint ( ch * Changeset , field string , opts ... Option ) CheckConstraint adds an unique constraint to changeset. func DeleteChange \u00b6 func DeleteChange ( ch * Changeset , field string ) DeleteChange from changeset. func EscapeString \u00b6 func EscapeString ( ch * Changeset , fields ... string ) EscapeString escapes special characters like \"<\" to become \"<\". this is helper for html.EscapeString func ForeignKeyConstraint \u00b6 func ForeignKeyConstraint ( ch * Changeset , field string , opts ... Option ) ForeignKeyConstraint adds an unique constraint to changeset. func PutAssoc \u00b6 func PutAssoc ( ch * Changeset , field string , value interface {}, opts ... Option ) PutAssoc to changeset. func PutChange \u00b6 func PutChange ( ch * Changeset , field string , value interface {}, opts ... Option ) PutChange to changeset. func PutDefault \u00b6 func PutDefault ( ch * Changeset , field string , value interface {}, opts ... Option ) PutDefault to changeset. func UnescapeString \u00b6 func UnescapeString ( ch * Changeset , field string ) UnescapeString unescapes entities like \"<\" to become \"<\". this is helper for html.UnescapeString. func UniqueConstraint \u00b6 func UniqueConstraint ( ch * Changeset , field string , opts ... Option ) UniqueConstraint adds an unique constraint to changeset. func ValidateExclusion \u00b6 func ValidateExclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateExclusion validates a change is not included in the given values. func ValidateInclusion \u00b6 func ValidateInclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateInclusion validates a change is included in the given values. func ValidateMax \u00b6 func ValidateMax ( ch * Changeset , field string , max int , opts ... Option ) ValidateMax validates the value of given field is not larger than max. Validation can be performed against string, slice and numbers. func ValidateMin \u00b6 func ValidateMin ( ch * Changeset , field string , min int , opts ... Option ) ValidateMin validates the value of given field is not smaller than min. Validation can be performed against string, slice and numbers. func ValidatePattern \u00b6 func ValidatePattern ( ch * Changeset , field string , pattern string , opts ... Option ) ValidatePattern validates the value of given field to match given pattern. func ValidateRange \u00b6 func ValidateRange ( ch * Changeset , field string , min int , max int , opts ... Option ) ValidateRange validates the value of given field is not larger than max and not smaller than min. Validation can be performed against string, slice and numbers. func ValidateRegexp \u00b6 func ValidateRegexp ( ch * Changeset , field string , exp * regexp . Regexp , opts ... Option ) ValidateRegexp validates the value of given field to match given regexp. func ValidateRequired \u00b6 func ValidateRequired ( ch * Changeset , fields [] string , opts ... Option ) ValidateRequired validates that one or more fields are present in the changeset. It'll add error to changeset if field in the changes is nil or string made only of whitespace. type ChangeFunc \u00b6 type ChangeFunc func ( interface {}, params . Params ) * Changeset ChangeFunc is changeset function. type Changeset \u00b6 type Changeset struct { // contains filtered or unexported fields } Changeset used to cast and validate data before saving it to the database. func Cast \u00b6 func Cast ( data interface {}, params params . Params , fields [] string , opts ... Option ) * Changeset Cast params as changes for the given data according to the permitted fields. Returns a new changeset. params will only be added as changes if it does not have the same value as the field in the data. func Change \u00b6 func Change ( schema interface {}, changes ... map [ string ] interface {}) * Changeset Change make a new changeset without changes and build from given schema. Returns new Changeset. func Convert \u00b6 func Convert ( data interface {}) * Changeset Convert a struct as changeset, every field's value will be treated as changes. Returns a new changeset. PK changes in the changeset created with this function will be ignored func (*Changeset) Apply \u00b6 func ( c * Changeset ) Apply ( doc * rel . Document , mut * rel . Mutation ) Apply mutation. func (Changeset) Changes \u00b6 func ( c Changeset ) Changes () map [ string ] interface {} Changes of changeset. func (Changeset) Constraints \u00b6 func ( c Changeset ) Constraints () Constraints Constraints of changeset. func (Changeset) Error \u00b6 func ( c Changeset ) Error () error Error of changeset, returns the first error if any. func (Changeset) Errors \u00b6 func ( c Changeset ) Errors () [] error Errors of changeset. func (Changeset) Fetch \u00b6 func ( c Changeset ) Fetch ( field string ) interface {} Fetch a change or value from changeset. func (Changeset) Get \u00b6 func ( c Changeset ) Get ( field string ) interface {} Get a change from changeset. func (Changeset) Types \u00b6 func ( c Changeset ) Types () map [ string ] reflect . Type Types of changeset. func (Changeset) Values \u00b6 func ( c Changeset ) Values () map [ string ] interface {} Values of changeset. type Constraint \u00b6 type Constraint struct { Field string Message string Code int Name string Exact bool Type rel . ConstraintType } Constraint defines information to infer constraint error. type Constraints \u00b6 type Constraints [] Constraint Constraints is slice of Constraint func (Constraints) GetError \u00b6 func ( constraints Constraints ) GetError ( err error ) error GetError converts error based on constraints. If the original error is constraint error, and it's defined in the constraint list, then it'll be updated with constraint's message. If the original error is constraint error but not defined in the constraint list, it'll be converted to unexpected error. else it'll not modify the error. type Error \u00b6 type Error struct { Message string `json:\"message\"` Field string `json:\"field,omitempty\"` Code int `json:\"code,omitempty\"` Err error `json:\"-\"` } Error struct. func (Error) Error \u00b6 func ( e Error ) Error () string Error prints error message. func (Error) Unwrap \u00b6 func ( e Error ) Unwrap () error Unwrap internal error. type Option \u00b6 type Option func ( * Options ) Option for changeset operation. func ChangeOnly \u00b6 func ChangeOnly ( changeOnly bool ) Option ChangeOnly is used to define if validate is only check change func Code \u00b6 func Code ( code int ) Option Code for changeset operation's error. func EmptyValues \u00b6 func EmptyValues ( values ... interface {}) Option EmptyValues defines list of empty values when casting. default to [\"\"] func Exact \u00b6 func Exact ( exact bool ) Option Exact is used to define how index name is matched. func Message \u00b6 func Message ( message string ) Option Message for changeset operation's error. func Name \u00b6 func Name ( name string ) Option Name is used to define index name of constraints. func Required \u00b6 func Required ( required bool ) Option Required is used to define whether an assoc needs to be required or not. func SourceField \u00b6 func SourceField ( field string ) Option SourceField to define used field name in params. type Options \u00b6 type Options struct { // contains filtered or unexported fields } Options applicable to changeset.","title":"github.com/go-rel/changeset"},{"location":"reference/changeset/#changeset","text":"import \"github.com/go-rel/changeset\"","title":"changeset"},{"location":"reference/changeset/#overview","text":"Package changeset used to cast and validate data before saving it to the database. Package changeset used to cast and validate data before saving it to the database.","title":"Overview"},{"location":"reference/changeset/#variables","text":"var CastAssocErrorMessage = \"{field} is invalid\" CastAssocErrorMessage is the default error message for CastAssoc when its invalid. var CastAssocRequiredMessage = \"{field} is required\" CastAssocRequiredMessage is the default error message for CastAssoc when its missing. var CastErrorMessage = \"{field} is invalid\" CastErrorMessage is the default error message for Cast. var CheckConstraintMessage = \"{field} is invalid\" CheckConstraintMessage is the default error message for CheckConstraint. var ForeignKeyConstraintMessage = \"does not exist\" ForeignKeyConstraintMessage is the default error message for ForeignKeyConstraint. var PutAssocErrorMessage = \"{field} is invalid\" PutAssocErrorMessage is the default error message for PutAssoc. var PutChangeErrorMessage = \"{field} is invalid\" PutChangeErrorMessage is the default error message for PutChange. var PutDefaultErrorMessage = \"{field} is invalid\" PutDefaultErrorMessage is the default error message for PutDefault. var UniqueConstraintMessage = \"{field} has already been taken\" UniqueConstraintMessage is the default error message for UniqueConstraint. var ValidateExclusionErrorMessage = \"{field} must not be any of {values}\" ValidateExclusionErrorMessage is the default error message for ValidateExclusion. var ValidateInclusionErrorMessage = \"{field} must be one of {values}\" ValidateInclusionErrorMessage is the default error message for ValidateInclusion. var ValidateMaxErrorMessage = \"{field} must be less than {max}\" ValidateMaxErrorMessage is the default error message for ValidateMax. var ValidateMinErrorMessage = \"{field} must be more than {min}\" ValidateMinErrorMessage is the default error message for ValidateMin. var ValidatePatternErrorMessage = \"{field}'s format is invalid\" ValidatePatternErrorMessage is the default error message for ValidatePattern. var ValidateRangeErrorMessage = \"{field} must be between {min} and {max}\" ValidateRangeErrorMessage is the default error message for ValidateRange. var ValidateRegexpErrorMessage = \"{field}'s format is invalid\" ValidateRegexpErrorMessage is the default error message for ValidateRegexp. var ValidateRequiredErrorMessage = \"{field} is required\" ValidateRequiredErrorMessage is the default error message for ValidateRequired.","title":"Variables"},{"location":"reference/changeset/#func-adderror","text":"func AddError ( ch * Changeset , field string , message string ) AddError adds an error to changeset. ch := changeset.Cast(user, params, fields) changeset.AddError(ch, \"field\", \"error\") ch.Errors() // []errors.Error{{Field: \"field\", Message: \"error\"}}","title":"func AddError"},{"location":"reference/changeset/#func-applystring","text":"func ApplyString ( ch * Changeset , field string , fn func ( string ) string ) ApplyString apply a function for string value.","title":"func ApplyString"},{"location":"reference/changeset/#func-castassoc","text":"func CastAssoc ( ch * Changeset , field string , fn ChangeFunc , opts ... Option ) CastAssoc casts association changes using changeset function. Repo insert or update won't persist any changes generated by CastAssoc.","title":"func CastAssoc"},{"location":"reference/changeset/#func-checkconstraint","text":"func CheckConstraint ( ch * Changeset , field string , opts ... Option ) CheckConstraint adds an unique constraint to changeset.","title":"func CheckConstraint"},{"location":"reference/changeset/#func-deletechange","text":"func DeleteChange ( ch * Changeset , field string ) DeleteChange from changeset.","title":"func DeleteChange"},{"location":"reference/changeset/#func-escapestring","text":"func EscapeString ( ch * Changeset , fields ... string ) EscapeString escapes special characters like \"<\" to become \"<\". this is helper for html.EscapeString","title":"func EscapeString"},{"location":"reference/changeset/#func-foreignkeyconstraint","text":"func ForeignKeyConstraint ( ch * Changeset , field string , opts ... Option ) ForeignKeyConstraint adds an unique constraint to changeset.","title":"func ForeignKeyConstraint"},{"location":"reference/changeset/#func-putassoc","text":"func PutAssoc ( ch * Changeset , field string , value interface {}, opts ... Option ) PutAssoc to changeset.","title":"func PutAssoc"},{"location":"reference/changeset/#func-putchange","text":"func PutChange ( ch * Changeset , field string , value interface {}, opts ... Option ) PutChange to changeset.","title":"func PutChange"},{"location":"reference/changeset/#func-putdefault","text":"func PutDefault ( ch * Changeset , field string , value interface {}, opts ... Option ) PutDefault to changeset.","title":"func PutDefault"},{"location":"reference/changeset/#func-unescapestring","text":"func UnescapeString ( ch * Changeset , field string ) UnescapeString unescapes entities like \"<\" to become \"<\". this is helper for html.UnescapeString.","title":"func UnescapeString"},{"location":"reference/changeset/#func-uniqueconstraint","text":"func UniqueConstraint ( ch * Changeset , field string , opts ... Option ) UniqueConstraint adds an unique constraint to changeset.","title":"func UniqueConstraint"},{"location":"reference/changeset/#func-validateexclusion","text":"func ValidateExclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateExclusion validates a change is not included in the given values.","title":"func ValidateExclusion"},{"location":"reference/changeset/#func-validateinclusion","text":"func ValidateInclusion ( ch * Changeset , field string , values [] interface {}, opts ... Option ) ValidateInclusion validates a change is included in the given values.","title":"func ValidateInclusion"},{"location":"reference/changeset/#func-validatemax","text":"func ValidateMax ( ch * Changeset , field string , max int , opts ... Option ) ValidateMax validates the value of given field is not larger than max. Validation can be performed against string, slice and numbers.","title":"func ValidateMax"},{"location":"reference/changeset/#func-validatemin","text":"func ValidateMin ( ch * Changeset , field string , min int , opts ... Option ) ValidateMin validates the value of given field is not smaller than min. Validation can be performed against string, slice and numbers.","title":"func ValidateMin"},{"location":"reference/changeset/#func-validatepattern","text":"func ValidatePattern ( ch * Changeset , field string , pattern string , opts ... Option ) ValidatePattern validates the value of given field to match given pattern.","title":"func ValidatePattern"},{"location":"reference/changeset/#func-validaterange","text":"func ValidateRange ( ch * Changeset , field string , min int , max int , opts ... Option ) ValidateRange validates the value of given field is not larger than max and not smaller than min. Validation can be performed against string, slice and numbers.","title":"func ValidateRange"},{"location":"reference/changeset/#func-validateregexp","text":"func ValidateRegexp ( ch * Changeset , field string , exp * regexp . Regexp , opts ... Option ) ValidateRegexp validates the value of given field to match given regexp.","title":"func ValidateRegexp"},{"location":"reference/changeset/#func-validaterequired","text":"func ValidateRequired ( ch * Changeset , fields [] string , opts ... Option ) ValidateRequired validates that one or more fields are present in the changeset. It'll add error to changeset if field in the changes is nil or string made only of whitespace.","title":"func ValidateRequired"},{"location":"reference/changeset/#type-changefunc","text":"type ChangeFunc func ( interface {}, params . Params ) * Changeset ChangeFunc is changeset function.","title":"type ChangeFunc"},{"location":"reference/changeset/#type-changeset","text":"type Changeset struct { // contains filtered or unexported fields } Changeset used to cast and validate data before saving it to the database.","title":"type Changeset"},{"location":"reference/changeset/#func-cast","text":"func Cast ( data interface {}, params params . Params , fields [] string , opts ... Option ) * Changeset Cast params as changes for the given data according to the permitted fields. Returns a new changeset. params will only be added as changes if it does not have the same value as the field in the data.","title":"func Cast"},{"location":"reference/changeset/#func-change","text":"func Change ( schema interface {}, changes ... map [ string ] interface {}) * Changeset Change make a new changeset without changes and build from given schema. Returns new Changeset.","title":"func Change"},{"location":"reference/changeset/#func-convert","text":"func Convert ( data interface {}) * Changeset Convert a struct as changeset, every field's value will be treated as changes. Returns a new changeset. PK changes in the changeset created with this function will be ignored","title":"func Convert"},{"location":"reference/changeset/#func-changeset-apply","text":"func ( c * Changeset ) Apply ( doc * rel . Document , mut * rel . Mutation ) Apply mutation.","title":"func (*Changeset) Apply"},{"location":"reference/changeset/#func-changeset-changes","text":"func ( c Changeset ) Changes () map [ string ] interface {} Changes of changeset.","title":"func (Changeset) Changes"},{"location":"reference/changeset/#func-changeset-constraints","text":"func ( c Changeset ) Constraints () Constraints Constraints of changeset.","title":"func (Changeset) Constraints"},{"location":"reference/changeset/#func-changeset-error","text":"func ( c Changeset ) Error () error Error of changeset, returns the first error if any.","title":"func (Changeset) Error"},{"location":"reference/changeset/#func-changeset-errors","text":"func ( c Changeset ) Errors () [] error Errors of changeset.","title":"func (Changeset) Errors"},{"location":"reference/changeset/#func-changeset-fetch","text":"func ( c Changeset ) Fetch ( field string ) interface {} Fetch a change or value from changeset.","title":"func (Changeset) Fetch"},{"location":"reference/changeset/#func-changeset-get","text":"func ( c Changeset ) Get ( field string ) interface {} Get a change from changeset.","title":"func (Changeset) Get"},{"location":"reference/changeset/#func-changeset-types","text":"func ( c Changeset ) Types () map [ string ] reflect . Type Types of changeset.","title":"func (Changeset) Types"},{"location":"reference/changeset/#func-changeset-values","text":"func ( c Changeset ) Values () map [ string ] interface {} Values of changeset.","title":"func (Changeset) Values"},{"location":"reference/changeset/#type-constraint","text":"type Constraint struct { Field string Message string Code int Name string Exact bool Type rel . ConstraintType } Constraint defines information to infer constraint error.","title":"type Constraint"},{"location":"reference/changeset/#type-constraints","text":"type Constraints [] Constraint Constraints is slice of Constraint","title":"type Constraints"},{"location":"reference/changeset/#func-constraints-geterror","text":"func ( constraints Constraints ) GetError ( err error ) error GetError converts error based on constraints. If the original error is constraint error, and it's defined in the constraint list, then it'll be updated with constraint's message. If the original error is constraint error but not defined in the constraint list, it'll be converted to unexpected error. else it'll not modify the error.","title":"func (Constraints) GetError"},{"location":"reference/changeset/#type-error","text":"type Error struct { Message string `json:\"message\"` Field string `json:\"field,omitempty\"` Code int `json:\"code,omitempty\"` Err error `json:\"-\"` } Error struct.","title":"type Error"},{"location":"reference/changeset/#func-error-error","text":"func ( e Error ) Error () string Error prints error message.","title":"func (Error) Error"},{"location":"reference/changeset/#func-error-unwrap","text":"func ( e Error ) Unwrap () error Unwrap internal error.","title":"func (Error) Unwrap"},{"location":"reference/changeset/#type-option","text":"type Option func ( * Options ) Option for changeset operation.","title":"type Option"},{"location":"reference/changeset/#func-changeonly","text":"func ChangeOnly ( changeOnly bool ) Option ChangeOnly is used to define if validate is only check change","title":"func ChangeOnly"},{"location":"reference/changeset/#func-code","text":"func Code ( code int ) Option Code for changeset operation's error.","title":"func Code"},{"location":"reference/changeset/#func-emptyvalues","text":"func EmptyValues ( values ... interface {}) Option EmptyValues defines list of empty values when casting. default to [\"\"]","title":"func EmptyValues"},{"location":"reference/changeset/#func-exact","text":"func Exact ( exact bool ) Option Exact is used to define how index name is matched.","title":"func Exact"},{"location":"reference/changeset/#func-message","text":"func Message ( message string ) Option Message for changeset operation's error.","title":"func Message"},{"location":"reference/changeset/#func-name","text":"func Name ( name string ) Option Name is used to define index name of constraints.","title":"func Name"},{"location":"reference/changeset/#func-required","text":"func Required ( required bool ) Option Required is used to define whether an assoc needs to be required or not.","title":"func Required"},{"location":"reference/changeset/#func-sourcefield","text":"func SourceField ( field string ) Option SourceField to define used field name in params.","title":"func SourceField"},{"location":"reference/changeset/#type-options","text":"type Options struct { // contains filtered or unexported fields } Options applicable to changeset.","title":"type Options"},{"location":"reference/group/","text":"group \u00b6 import \"github.com/go-rel/rel/group\" Overview \u00b6 Package group is syntatic sugar for building group query. Variables \u00b6 var ( // By is alias for rel.NewGroup By = rel . NewGroup // Fields is alias for rel.NewGroup Fields = rel . NewGroup )","title":"github.com/go-rel/rel/group"},{"location":"reference/group/#group","text":"import \"github.com/go-rel/rel/group\"","title":"group"},{"location":"reference/group/#overview","text":"Package group is syntatic sugar for building group query.","title":"Overview"},{"location":"reference/group/#variables","text":"var ( // By is alias for rel.NewGroup By = rel . NewGroup // Fields is alias for rel.NewGroup Fields = rel . NewGroup )","title":"Variables"},{"location":"reference/join/","text":"join \u00b6 import \"github.com/go-rel/rel/join\" Overview \u00b6 Package join is syntatic sugar for building join query. Variables \u00b6 var ( // Join is alias for rel.NewJoin Join = rel . NewJoin // On is alias for rel.NewJoinOn On = rel . NewJoinOn // Inner is alias for rel.NewInnerJoin Inner = rel . NewInnerJoin // InnerOn is alias for rel.NewInnerJoinOn InnerOn = rel . NewInnerJoinOn // Left is alias for rel.NewLeftJoin Left = rel . NewLeftJoin // LeftOn is alias for rel.NewLeftJoinOn LeftOn = rel . NewLeftJoinOn // Right is alias for rel.NewRightJoin Right = rel . NewRightJoin // RightOn is alias for rel.NewRightJoinOn RightOn = rel . NewRightJoinOn // Full is alias for rel.NewFullJoin Full = rel . NewFullJoin // FullOn is alias for rel.NewFullJoinOn FullOn = rel . NewFullJoinOn // AssocWith is alias for rel.NewJoinAssocWith AssocWith = rel . NewJoinAssocWith // Assoc is alias for rel.NewJoinAssoc Assoc = rel . NewJoinAssoc )","title":"github.com/go-rel/rel/join"},{"location":"reference/join/#join","text":"import \"github.com/go-rel/rel/join\"","title":"join"},{"location":"reference/join/#overview","text":"Package join is syntatic sugar for building join query.","title":"Overview"},{"location":"reference/join/#variables","text":"var ( // Join is alias for rel.NewJoin Join = rel . NewJoin // On is alias for rel.NewJoinOn On = rel . NewJoinOn // Inner is alias for rel.NewInnerJoin Inner = rel . NewInnerJoin // InnerOn is alias for rel.NewInnerJoinOn InnerOn = rel . NewInnerJoinOn // Left is alias for rel.NewLeftJoin Left = rel . NewLeftJoin // LeftOn is alias for rel.NewLeftJoinOn LeftOn = rel . NewLeftJoinOn // Right is alias for rel.NewRightJoin Right = rel . NewRightJoin // RightOn is alias for rel.NewRightJoinOn RightOn = rel . NewRightJoinOn // Full is alias for rel.NewFullJoin Full = rel . NewFullJoin // FullOn is alias for rel.NewFullJoinOn FullOn = rel . NewFullJoinOn // AssocWith is alias for rel.NewJoinAssocWith AssocWith = rel . NewJoinAssocWith // Assoc is alias for rel.NewJoinAssoc Assoc = rel . NewJoinAssoc )","title":"Variables"},{"location":"reference/migration/","text":"migration \u00b6 import \"github.com/go-rel/migration\" Overview \u00b6 type Migration \u00b6 type Migration struct { // contains filtered or unexported fields } Migration utility that handles migration logic. func New \u00b6 func New ( repo rel . Repository ) Migration New migration manager. func (*Migration) Instrumentation \u00b6 func ( m * Migration ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation function. func (*Migration) Migrate \u00b6 func ( m * Migration ) Migrate ( ctx context . Context ) Migrate to the latest schema version. func (*Migration) Register \u00b6 func ( m * Migration ) Register ( v int , up func ( schema * rel . Schema ), down func ( schema * rel . Schema )) Register a migration. func (*Migration) Rollback \u00b6 func ( m * Migration ) Rollback ( ctx context . Context ) Rollback migration 1 step.","title":"github.com/go-rel/migration"},{"location":"reference/migration/#migration","text":"import \"github.com/go-rel/migration\"","title":"migration"},{"location":"reference/migration/#overview","text":"","title":"Overview"},{"location":"reference/migration/#type-migration","text":"type Migration struct { // contains filtered or unexported fields } Migration utility that handles migration logic.","title":"type Migration"},{"location":"reference/migration/#func-new","text":"func New ( repo rel . Repository ) Migration New migration manager.","title":"func New"},{"location":"reference/migration/#func-migration-instrumentation","text":"func ( m * Migration ) Instrumentation ( instrumenter rel . Instrumenter ) Instrumentation function.","title":"func (*Migration) Instrumentation"},{"location":"reference/migration/#func-migration-migrate","text":"func ( m * Migration ) Migrate ( ctx context . Context ) Migrate to the latest schema version.","title":"func (*Migration) Migrate"},{"location":"reference/migration/#func-migration-register","text":"func ( m * Migration ) Register ( v int , up func ( schema * rel . Schema ), down func ( schema * rel . Schema )) Register a migration.","title":"func (*Migration) Register"},{"location":"reference/migration/#func-migration-rollback","text":"func ( m * Migration ) Rollback ( ctx context . Context ) Rollback migration 1 step.","title":"func (*Migration) Rollback"},{"location":"reference/rel/","text":"","title":"github.com/go-rel/rel"},{"location":"reference/reltest/","text":"","title":"github.com/go-rel/reltest"},{"location":"reference/sort/","text":"sort \u00b6 import \"github.com/go-rel/rel/sort\" Overview \u00b6 Package sort is syntatic sugar for building sort query. Variables \u00b6 var ( // Asc creates a query that sort the result ascending by specified field. Asc = rel . NewSortAsc // Desc creates a query that sort the result descending by specified field. Desc = rel . NewSortDesc )","title":"github.com/go-rel/rel/sort"},{"location":"reference/sort/#sort","text":"import \"github.com/go-rel/rel/sort\"","title":"sort"},{"location":"reference/sort/#overview","text":"Package sort is syntatic sugar for building sort query.","title":"Overview"},{"location":"reference/sort/#variables","text":"var ( // Asc creates a query that sort the result ascending by specified field. Asc = rel . NewSortAsc // Desc creates a query that sort the result descending by specified field. Desc = rel . NewSortDesc )","title":"Variables"},{"location":"reference/where/","text":"where \u00b6 import \"github.com/go-rel/rel/where\" Overview \u00b6 Package where is syntatic sugar for building where query. Variables \u00b6 var ( // And compares other filters using and. And = rel . And // Or compares other filters using or. Or = rel . Or // Not wraps filters using not. // It'll negate the filter type if possible. Not = rel . Not // Eq expression field equal to value. Eq = rel . Eq // Ne compares that left value is not equal to right value. Ne = rel . Ne // Lt compares that left value is less than to right value. Lt = rel . Lt // Lte compares that left value is less than or equal to right value. Lte = rel . Lte // Gt compares that left value is greater than to right value. Gt = rel . Gt // Gte compares that left value is greater than or equal to right value. Gte = rel . Gte // Nil check whether field is nil. Nil = rel . Nil // NotNil check whether field is not nil. NotNil = rel . NotNil // In check whethers value of the field is included in values. In = rel . In // InInt check whethers integer value of the field is included in values. InInt = rel . InInt // InUint check whethers unsigned integer value of the field is included in values. InUint = rel . InUint // InString check whethers string value of the field is included in values. InString = rel . InString // Nin check whethers value of the field is not included in values. Nin = rel . Nin // NinInt check whethers integer value of the field is not included in values. NinInt = rel . NinInt // NinUint check whethers unsigned integer value of the field is not included in values. NinUint = rel . NinUint // NinString check whethers string value of the field is not included in values. NinString = rel . NinString // Like compares value of field to match string pattern. Like = rel . Like // NotLike compares value of field to not match string pattern. NotLike = rel . NotLike // Fragment add custom filter. Fragment = rel . FilterFragment )","title":"github.com/go-rel/rel/where"},{"location":"reference/where/#where","text":"import \"github.com/go-rel/rel/where\"","title":"where"},{"location":"reference/where/#overview","text":"Package where is syntatic sugar for building where query.","title":"Overview"},{"location":"reference/where/#variables","text":"var ( // And compares other filters using and. And = rel . And // Or compares other filters using or. Or = rel . Or // Not wraps filters using not. // It'll negate the filter type if possible. Not = rel . Not // Eq expression field equal to value. Eq = rel . Eq // Ne compares that left value is not equal to right value. Ne = rel . Ne // Lt compares that left value is less than to right value. Lt = rel . Lt // Lte compares that left value is less than or equal to right value. Lte = rel . Lte // Gt compares that left value is greater than to right value. Gt = rel . Gt // Gte compares that left value is greater than or equal to right value. Gte = rel . Gte // Nil check whether field is nil. Nil = rel . Nil // NotNil check whether field is not nil. NotNil = rel . NotNil // In check whethers value of the field is included in values. In = rel . In // InInt check whethers integer value of the field is included in values. InInt = rel . InInt // InUint check whethers unsigned integer value of the field is included in values. InUint = rel . InUint // InString check whethers string value of the field is included in values. InString = rel . InString // Nin check whethers value of the field is not included in values. Nin = rel . Nin // NinInt check whethers integer value of the field is not included in values. NinInt = rel . NinInt // NinUint check whethers unsigned integer value of the field is not included in values. NinUint = rel . NinUint // NinString check whethers string value of the field is not included in values. NinString = rel . NinString // Like compares value of field to match string pattern. Like = rel . Like // NotLike compares value of field to not match string pattern. NotLike = rel . NotLike // Fragment add custom filter. Fragment = rel . FilterFragment )","title":"Variables"}]}